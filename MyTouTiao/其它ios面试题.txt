

第16章  动画

# anmition
动画的继承结构

CAAnimation(动画根类，不可直接使用){
    CAPropertyAnimation（属性动画，抽象类，不能直接使用）{
        CABasicAnimation（基本动画，可直接使用）{
              CASpringAnimation（弹性动画，可直接使用，iOS9新加）
        }
        CAKeyframeAnimation（关键帧动画，可直接使用）
    }
    CATransition（转场动画，可直接使用）
    CAAnimationGroup （组动画，可直接使用）
}

1、CAAnimation 

属性：
//动画的代理回调
@property(nullable, strong) id delegate;
//动画执行完以后是否移除动画,默认YES
@property(getter=isRemovedOnCompletion) BOOL removedOnCompletion;
//动画的动作规则,包含以下值
//kCAMediaTimingFunctionLinear 匀速
//kCAMediaTimingFunctionEaseIn 慢进快出
//kCAMediaTimingFunctionEaseOut 快进慢出
//kCAMediaTimingFunctionEaseInEaseOut 慢进慢出 中间加速
//kCAMediaTimingFunctionDefault 默认
@property(nullable, strong) CAMediaTimingFunction *timingFunction;

属性的详解：

委托：动画执行的代理，在动画开始前设定，不用显式的写在代码里，它包含两个方法：
动画开始回调
- (void)animationDidStart:(CAAnimation *)anim;
动画结束回调
- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag;
removedOnCompletion：动画完成后是否移除动画默认为YES此属性为YES时，在fillMode不可用，具体为什么不可用，可以自己结合两个属性分析一下，这里不再赘述。
timingFunction设置动画速度曲线，默认值上面已经给出下面说它的几个方法：
。这两个方法是一样的如果我们对系统自带的速度函数不满意，可以通过这两个函数创建一个自己喜欢的速度曲线函数，具体用法可以参考这篇文章CAMediaTimingFunction使用的
+ (instancetype)functionWithControlPoints:(float)c1x :(float)c1y :(float)c2x :(float)c2y;
- (instancetype)initWithControlPoints:(float)c1x :(float)c1y :(float)c2x :(float)c2y;
电子杂志曲线的函数的缓冲点，具体用法可以参考这篇文章：iOS-核心动画高级编程/ 10-缓冲
- (void)getControlPointAtIndex:(size_t)idx values:(float[2])ptr;



2、CAAnimation <CAMediaTiming>协议的属性

属性：
//开始时间.这个属性比较复杂,傻瓜用法为:CACurrentMediaTime() + x,
//其中x为延迟时间.如果设置 beginTime = CACurrentMediaTime() + 1.0,产生的效果为延迟一秒执行动画,下面详解原理
@property CFTimeInterval beginTime;
//动画执行时间,此属性和speed有关系speed默认为1.0,如果speed设置为2.0,那么动画执行时间则为duration*(1.0/2.0).
@property CFTimeInterval duration;
//动画执行速度,它duration的关系参考上面解释
@property float speed;
//动画的时间延迟,这个属性比较复杂,下面详解
@property CFTimeInterval timeOffset;
//重复执行次数
@property float repeatCount;
//重复执行时间,此属性优先级大于repeatCount.也就是说如果repeatDuration设置为1秒重复10次,那么它会在1秒内执行完动画.
@property CFTimeInterval repeatDuration;
//是否自动翻转动画,默认NO.如果设置YES,那么整个动画的执行效果为A->B->A.
@property BOOL autoreverses;
//动画的填充方式,默认为: kCAFillModeRemoved,包含以下值
//kCAFillModeForwards//动画结束后回到准备状态
//kCAFillModeBackwards//动画结束后保持最后状态
//kCAFillModeBoth//动画结束后回到准备状态,并保持最后状态
//kCAFillModeRemoved//执行完成移除动画
@property(copy) NSString *fillMode;


属性的详解：

BEGINTIME：刚才上面简单解释了下这个属性的用法：CACurrentMediaTime()+ x。会使动画延迟执行点¯x秒不知道到这里有没有人想过如果-x？会出现怎么样效果假设我们有执行一个3秒的动画，设置然后beginTime = CACurrentMediaTime()- 1.5那么执行动画你会发现动画只会执行后半段，就是也。只执行后面的3-1.5s的动画。为什么会这样？其实动画都有一个时间表（时间线）的概念。动画开始执行都是基于这个时间线的绝对时间，这个时间和它的父类有关（系统的属性注释可以看到）。默认的CALayer的的BEGINTIME为零，如果这个值为零的话，系统会把它设置为CACurrentMediaTime（），那么这个时间就是正常执行动画的时间：立即执行所以如果设置你beginTime=CACurrentMediaTime()+x;它会把它的执行时间线推迟x秒，就是也。晚执行x秒，如果你beginTime=CACurrentMediaTime()-x;那它开始的时候会从你动画对应的绝对时间开始执行。
timeOffset：时间偏移量，默认为0;既然它是时间偏移量，那么它即和动画时间相关这么解释：假设我们设置一个动画时间为5秒，动画执行的过程为1->2->3->4->5，这时候如果你设置timeOffset = 2s它那么的执行过程就会变成3->4->5->1->2如果你设置timeOffset = 4s那么它的执行过程就会变成5->1->2->3->4，这么说应该很明白了吧？

3、CAPropertyAnimation属性动画，抽象类，不能直接使用

属性：
//需要动画的属性值
@property(nullable, copy) NSString *keyPath;
//属性动画是否以当前动画效果为基础,默认为NO
@property(getter=isAdditive) BOOL additive;
//指定动画是否为累加效果,默认为NO
@property(getter=isCumulative) BOOL cumulative;
//此属性相当于CALayer中的transform属性,下面会详解
@property(nullable, strong) CAValueFunction *valueFunction;


属性的详解：
CAPropertyAnimation是属性动画顾名思义也就是针对属性才可以做的动画那它可以对谁的属性可以做动画是的CALayer的属性，比如：？界限，位置等那么问题来了，我们改变的CALayer的位置可以。设置直接[CAPropertyAnimation animationWithKeyPath:@"position"]如果我们设置它的变换（CATransform3D）呢？CATransform3D是一个矩阵，如果我们想为它做动画怎么办？下面这个属性就是用来解决这个问题的。

valueFunction：我们来看它可以设置的值：
kCAValueFunctionRotateX
kCAValueFunctionRotateY
kCAValueFunctionRotateZ
kCAValueFunctionScale
kCAValueFunctionScaleX
kCAValueFunctionScaleY
kCAValueFunctionScaleZ
kCAValueFunctionTranslate
kCAValueFunctionTranslateX
kCAValueFunctionTranslateY
kCAValueFunctionTranslateZ


方法
//创建一个CAPropertyAnimation对象
+ (instancetype)animationWithKeyPath:(nullable NSString *)path;

属性归总：
CATransform3D{
rotation旋转
transform.rotation.x
transform.rotation.y
transform.rotation.z

scale缩放
transform.scale.x
transform.scale.y
transform.scale.z

translation平移
transform.translation.x
transform.translation.y
transform.translation.z
}

CGPoint{
position
position.x
position.y
}

CGRect{
bounds
bounds.size
bounds.size.width
bounds.size.height

bounds.origin
bounds.origin.x
bounds.origin.y
}

property{
opacity
backgroundColor
cornerRadius
borderWidth
contents

Shadow{
shadowColor
shadowOffset
shadowOpacity
shadowRadius
}
}
总结：CAAnimation是基类，CAPropertyAnimation是抽象类，两者都不可以直接使用，那我们只有使用它的子类了。


4、CABasicAnimation基本动画

属性：
//开始值
@property(nullable, strong) id fromValue;
//结束值
@property(nullable, strong) id toValue;
//结束值
@property(nullable, strong) id byValue;

属性详解：
这三个属性之间的规则

fromValue状语从句：toValue不为空，的动画会效果从fromValue的值变化到toValue。
fromValue状语从句：byValue都不为空，的动画效果将会从fromValue变化到fromValue+byValue
toValue状语从句：byValue都不为空，的动画效果将会从toValue-byValue变化到toValue
只有fromValue的值不为空，的动画效果将会从fromValue的值变化到当前的状态。
只有toValue的值不为空，的动画效果将会从当前状态的值变化到toValue的值。
只有byValue的值不为空，动画的效果将会从当前的值变化到（当前状态的值+ byValue）的值。
CABasicAnimation看起来不太复杂，但实际只用这个就足以可以做很多种动画了

主要代码：
-(void)animationBegin:(UIButton *)btn{
        CABasicAnimation *animation = nil;
        switch (btn.tag) {
        case 0:{
        //淡如淡出
        animation = [CABasicAnimation animationWithKeyPath:@"opacity"];
        [animation setFromValue:@1.0];
        [animation setToValue:@0.1];
        }break;
        case 1:{
        //缩放
        animation = [CABasicAnimation animationWithKeyPath:@"transform.scale"];
        [animation setFromValue:@1.0];//设置起始值
        [animation setToValue:@0.1];//设置目标值
        }break;
        case 2:{
        //旋转
        animation = [CABasicAnimation animationWithKeyPath:@"transform.rotation"];
        //setFromValue不设置,默认以当前状态为准
        [animation setToValue:@(M_PI)];
        }break;
        case 3:{
        //平移
        animation = [CABasicAnimation animationWithKeyPath:@"position"];
        //setFromValue不设置,默认以当前状态为准
        [animation setToValue:[NSValue valueWithCGPoint:CGPointMake(self.view.center.x, self.view.center.y + 200)]];
        }break;
        default:break;
        }
        [animation setDelegate:self];//代理回调
        [animation setDuration:0.25];//设置动画时间，单次动画时间
        [animation setRemovedOnCompletion:NO];//默认为YES,设置为NO时setFillMode有效
        /**
        *设置时间函数CAMediaTimingFunction
        *kCAMediaTimingFunctionLinear 匀速
        *kCAMediaTimingFunctionEaseIn 开始速度慢，后来速度快
        *kCAMediaTimingFunctionEaseOut 开始速度快 后来速度慢
        *kCAMediaTimingFunctionEaseInEaseOut = kCAMediaTimingFunctionDefault 中间速度快，两头速度慢
        */
        [animation setTimingFunction:[CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]];
        //设置自动翻转
        //设置自动翻转以后单次动画时间不变，总动画时间增加一倍，它会让你前半部分的动画以相反的方式动画过来
        //比如说你设置执行一次动画，从a到b时间为1秒，设置自动翻转以后动画的执行方式为，先从a到b执行一秒，然后从b到a再执行一下动画结束
        [animation setAutoreverses:YES];
        //kCAFillModeForwards//动画结束后回到准备状态
        //kCAFillModeBackwards//动画结束后保持最后状态
        //kCAFillModeBoth//动画结束后回到准备状态,并保持最后状态
        //kCAFillModeRemoved//执行完成移除动画
        [animation setFillMode:kCAFillModeBoth];
        //将动画添加到layer,添加到图层开始执行动画，
        //注意:key值的设置与否会影响动画的效果
        //如果不设置key值每次执行都会创建一个动画，然后创建的动画会叠加在图层上
        //如果设置key值，系统执行这个动画时会先检查这个动画有没有被创建，如果没有的话就创建一个，如果有的话就重新从头开始执行这个动画
        //你可以通过key值获取或者删除一个动画:
        //[self.demoView.layer animationForKey:@""];
        //[self.demoView.layer removeAnimationForKey:@""]
        [self.demoView.layer addAnimation:animation forKey:@"baseanimation"];
}

/**
*  动画开始和动画结束时 self.demoView.center 是一直不变的，说明动画并没有改变视图本身的位置
*/
- (void)animationDidStart:(CAAnimation *)anim{
NSLog(@"动画开始------：%@",    NSStringFromCGPoint(self.demoView.center));
}
- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag{
NSLog(@"动画结束------：%@",    NSStringFromCGPoint(self.demoView.center));
}


CASpringAnimation弹性动画

属性：
//理解下面的属性的时候可以结合现实物理现象,比如把它想象成一个弹簧上挂着一个金属小球
//质量,振幅和质量成反比
@property CGFloat mass;
//刚度系数(劲度系数/弹性系数),刚度系数越大,形变产生的力就越大,运动越快
@property CGFloat stiffness;
//阻尼系数,阻止弹簧伸缩的系数,阻尼系数越大,停止越快,可以认为它是阻力系数
@property CGFloat damping;
//初始速率,动画视图的初始速度大小速率为正数时,速度方向与运动方向一致,速率为负数时,速度方向与运动方向相反.
@property CGFloat initialVelocity;
//结算时间,只读.返回弹簧动画到停止时的估算时间，根据当前的动画参数估算通常弹簧动画的时间使用结算时间比较准确
@property(readonly) CFTimeInterval settlingDuration;

代码1:
CASpringAnimation *spring = [CASpringAnimation animationWithKeyPath:@"position.y"];
spring.damping = 5;
spring.stiffness = 100;
spring.mass = 1;
spring.initialVelocity = 0;
spring.duration = spring.settlingDuration;
spring.fromValue = @(self.demoView1.center.y);
spring.toValue = @(self.demoView1.center.y + (btn.selected?+200:-200));
spring.fillMode = kCAFillModeForwards;
[self.demoView1.layer addAnimation:spring forKey:nil];

代码2:自定义弹性动画
#import "UIView+ShakeAnimation.h"
#import <objc/runtime.h>
typedef void (^RunAnimationBlock)();
@interface UIView ()
@property (nonatomic,  copy)RunAnimationBlock block;
@end

@implementation UIView (ShakeAnimation)

-(void)startAnimationFromFrame:(CGRect)framef
toFrame:(CGRect)framet
duration:(CGFloat)duration
shakeTimes:(NSInteger)times
stretchPercent:(CGFloat)stretchPercent
completion:(void (^)(BOOL finished))completion
{
self.layer.masksToBounds = YES;

__block CGFloat perTime = duration / times;
__block CGFloat perx = (framet.origin.x - framef.origin.x) * stretchPercent / times;
__block CGFloat pery = (framet.origin.y - framef.origin.y) * stretchPercent / times;
__block CGFloat perw = (framet.size.width - framef.size.width) * stretchPercent / times;
__block CGFloat perh = (framet.size.height - framef.size.height) * stretchPercent / times;

__block UIView * tmpView = self;
__block NSInteger tmpTimes = (NSInteger)times;
__block NSInteger tmpsymbol = -1;

__weak typeof(self) weakSelf = self;
self.block = ^{

[UIView animateWithDuration:perTime animations:^{

CGFloat x = framet.origin.x + perx * tmpTimes;
CGFloat y = framet.origin.y + pery * tmpTimes;
CGFloat w = framet.size.width + perw * tmpTimes;
CGFloat h = framet.size.height + perh * tmpTimes;
CGRect rect = CGRectMake(x, y, w, h);

tmpView.frame = rect;
}completion:^(BOOL finished) {

tmpTimes = tmpTimes + tmpsymbol;
tmpTimes = - tmpTimes;
tmpsymbol = - tmpsymbol;
if (tmpTimes != 0) {
weakSelf.block();
}else{
[UIView animateWithDuration:perTime animations:^{
tmpView.frame = framet;
}completion:^(BOOL finished) {
completion(YES);
}];
}
}];
};

self.block();
}
static char RunAnimationBlockKey;
-(RunAnimationBlock)block{
return objc_getAssociatedObject(self, &RunAnimationBlockKey);
}
-(void)setBlock:(RunAnimationBlock)block{
objc_setAssociatedObject(self, &RunAnimationBlockKey, block, OBJC_ASSOCIATION_COPY_NONATOMIC);
}
@end
调用：

[self.demoView2 startAnimationFromFrame:CGRectMake(10, 300, 100, 100)
toFrame:CGRectMake(10, 300, 300, 100)
duration:0.5
shakeTimes:5
stretchPercent:0.3
completion:^(BOOL finished) {
NSLog(@"======over======:%@",self.demoView1);
}];



5、CAKeyframeAnimation关键帧动画
属性：
//关键帧值数组,一组变化值
@property(nullable, copy) NSArray *values;
//关键帧帧路径,优先级比values大
@property(nullable) CGPathRef path;
//每一帧对应的时间,时间可以控制速度.它和每一个帧相对应,取值为0.0-1.0,不设则每一帧时间相等.
@property(nullable, copy) NSArray<NSNumber *> *keyTimes;
//每一帧对应的时间曲线函数,也就是每一帧的运动节奏
@property(nullable, copy) NSArray<CAMediaTimingFunction *> *timingFunctions;
//动画的计算模式,默认值: kCAAnimationLinear.有以下几个值:
//kCAAnimationLinear//关键帧为座标点的时候,关键帧之间直接直线相连进行插值计算;
//kCAAnimationDiscrete//离散的,也就是没有补间动画
//kCAAnimationPaced//平均，keyTimes跟timeFunctions失效
//kCAAnimationCubic对关键帧为座标点的关键帧进行圆滑曲线相连后插值计算,对于曲线的形状还可以通过tensionValues,continuityValues,biasValues来进行调整自定义,keyTimes跟timeFunctions失效
//kCAAnimationCubicPaced在kCAAnimationCubic的基础上使得动画运行变得均匀,就是系统时间内运动的距离相同,,keyTimes跟timeFunctions失效
@property(copy) NSString *calculationMode;
//动画的张力,当动画为立方计算模式的时候此属性提供了控制插值,因为每个关键帧都可能有张力所以连续性会有所偏差它的范围为[-1,1].同样是此作用
@property(nullable, copy) NSArray<NSNumber *> *tensionValues;
//动画的连续性值
@property(nullable, copy) NSArray<NSNumber *> *continuityValues;
//动画的偏斜率
@property(nullable, copy) NSArray<NSNumber *> *biasValues;
//动画沿路径旋转方式,默认为nil.它有两个值:
//kCAAnimationRotateAuto//自动旋转,
//kCAAnimationRotateAutoReverse//自动翻转
@property(nullable, copy) NSString *rotationMode;

6、CAAnimationGroup动画组

属性

//只有一个属性,数组中接受CAAnimation元素
@property(nullable, copy) NSArray<CAAnimation *> *animations;

可以看到CAAnimationGroup只有一个属性一个CAAnimation数组。而且它继承于CAAnimation，它具有CAAnimation的特性，所以它的用法和CAAnimation是一样的，不同的是他可以包含ñ个动画，也就是说他可以接受很多个CAAnimation并且可以让它们一起开始，这就造成了动画效果的叠加，效果就是ñ个动画同时进行。

7、CATransition转场动画

//转场类型,字符串类型参数.系统提供了四中动画形式:
//kCATransitionFade//逐渐消失
//kCATransitionMoveIn//移进来
//kCATransitionPush//推进来
//kCATransitionReveal//揭开
//另外,除了系统给的这几种动画效果,我们还可以使用系统私有的动画效果:
//@"cube",//立方体翻转效果
//@"oglFlip",//翻转效果
//@"suckEffect",//收缩效果,动画方向不可控
//@"rippleEffect",//水滴波纹效果,动画方向不可控
//@"pageCurl",//向上翻页效果
//@"pageUnCurl",//向下翻页效果
//@"cameralIrisHollowOpen",//摄像头打开效果,动画方向不可控
//@"cameraIrisHollowClose",//摄像头关闭效果,动画方向不可控
@property(copy) NSString *type;
//转场方向,系统一共提供四个方向:
//kCATransitionFromRight//从右开始
//kCATransitionFromLeft//从左开始
//kCATransitionFromTop//从上开始
//kCATransitionFromBottom//从下开始
@property(nullable, copy) NSString *subtype;
//开始进度,默认0.0.如果设置0.3,那么动画将从动画的0.3的部分开始
@property float startProgress;
//结束进度,默认1.0.如果设置0.6,那么动画将从动画的0.6部分以后就会结束
@property float endProgress;
//开始进度
@property(nullable, strong) id filter;

CATransition也是继承CAAnimation，系统默认提供了12种动画样式，加上4个动画方向，除了方向不可控的四种效果外，大概一共提供了36种动画。

另外系统还给UIView的添加了很多分类方法可以快速完成一些简单的动画，如下：

UIView（UIViewAnimation）

@interface UIView(UIViewAnimation)

+ (void)beginAnimations:(nullable NSString *)animationID context:(nullable void *)context;  // additional context info passed to will start/did stop selectors. begin/commit can be nested
//提交动画
+ (void)commitAnimations;
//设置代理
+ (void)setAnimationDelegate:(nullable id)delegate;                          //设置动画开始方法
+ (void)setAnimationWillStartSelector:(nullable SEL)selector;                
//设置动画结束方法
+ (void)setAnimationDidStopSelector:(nullable SEL)selector;
//设置动画时间:default = 0.2
+ (void)setAnimationDuration:(NSTimeInterval)duration;              
//设置动画延迟开始时间:default = 0.0
+ (void)setAnimationDelay:(NSTimeInterval)delay;
//设置动画延迟开始日期:default = now ([NSDate date])
+ (void)setAnimationStartDate:(NSDate *)startDate;                  
//设置动画运动曲线:default =UIViewAnimationCurveEaseInOut
//UIViewAnimationCurveEaseInOut,//慢进慢出
//UIViewAnimationCurveEaseIn, //慢进快出
//UIViewAnimationCurveEaseOut,//快进慢出
//UIViewAnimationCurveLinear//匀速
+ (void)setAnimationCurve:(UIViewAnimationCurve)curve;              
//设置重复次数: default = 0.0.  May be fractional
+ (void)setAnimationRepeatCount:(float)repeatCount;
//设置是否翻转动画: default = NO. used if repeat 
+ (void)setAnimationRepeatAutoreverses:(BOOL)repeatAutoreverses;
//设置动画是否从当前状态开始:default = NO
+ (void)setAnimationBeginsFromCurrentState:(BOOL)fromCurrentState;
//设置动画类型
+ (void)setAnimationTransition:(UIViewAnimationTransition)transition forView:(UIView *)view cache:(BOOL)cache; 
//设置动画是否有效
+ (void)setAnimationsEnabled:(BOOL)enabled;
//
+ (BOOL)areAnimationsEnabled;
//
+ (void)performWithoutAnimation:(void (^)(void))actionsWithoutAnimation
//
+ (NSTimeInterval)inheritedAnimationDuration 
@end


UIView（UIViewAnimationWithBlocks）
@interface UIView(UIViewAnimationWithBlocks)
//以下方法都大同小异,就不一一做注释了
+ (void)animateWithDuration:(NSTimeInterval)duration delay:(NSTimeInterval)delay options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^ __nullable)(BOOL finished))completion;
+ (void)animateWithDuration:(NSTimeInterval)duration animations:(void (^)(void))animations completion:(void (^ __nullable)(BOOL finished))completion 
+ (void)animateWithDuration:(NSTimeInterval)duration animations:(void (^)(void))animations;
+ (void)animateWithDuration:(NSTimeInterval)duration delay:(NSTimeInterval)delay usingSpringWithDamping:(CGFloat)dampingRatio initialSpringVelocity:(CGFloat)velocity options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^ __nullable)(BOOL finished))completion
+ (void)transitionWithView:(UIView *)view duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options animations:(void (^ __nullable)(void))animations completion:(void (^ __nullable)(BOOL finished))completion;
+ (void)transitionFromView:(UIView *)fromView toView:(UIView *)toView duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options completion:(void (^ __nullable)(BOOL finished))completion;
+ (void)performSystemAnimation:(UISystemAnimation)animation onViews:(NSArray<__kindof UIView *> *)views options:(UIViewAnimationOptions)options animations:(void (^ __nullable)(void))parallelAnimations completion:(void (^ __nullable)(BOOL finished))completion NS_AVAILABLE_IOS(7_0);

@end


UIView（UIViewKeyframeAnimations）
+ (void)animateKeyframesWithDuration:(NSTimeInterval)duration delay:(NSTimeInterval)delay options:(UIViewKeyframeAnimationOptions)options animations:(void (^)(void))animations completion:(void (^ __nullable)(BOOL finished))completion;
+ (void)addKeyframeWithRelativeStartTime:(double)frameStartTime relativeDuration:(double)frameDuration animations:(void (^)(void))animations

//单视图转场动画
+ (void)transitionWithView:(UIView *)view
duration:(NSTimeInterval)duration 
options:(UIViewAnimationOptions)options
animations:(void (^ __nullable)(void))animations
completion:(void (^ __nullable)(BOOL finished))completion
//双视图转场动画
+ (void)transitionFromView:(UIView *)fromView
toView:(UIView *)toView 
duration:(NSTimeInterval)duration 
options:(UIViewAnimationOptions)options
completion:(void (^ __nullable)(BOOL finished))completion

这两个都是转场动画，不同的是第一个是单视图转场，第二个是双视图转场不过需要注意的是：单视图转场动画只能用作属性动画做不到的转场效果，比如属性动画不能给的UIImageView的形象赋值操作做动画效果等。

我们可以看到以上两个方法中都有一个共同的参数：
UIViewAnimationOptions
typedef NS_OPTIONS(NSUInteger, UIViewAnimationOptions) {
UIViewAnimationOptionLayoutSubviews            = 1 <<  0,
UIViewAnimationOptionAllowUserInteraction      = 1 <<  1, // turn on user interaction while animating
UIViewAnimationOptionBeginFromCurrentState     = 1 <<  2, // start all views from current value, not initial value
UIViewAnimationOptionRepeat                    = 1 <<  3, // repeat animation indefinitely
UIViewAnimationOptionAutoreverse               = 1 <<  4, // if repeat, run animation back and forth
UIViewAnimationOptionOverrideInheritedDuration = 1 <<  5, // ignore nested duration
UIViewAnimationOptionOverrideInheritedCurve    = 1 <<  6, // ignore nested curve
UIViewAnimationOptionAllowAnimatedContent      = 1 <<  7, // animate contents (applies to transitions only)
UIViewAnimationOptionShowHideTransitionViews   = 1 <<  8, // flip to/from hidden state instead of adding/removing
UIViewAnimationOptionOverrideInheritedOptions  = 1 <<  9, // do not inherit any options or animation type

UIViewAnimationOptionCurveEaseInOut            = 0 << 16, // default
UIViewAnimationOptionCurveEaseIn               = 1 << 16,
UIViewAnimationOptionCurveEaseOut              = 2 << 16,
UIViewAnimationOptionCurveLinear               = 3 << 16,

UIViewAnimationOptionTransitionNone            = 0 << 20, // default
UIViewAnimationOptionTransitionFlipFromLeft    = 1 << 20,
UIViewAnimationOptionTransitionFlipFromRight   = 2 << 20,
UIViewAnimationOptionTransitionCurlUp          = 3 << 20,
UIViewAnimationOptionTransitionCurlDown        = 4 << 20,
UIViewAnimationOptionTransitionCrossDissolve   = 5 << 20,
UIViewAnimationOptionTransitionFlipFromTop     = 6 << 20,
UIViewAnimationOptionTransitionFlipFromBottom  = 7 << 20,
} NS_ENUM_AVAILABLE_IOS(4_0);

可以看到系统给到的是一个位移枚举，这就意味着这个枚举可以多个值同时使用，但是怎么用呢？其实那些枚举值可以分为三个部分。
我们分别看一下每个枚举的意思：
第一部分：动画效果
UIViewAnimationOptionTransitionNone//没有效果
UIViewAnimationOptionTransitionFlipFromLeft//从左水平翻转
UIViewAnimationOptionTransitionFlipFromRight//从右水平翻转
UIViewAnimationOptionTransitionCurlUp//翻书上掀
UIViewAnimationOptionTransitionCurlDown//翻书下盖UIViewAnimationOptionTransitionCrossDissolve//融合
UIViewAnimationOptionTransitionFlipFromTop//从上垂直翻转                    UIViewAnimationOptionTransitionFlipFromBottom//从下垂直翻转

第二部分：动画运动曲线
//开始慢，加速到中间，然后减慢到结束
UIViewAnimationOptionCurveEaseInOut
//开始慢，加速到结束
UIViewAnimationOptionCurveEaseIn
//开始快，减速到结束
UIViewAnimationOptionCurveEaseOut
//线性运动
UIViewAnimationOptionCurveLinear

第三部分：其他
//默认，跟父类作为一个整体
UIViewAnimationOptionLayoutSubviews
//设置了这个，主线程可以接收点击事件
UIViewAnimationOptionAllowUserInteraction
//从当前状态开始动画，父层动画运动期间，开始子层动画.
UIViewAnimationOptionBeginFromCurrentState
//重复执行动画，从开始到结束， 结束后直接跳到开始态
UIViewAnimationOptionRepeat
//反向执行动画，结束后会再从结束态->开始态
UIViewAnimationOptionAutoreverse
//忽略继承自父层持续时间，使用自己持续时间（如果存在）
UIViewAnimationOptionOverrideInheritedDuration
//忽略继承自父层的线性效果，使用自己的线性效果（如果存在）
UIViewAnimationOptionOverrideInheritedCurve
//允许同一个view的多个动画同时进行     
UIViewAnimationOptionAllowAnimatedContent     
//视图切换时直接隐藏旧视图、显示新视图，而不是将旧视图从父视图移除（仅仅适用于转场动画）             UIViewAnimationOptionShowHideTransitionViews
//不继承父动画设置或动画类型.
UIViewAnimationOptionOverrideInheritedOptions

这下可以看到，这些枚举功能都不一样但是可以随意组合，但是组合的时候需要注意，类型同一枚举的一起不能使用比如UIViewAnimationOptionCurveEaseIn状语从句：UIViewAnimationOptionCurveEaseOut





              
            
                  
第17章

73、iOS获取设备唯一标识 https://blog.csdn.net/u014795020/article/details/72667320
前言

目前市面应用普遍采用用户体验，涉及到部分重要功能时候才提醒用户注册账户，而用户之前的操作，比如收藏，点赞，关注等内容需要同时关联进注册的账户，那么根据什么记录用户的操作信息就尤为重要。下面就列出我之前收集资料总结的方案。

UDID

UDID（Unique Device Identifier），iOS 设备的唯一识别码，是一个40位十六进制序列（越狱的设备通过某些工具可以改变设备的 UDID），移动网络可以利用 UDID 来识别移动设备。 
许多开发者把 UDID 跟用户的真实姓名、密码、住址、其它数据关联起来，网络窥探者会从多个应用收集这些数据，然后顺藤摸瓜得到这个人的许多隐私数据，同时大部分应用确实在频繁传输 UDID 和私人信息。 为了避免集体诉讼，苹果最终决定在 iOS 5 的时候，将这一惯例废除。 
现在应用试图获取 UDID 已被禁止且不允许上架。

MAC 地址

MAC（Medium / Media Access Control）地址，用来表示互联网上每一个站点的标示符，是一个六个字节（48位）的十六进制序列。前三个字节是由 IEEE 的注册管理机构 RA 负责给不同厂家分配的”编制上唯一的标示符（Organizationally Unique Identifier)”，后三个字节由各厂家自行指派给生产的适配器接口，称为扩展标示符。 
MAC 地址在网络上用来区分设备的唯一性，接入网络的设备都有一个MAC地址，他们肯定都是唯一的。一部 iPhone 上可能有多个 MAC 地址，包括 WIFI 的、SIM 的等，但是 iTouch 和 iPad 上就有一个 WIFI 的，因此只需获取 WIFI 的 MAC 地址就好了。一般会采取 MD5（MAC 地址 + bundleID）获取唯一标识。 
但是 MAC 地址和 UDID 一样，存在隐私问题， iOS 7 之后，所有设备请求 MAC 地址会返回一个固定值，这个方法也不攻自破了。

OpenUDID

UDID 被弃用后，广大开发者需要寻找一个可以替代的 UDID，并且不受苹果控制的方案，由此，OpenUDID 成为了当时使用最广泛的开源 UDID 代替方案。OpenUDID 利用一个非常巧妙的方法在不同程序间存储标示符：在粘贴板中用了一个特殊的名称来存储标示符，通过这种方法，其他应用程序也可以获取。 
苹果在 iOS 7 之后对粘贴板做了限制，导致同一个设备上的应用间，无法再共享一个 OpenUDID。

UUID + 自己存储

UUID（Universally Unique IDentifier），通用唯一标示符，是一个32位的十六进制序列，使用小横线来连接：8-4-4-4-12，通过 NSUUID（iOS 6 之后）[NSUUID UUID].UUIDString 或者 CFUUID（iOS 2 之后） CFBridgingRelease(CFUUIDCreateString(kCFAllocatorDefault, CFUUIDCreate(kCFAllocatorDefault))) 来获取，
但是每次获取的值都不一样，需要自己存储。keychain存储

推送 token + bundleID

推送 token 保证设备唯一，但是必须有网络情况下才能工作，该方法不依赖于设备本身，但依赖于 apple push，而 apple push 有时候会抽风的。

IDFA

IDFA-identifierForIdentifier（广告标示符），在同一个设备上的所有 APP 都会取到相同的值，是苹果专门给各广告提供商用来追踪用户而设定的。虽然 iPhone 默认是允许追踪的，而且一般用户都不知道有这么个设置，但是用户可以在 设置 - 隐私 - 广告追踪 里重置此 ID 的值，或者限制此 ID 的使用，所以有可能会取不到值。

IDFV

IDFV-identifierForVendor（Vendor 标示符），通过 [UIDevice currentDevice].identifierForVendor.UUIDString 来获取。是通过 bundleID 的反转的前两部分进行匹配，如果相同是同一个 Vendor ，例如对于 com.mayan.app_1 和 com.mayan.app_2 这两个 bundleID 来说，就属于同一个 Vendor ，共享同一个 IDFV，和 IDFA 不同的是，IDFV 的值一定能取到的，所以非常适合于作为内部用户行为分析的主 ID 来识别用户。但是用户删除了该 APP ，则 IDFV 值会被重置，再次安装此 APP ，IDFV 的值和之前的不同。

IDFV + keychain

通过以上几种存储唯一标识的方法分析，总结一下各有优劣。很多方法被苹果禁止，或者漏洞太多，越来越不被开发者利用，现在苹果主推IDFA和IDFV这两种方法，分别对外和对内，但是IDFV在App重新安装时候会被更改，所以我的方法是通过第一次生成的IDFV存储到keychain中，以后每次获取标识符都从keychain中获取。注意：keychain在iOS 7之后开放给开发者，但是在iOS 10中默认是关闭的，需要开发者手动打开。
我的项目用的是
+(NSString*) getCurrentDeviceUDID
{
    return [OpenUDID value];
}    






第18章

const,static,extern,#define super superclass class
#define 定义一般是以项目名开头，以KEY结尾 ，意为取值 
#define zlburl @"http://"  
常用的字符串 常用的代码 抽成宏
const define区别
推荐常有字符串常量的时候使用const 
NSString *const  cent = @"zlbcent";//去掉CONST是全局变量

#define是预编译时候   const编译的时候
#define不会检查错语   const会检查语法错误
#define可以定义代码   const不会定义代码
定义太多的宏会造成编译时间过长 ，const这个代码只会编译一次，宏是只要用到的地方都进行了替换 
因此常用的字符串使用const定义
一个错误的说法：大量使用宏会造成内存过大
这个说法是错误的，NSLOG("%@",zlburl)NSLOG("%@",zlburl)NSLOG("%@",zlburl)打印多次后还是同一个内存地址，因为常量会放到常量区里面，只分配一次内存

const用于修饰基本变量和指针变量，且修饰的变量指读，const一定放到变量的左边靠近变量

下面这两写法一样
int const a = 0
const int a = 0


下面有区别
int a = 5
int * const p = &a//报错
const int  *p = 3 //报错
int  const *p = 3 //报错
int const* const p = &a//报错
const int* const p = &a//报错

const修饰对象变量

NSString *const name = @"123";//123不能改
NSString const *name = @"123";//123能改

const使用场景
定义一个全局指读变量
NSString *const a = @"123";
方法中定义指读参数
-(void)test(NSString *const)name
{
   name = @"oo";//不能修改
}

static 作用：修饰一个局部变量，修饰全局变量
修饰局部变量，会延长其生命周期，只要成员运行，局部变量一直存在，局部变量只会在程序启动分配一次内存
-(void)tt
{
  static int a = 1;
  a++;
  }
修饰全局变量，只会在当前文件使用，修改了全局变量作用局

extern只能用来声明一个全局变量，不能用来定义变量，extern int a = 10 ;ctrl b 会报错
int a = 3;
extern int a;//这个不报错
作用是用来声明全局变量
c.m中  int a = 5;
b.m中要使用a ，需要extern int a;
如果 static int a = 1;  b.m extern int a 编译会报错的

全局变量定义 static const联合使用
NSString *const name = @"123";
只能在本文件夹用的全局变量
static NSString *const name = @"123";

extern const联合使用
NSString *const name = @"123";
extern NSString *const name；
为了防止全局变量冲突，所有全局变量定义到一个文件夹里
为了遵守苹果的风格，extern换成UIKIT_EXTERN

[super class] //super指向父类的标志，是一个编译标识符，不是一个指针，获取该对象的类名，而非父类，因为super的本质是拿到当前的对象去调用父类的方法
[self class]//获取该对象的类名
[self superclass]//获取该类父对象类名


项目中遇到的一个问题
创建一个person类，在使用时提示没有定义
分析：这个类有的，没定义，说明这个类没有参与编译
在xcode 中build phases --complle source添加上.m就可以了
造成原因是创建一个项目的时候下边有个选项未打勾，所以就不参与编译





第19章

数据存储

1.sqlite中插入特殊字符的方法？
   在特殊字符前面加“/”
   如：方法：keyWord = keyWord.replace("/","//");
   
2.codedata

CoreData是对SQLite数据库的封装。
Core Data使用起来相对直接使用SQLite3的API而言更加的面向对象，操作过程通常分为以下几个步骤：

创建管理上下文
创建管理上下可以细分为：加载模型文件->指定数据存储路径->创建对应数据类型的存储->创建管理对象上下方并指定存储。
经过这几个步骤之后可以得到管理对象上下文NSManagedObjectContext，以后所有的数据操作都由此对象负责。同时如果是第一次创建上下文，Core Data会自动创建存储文件（例如这里使用SQLite3存储），并且根据模型对象创建对应的表结构。
查询数据
对于有条件的查询，在Core Data中是通过谓词来实现的。首先创建一个请求，然后设置请求条件，最后调用上下文执行请求的方法。
插入数据
插入数据需要调用实体描述对象NSEntityDescription返回一个实体对象，然后设置对象属性，最后保存当前上下文即可。这里需要注意，增、删、改操作完最后必须调用管理对象上下文的保存方法，否则操作不会执行。
删除数据
删除数据可以直接调用管理对象上下文的deleteObject方法，删除完保存上下文即可。注意，删除数据前必须先查询到对应对象。
修改数据
修改数据首先也是取出对应的实体对象，然后通过修改对象的属性，最后保存上下文。

NSManagedObject：
    这个类对应数据库的一张表，这个类对象对应数据库中表的一条数据，是是NSObject的子类。
    
NSManagedObjectModel：包含一个或多个NSEntityDescription对象，NSEntityDescription记录的就是实体的描述信息。即包含了多张表
    
NSManagedObjectContext：
    用于操作数据库，对数据库进行增删查改。在多线程中不安全，如果实现多线程中操作数据库
    一个线程对应一个NSManagedObjectContext。
    
NSPersistentStoreCoordinator:
    决定数据存储的位置 (SQLite/XML/其它文件中)，NSManagedObjectContext多个对	象
    可以使用NSPersistentStoreCoordinator同一个对象实例，多对一，因为NSManagedObjectContext会在使用NSPersistentStoreCoordinator
    前上锁，NSPersistentStoreCoordinator对象相当于存储在本地的数据库，NSManagedObjectContext对其进行增删查改。
    
    
CoreData 数据库增删查改：https://www.jianshu.com/p/332cba029b95
    1。xcode创建项目的时候，勾选Use Core Data 会自动创建coreData模型文件，
    不勾选，右键新建文件，选Data Model创建一个模型文件
    
    2。选中模型文件，创建多个实体，及多张表，创建一个Student 实体（第一字母必须是大写），以及添加一些name、age、sex 等属性
    Add Entity:创建一个实体，即创建一张表
    Attribues:添加属性 类型
    Releationships:表之间的关系，如一对多，多对多，一对一
    
    3。避免崩溃
    选中student实体，最右边第三个图标点开codegen(代码生成)选：Manual/none
    最右边第一个图标点开：code generation - lanuage(代码生成语言)object-c
    
    4。生成对应实体的实体类 editor - create NSManagedObject subclass
    生成如下文件：
    Student+CoreDataProperties.h
    Student+CoreDataProperties.m
    Student+CoreDataClass.h
    Student+CoreDataClass.m
    
    5。生成上下文和数据库关联
            //创建数据库
         - (void)createSqlite{
    
        //1、创建模型对象
        //获取模型路径
        NSURL *modelURL = [[NSBundle mainBundle] URLForResource:@"Model" withExtension:@"momd"];
        //根据模型文件创建模型对象
        NSManagedObjectModel *model = [[NSManagedObjectModel alloc] initWithContentsOfURL:modelURL];
    
        //2、创建持久化存储助理：数据库
        //利用模型对象创建助理对象
        NSPersistentStoreCoordinator *store = [[NSPersistentStoreCoordinator alloc] initWithManagedObjectModel:model];
    
        //数据库的名称和路径
        NSString *docStr = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];
        NSString *sqlPath = [docStr stringByAppendingPathComponent:@"coreData.sqlite"];
        NSLog(@"数据库 path = %@", sqlPath);
        NSURL *sqlUrl = [NSURL fileURLWithPath:sqlPath];
    
        NSError *error = nil;
        //设置数据库相关信息 添加一个持久化存储库并设置类型和路径，NSSQLiteStoreType：SQLite作为存储库
        [store addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:sqlUrl options:nil error:&error];
    
        if (error) {
            NSLog(@"添加数据库失败:%@",error);
        } else {
            NSLog(@"添加数据库成功");
        }
    
        //3、创建上下文 保存信息 对数据库进行操作
        NSManagedObjectContext *context = [[NSManagedObjectContext alloc] initWithConcurrencyType:NSMainQueueConcurrencyType];
   
        //关联持久化助理
        context.persistentStoreCoordinator = store;
        _context = context;

    }
    
    6。Appdelegate中创建数据库助理对象
             AppDelegate * appDelegate = (AppDelegate *)[UIApplication sharedApplication].delegate;
    
             NSPersistentContainer * container = appDelegate.persistentContainer;
    
             //返回沙盒中存储数据库的文件夹URL路径，这是一个静态方法，表示数据库的文件路径是唯一的
             NSURL * url = [NSPersistentContainer defaultDirectoryURL];
    
             NSManagedObjectContext *viewContext = container.viewContext;
    
             NSManagedObjectModel *managedObjectModel = container.managedObjectModel;
    
             NSPersistentStoreCoordinator *persistentStoreCoordinator = container.persistentStoreCoordinator;

             //使用存储调度器快速在多线程中操作数据库，效率非常高(比主线程操作块50倍！！！)
             - (void)performBackgroundTask:(void (^)(NSManagedObjectContext *))block;
             
    7。增删查排序
       5.增删改查排

       写入数据

       // 1.根据Entity名称和NSManagedObjectContext获取一个新的继承于NSManagedObject的子类Student
       Student * student = [NSEntityDescription  insertNewObjectForEntityForName:@"Student"  inManagedObjectContext:_context];
    
       //2.根据表Student中的键值，给NSManagedObject对象赋值
       student.name = [NSString stringWithFormat:@"Mr-%d",arc4random()%100];
       student.age = arc4random()%20;
       student.sex = arc4random()%2 == 0 ?  @"美女" : @"帅哥" ;
       student.height = arc4random()%180;
       student.number = arc4random()%100

       //   3.保存插入的数据
       NSError *error = nil;
       if ([_context save:&error]) {
          [self alertViewWithMessage:@"数据插入到数据库成功"];
        }else{
           [self alertViewWithMessage:[NSString stringWithFormat:@"数据插入到数据库失败, %@",error]];
        }



       删除数据

       - (void)deleteData{
   
       //创建删除请求
       NSFetchRequest *deleRequest = [NSFetchRequest fetchRequestWithEntityName:@"Student"];
    
       //删除条件
        NSPredicate *pre = [NSPredicate predicateWithFormat:@"age < %d", 10];
       deleRequest.predicate = pre;
   
       //返回需要删除的对象数组
       NSArray *deleArray = [_context executeFetchRequest:deleRequest error:nil];
    
       //从数据库中删除
       for (Student *stu in deleArray) {
        [_context deleteObject:stu];
        }
   
       NSError *error = nil;
       //保存--记住保存
       if ([_context save:&error]) {
          [self alertViewWithMessage:@"删除 age < 10 的数据"];
       }else{
          NSLog(@"删除数据失败, %@", error);
        }
       }


      更新修改

     //更新，修改
     - (void)updateData{
    
       //创建查询请求
       NSFetchRequest *request = [NSFetchRequest fetchRequestWithEntityName:@"Student"];
       NSPredicate *pre = [NSPredicate predicateWithFormat:@"sex = %@", @"帅哥"];
       request.predicate = pre;
    
       //发送请求
       NSArray *resArray = [_context executeFetchRequest:request error:nil];
    
       //修改
       for (Student *stu in resArray) {
          stu.name = @"且行且珍惜_iOS";
       }
  
       //保存
       NSError *error = nil;
       if ([_context save:&error]) {
           [self alertViewWithMessage:@"更新所有帅哥的的名字为“且行且珍惜_iOS”"];
       }else{
           NSLog(@"更新数据失败, %@", error);
       }  
      }
      
      排序

     //排序
     - (void)sort{
        //创建排序请求
        NSFetchRequest *request = [NSFetchRequest fetchRequestWithEntityName:@"Student"];
       //实例化排序对象
       NSSortDescriptor *ageSort = [NSSortDescriptor sortDescriptorWithKey:@"age"ascending:YES];
       NSSortDescriptor *numberSort = [NSSortDescriptor sortDescriptorWithKey:@"number"ascending:YES];
       request.sortDescriptors = @[ageSort,numberSort];
       //发送请求
       NSError *error = nil;
       NSArray *resArray = [_context executeFetchRequest:request error:&error];
       if (error == nil) {
          [self alertViewWithMessage:@"按照age和number排序"];
        }else{
           NSLog(@"排序失败, %@", error);
        }
      }
      
      CoreData调试:

      打开Product，选择Edit Scheme.
      选择Arguments，在下面的ArgumentsPassed On Launch中添加下面两个选项，如图：
     (1)-com.apple.CoreData.SQLDebug
     (2)1





CoreData 数据库迁移：
    NSManagedObjectModel托管对象模型变化，就必须要数据库迁移。
    引起变化：
        新增了一张表，即新增了一个实体
        新增一个实体的一个属性，即新增了一个表中的一个字段
        把一个实体的某个属性迁移到另外一个实体的某个属性里面，即把一张表中的字段移到别一张表中
        删除一个字段
        可选字段变为必选字段
  1.自动迁移，有可能数据太多，自动迁移会占用很多内存
  2.手动迁移可解决内存问题，更灵活。
  
  自动迁移案例：
      原理： 添加一个新模型，代码打开数据库迁移开关，把旧模型中字段遍列与新模型字段进行对比，最后把字段移到新模型中
      1。创建一个model版本。editor->Add Model Version 取名为：Model2.xcdatamodel，这时候xcode左边会有之前的model和现在的model
      2。选择新建的这个model版本为当前要使用的。 xcode右边 model version 选择model2
      3。修改新数据模型Model2,如增加一些字段
      4。设置数据库参数options，打开数据库升级迁移的开关
       //创建持久化存储助理：数据库
        NSPersistentStoreCoordinator * store = [[NSPersistentStoreCoordinator alloc] initWithManagedObjectModel:model];
       //请求自动轻量级迁移
        NSDictionary *options = [NSDictionary dictionaryWithObjectsAndKeys:
                             [NSNumber numberWithBool:YES], NSMigratePersistentStoresAutomaticallyOption,
                             [NSNumber numberWithBool:YES], NSInferMappingModelAutomaticallyOption,
                             nil];
         NSError *error = nil;
        //设置数据库相关信息 添加一个持久化存储库并设置存储类型和路径，NSSQLiteStoreType：SQLite作为存储库
      [store addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:sqlUrl options:options error:&error];
      这里说一下新增加的2个参数的意义：
       NSMigratePersistentStoresAutomaticallyOption = YES，那么Core Data会试着把之前低版本的出现不兼容的持久化存储区迁移到新的模型中，
       这里的例子里，Core Data就能识别出是新表，就会新建出新表的存储区来。
       NSInferMappingModelAutomaticallyOption = YES,这个参数的意义是Core Data会根据自己认为最合理的方式去尝试MappingModel，
       从源模型实体的某个属性，映射到目标模型实体的某个属性。
       
       
       
3。简单描述下客户端的缓存机制？
    缓存可以分为：内存数据缓存、数据库缓存、文件缓存   
    每次想获取数据的时候
    先检测内存中有无缓存
    再检测本地有无缓存(数据库\文件)
    最终发送网络请求
    将服务器返回的网络数据进行缓存（内存、数据库、文件）， 以便下次读取
    
4。什么是序列化和反序列化，用来做什么

   序列化把对象转化为字节序列的过程
   反序列化把字节序列恢复成对象
   把对象写到文件或者数据库中，并且读取出来
   
5。OC中实现复杂对象的存储

   遵循NSCoding协议，实现复杂对象的存储，实现该协议后可以对其进行打包或者解包，转化为NSDate

7。iOS中常用的数据存储方式有哪些？
   
   数据存储有四种方案，NSUserDefault,KeyChain（删除app后存储的文件不会消失）,File,DB.
   其中File有三种方式：plist,Archiver（对象存储，nscoding协议）,Stream
    DB包括core Data和FMDB
    
8。说一说你对SQLite的认识
   SQLite是目前主流的嵌入式关系型数据库，其最主要的特点就是轻量级、跨平台，当前很多嵌入式操作系统都将其作为数据库首选。
   功能也绝不亚于很多大型关系数据库
   和其他数据库相比，SQLite中的SQL语法并没有太大的差别
   SQLite数据库的几个特点：
     基于C语言开发的轻型数据库
     在iOS中需要使用C语言语法进行数据库操作、访问（无法使用ObjC直接访问，因为libqlite3框架基于C语言编写）
     SQLite中采用的是动态数据类型，即使创建时定义了一种类型，在实际操作时也可以存储其他类型，但是推荐建库时使用合适的类型
     建立连接后通常不需要关闭连接（尽管可以手动关闭）
   SQLite数据库操作：
     sqlite3_open()打开数据库会指定一个数据库文件保存路径，文件存在则直接打开，否则创建并打开，
     会得到一个sqlite3类型的对象，后面需要借助这个对象进行其他操作
     执行SQL语句，执行SQL语句又包括有返回值的语句和无返回值语句。
     对于无返回值的语句（如增加、删除、修改等）直接通过sqlite3_exec()函数执行；
     对于有返回值的语句则首先通过sqlite3_prepare_v2()进行sql语句评估（语法检测），然后通过sqlite3_step()依次取出查询结果的每一行数据，对于每行数据都可以通过对应的sqlite3_column_类型()方法获得对应列的数据，如此反复循环直到遍历完成。当然，最后需要释放句柄。

9。说一说你对FMDB的认识     
    FMDB是一个处理数据存储的第三方框架，框架是对sqlite的封装，整个框架非常轻量级但又不失灵活性，而且更加面向对象
    特点：
      FMDB引入了一个MFDatabase对象来表示数据库，打开数据库和后面的数据库操作全部依赖此对象。
      FMDB中FMDatabase类提供了两个方法executeUpdate:和executeQuery:分别用于执行无返回结果的查询和有返回结果的查询。
      当然这两个方法有很多的重载这里就不详细解释了。唯一需要指出的是，如果调用有格式化参数的sql语句时，格式化符号使用“?”
      而不是“%@”、等。
      libsqlite3进行数据库操作其实是线程不安全的，在多线程中使用FMDatabaseQueue对象，相比FMDatabase而言，它是线程安全的。
      在FMDB中FMDatabase有beginTransaction、commit、rollback三个方法进行开启事务、提交事务和回滚事务。在Core Data中大家也可以发现，
      所有的增、删、改操作之后必须调用上下文的保存方法，其实本身就提供了事务的支持 
      
10。如果后期需要增加数据库中的字段怎么实现，如果不使用CoreData呢？
     编写SQL语句来操作原来表中的字段
     增加表字段：ALTER TABLE 表名 ADD COLUMN 字段名 字段类型;
     删除表字段：ALTER TABLE 表名 DROP COLUMN 字段名;
     修改表字段：ALTER TABLE 表名 RENAME COLUMN 旧字段名 TO 新字段名;

11。说说数据库的左连接和右连接的区别，如果有A，B两张表，A表有3条数据，B表有4条数据，通过左连接和右连接，查询出的数据条数最少是多少条？最多是多少条？

   数据库左连接和右连接的区别：
   主表不一样通过左连接和右连接，最小条数为3（记录条数较小的记录数），最大条数为12（3×4）
  （1）左连接：只要左边表中有记录，数据就能检索出来，而右边有的记录必要在左边表中有的记录才能被检索出来
  （2）右连接：右连接是只要右边表中有记录，数据就能检索出来
  
12。iOS 的沙盒目录结构是怎样的？ App Bundle 里面都有什么？
    沙盒结构

    Application：存放程序源文件，上架前经过数字签名，上架后不可修改
    Documents：常用目录，iCloud备份目录，存放数据,这里不能存缓存文件,否则上架不被通过
    Library

    Caches：存放体积大又不需要备份的数据,SDWebImage缓存路径就是这个
    Preference：设置目录，iCloud会备份设置信息


    tmp：存放临时文件，不会被备份，而且这个文件下的数据有可能随时被清除的可能


    App Bundle 里面有什么

    Info.plist:此文件包含了应用程序的配置信息.系统依赖此文件以获取应用程序的相关信息
    可执行文件:此文件包含应用程序的入口和通过静态连接到应用程序target的代码
    资源文件:图片,声音文件一类的
    其他:可以嵌入定制的数据资源

13。你会如何存储用户的一些敏感信息，如登录的 token
    使用keychain来存储,也就是钥匙串,使用keychain需要导入Security框架

14。使用 NSUserDefaults 时，如何处理布尔的默认值？(比如返回 NO，不知道是真的 NO 还是没有设置过)
if([[NSUserDefaults standardUserDefaults] objectForKey:ID] == nil){
    NSLog(@"没有设置");
}

15。MD5和Base64的区别是什么，各自使用场景是什么？
    MD5：是一种不可逆的摘要算法，用于生成摘要，无法逆着破解得到原文。常用的是生成32位摘要，用于验证数据的有效性。比如，在网络请求接口中，通过将所有的参数生成摘要，客户端和服务端采用同样的规则生成摘要，这样可以防篡改。又如，下载文件时，通过生成文件的摘要，用于验证文件是否损坏。
    Base64：属于加密算法，是可逆的，经过encode后，可以decode得到原文。在开发中，有的公司上传图片采用的是将图片转换成base64字符串，再上传。在做加密相关的功能时，通常会将数据进行base64加密/解密。

16。plist文件是用来做什么的。一般用它来处理一些什么方面的问题。

plist是iOS系统中特有的文件格式。我们常用的NSUserDefaults偏好设置实质上就是plist文件操作。plist文件是用来持久化存储数据的。
我们通常使用它来存储偏好设置，以及那些少量的、数组结构比较复杂的不适合存储数据库的数据。比如，我们要存储全国城市名称和id，
那么我们要优先选择plist直接持久化存储，因为更简单。

17。怎么解决sqlite锁定的问题
1>  设置数据库锁定的处理函数
int sqlite3_busy_handler(sqlite3*, int(*)(void*,int), void*);
函数可以定义一个回调函数，当出现数据库忙时，sqlite会调用该函数
当回调函数为ＮＵＬＬ时，清除busy handle，申请不到锁直接返回
回调函数的第二个函数会被传递为该由此次忙事件调用该函数的次数
回调函数返回非０,数据库会重试当前操作，返回０则当前操作返回SQLITE_BUSY

2>  设定锁定时的等待时间
int sqlite3_busy_timeout(sqlite3*, 60); 
定义一个毫秒数，当未到达该毫秒数时，sqlite会sleep并重试当前操作
如果超过ms毫秒，仍然申请不到需要的锁，当前操作返回sqlite_BUSY
当ms<=0时，清除busy handle，申请不到锁直接返回





第20章  UI 面试题

1。动态的去拉伸图片
    方法1：代码拉伸
    设置topCapHeight、leftCapWidth、bottomCapHeight、lerightCapWidth,图中的黑色区域就是图片拉伸的范围，也就是说边上的不会被拉伸
    iOS6： 
    
   // UIImageResizingModeTile, // 平铺模式，通过重复显示UIEdgeInsets指定的矩形区域来填充图片
    //UIImageResizingModeStretch, // 拉伸模式，通过拉伸UIEdgeInsets指定的矩形区域来填充图片
        // 加载图片
    UIImage *image = [UIImage imageNamed:@"chat_send_nor"];
    
    // 设置端盖的值
    CGFloat top = image.size.height * 0.5;
    CGFloat left = image.size.width * 0.5;
    CGFloat bottom = image.size.height * 0.5;
    CGFloat right = image.size.width * 0.5;
    
    // 设置端盖的值
    UIEdgeInsets edgeInsets = UIEdgeInsetsMake(top, left, bottom, right);
    // 设置拉伸的模式
    UIImageResizingMode mode = UIImageResizingModeStretch;
    
    // 拉伸图片
    UIImage *newImage = [image resizableImageWithCapInsets:edgeInsets resizingMode:mode];
    
    // 设置按钮的背景图片
    [btn setBackgroundImage:newImage forState:UIControlStateNormal];

   方法2：
   1。重做一张较小的图片，只做左上角的小尾巴!
   2。选中此图片，在xcode右边属性silcing中设置参数即可拉伸
   
   
2。控制器 View的生命周期及相关函数是什么？你在开发中是如何用的？
     每次访问UIViewController的view，如果view为nil就会调用loadView方法
     如删除绑定一个控制器的xib view，就会不断的调用loadView方法
     loadView方法，就是给我们自定义UIViewController的view用的，在loadView方法中写自己创建的view，不需要[super loadView]
     [super loadView]会自动创建一个空白的view
1.首先判断控制器是否有视图，如果没有就调用loadView方法创建：通过storyboard或者代码；
2.随后调用viewDidLoad，可以进行下一步的初始化操作；只会被调用一次；
3.在视图显示之前调用viewWillAppear；该函数可以多次调用；
4.视图viewDidAppear
5.在视图消失之前调用viewWillDisappear；该函数可以多次调用；
如需要）；
6.在布局变化前后，调用viewWill/DidLayoutSubviews处理相关信息；


3.Size Classes 具体使用
对屏幕进行分类

4.使用 drawRect有什么影响？
displayIfNeeded立即执行drawRect
drawRect 方法依赖 Core Graphics 框架来进行自定义的绘制
缺点：它处理 touch 事件时每次按钮被点击后，都会用 setNeddsDisplay 进行强制重绘；
而且不止一次，每次单点事件触发两次执行。这样的话从性能的角度来说，对 CPU 和内存来说都是欠佳的
。这个方法的调用机制也是非常特别. 当你调用 setNeedsDisplay 方法时, UIKit 将会把当前图层标记为 dirty,
但还是会显示原来的内容,直到何适的时间下一次的视图渲染周期,才会将标记为 dirty 的图层重新建立 Core Graphics 上下文,
然后将内存中的数据恢复出来, 再使用 CGContextRef 进行绘制

drawrect方法不调用：
UIView初始化时没有设置rect大小
设置contentMode属性值为UIViewContentModeRedraw
通过设置contentMode属性值为UIViewContentModeRedraw，那么将在每次设置或更改frame的时候自动调用drawRect:
rect不能为0不调用
初始化一个view的时候，没有使用initWithFrame，不调用




3。描述下 SDWebImage里面给 UIImageView加载图片的逻辑

1.入口setImageWithURL:placeholderImage:options: 会先把placeholderImage 显示，然后 SDWebImageManager 根据 URL 开始处理图片。
2.进入 SDWebImageManager-downloadWithURL:delegate:options:userInfo: 交给 SDImageCache 从缓存查找图片是否已经下载queryDiskCacheForKey:delegate:userInfo:
3.先从内存图片缓存查找是否有图片，如果内存中已经有图片缓存，SDImageCacheDelegate 回调 imageCache:didFindImage:forKey:userInfo: 到 SDWebImageManager。
4.SDWebImageManagerDelegate 回调 webImageManager:didFinishWithImage: 到UIImageView+WebCache 等前端展示图片。
5.如果内存缓存中没有，生成 NSInvocationOperation 添加到队列开始从硬盘查找图片是否已经缓存。
6.根据 URLKey 在硬盘缓存目录下尝试读取图片文件。这一步是在 NSOperation 进行的操作，所以回主线程进行结果回调notifyDelegate:
7.如果上一操作从硬盘读取到了图片，将图片添加到内存缓存中（如果空闲内存过小，会先清空内存缓存）。SDImageCacheDelegate 回调imageCache:didFindImage:forKey:userInfo: 进而回调展示图片。
8.如果从硬盘缓存目录读取不到图片，说明所有缓存都不存在该图片，需要下载图片，回调 imageCache:didNotFindImageForKey:userInfo:
9.共享或重新生成一个下载器 SDWebImageDownloader 开始下载图片。
10.图片下载由 NSURLConnection 来做，实现相关 delegate 来判断图片下载中、下载完成和下载失败。
11.connection:didReceiveData: 中利用 ImageIO 做了按图片下载进度加载效果。
12.connectionDidFinishLoading: 数据下载完成后交给 SDWebImageDecoder 做图片解码处理。
13.图片解码处理在一个 NSOperationQueue 完成，不会拖慢主线程 UI。如果有需要对下载的图片进行二次处理，最好也在这里完成，效率会好很多。
14.在主线程notifyDelegateOnMainThreadWithInfo: 宣告解码完成，imageDecoder:didFinishDecodingImage:userInfo: 回调给 SDWebImageDownloader。
15.imageDownloader:didFinishWithImage: 回调给 SDWebImageManager 告知图片下载完成。
16.通知所有的 downloadDelegates 下载完成，回调给需要的地方展示图片。
17.将图片保存到 SDImageCache 中，内存缓存和硬盘缓存同时保存。写文件到硬盘也在以单独 NSInvocationOperation 完成，避免拖慢主线程。
18.SDImageCache 在初始化的时候会注册一些消息通知，在内存警告或退到后台的时候清理内存图片缓存，应用结束的时候清理过期图片。
19.SDWebImage 也提供了UIButton+WebCache 和 MKAnnotationView+WebCache，方便使用。
20.SDWebImagePrefetcher 可以预先下载图片，方便后续使用。

4。控制器的生命周期
-[ViewController initWithNibName:bundle:]；
-[ViewController init]；
-[ViewController loadView]；
-[ViewController viewDidLoad]；
-[ViewController viewWillAppear:]；
-[ViewController viewDidAppear:]；
-[ViewController viewWillDisappear:]；
-[ViewController viewDidDisappear:]；

// 自定义控制器 view，这个方法只有实现了才会执行
- (void)loadView
{
self.view = [[UIView alloc] init];
self.view.backgroundColor = [UIColor orangeColor];
}
// view 是懒加载，只要 view 加载完毕就调用这个方法
- (void)viewDidLoad
{
[super viewDidLoad];

NSLog(@"%s",__func__);
}

// view 即将显示
- (void)viewWillAppear:(BOOL)animated
{
[super viewWillAppear:animated];

NSLog(@"%s",__func__);
}
// view 即将开始布局子控件
- (void)viewWillLayoutSubviews
{
[super viewWillLayoutSubviews];

NSLog(@"%s",__func__);
}
// view 已经完成子控件的布局
- (void)viewDidLayoutSubviews
{
[super viewDidLayoutSubviews];

NSLog(@"%s",__func__);
}
// view 已经出现
- (void)viewDidAppear:(BOOL)animated
{
[super viewDidAppear:animated];

NSLog(@"%s",__func__);
}
// view 即将消失
- (void)viewWillDisappear:(BOOL)animated
{
[super viewWillDisappear:animated];

NSLog(@"%s",__func__);
}
// view 已经消失
- (void)viewDidDisappear:(BOOL)animated
{
[super viewDidDisappear:animated];

NSLog(@"%s",__func__);
}
// 收到内存警告
- (void)didReceiveMemoryWarning
{
[super didReceiveMemoryWarning];

NSLog(@"%s",__func__);
}
// 方法已过期，即将销毁 view
- (void)viewWillUnload
{
}
// 方法已过期，已经销毁 view
- (void)viewDidUnload
{
}


5。你是怎么封装一个 view的
可以通过纯代码或者 xib 的方式来封装子控件
建立一个跟 view 相关的模型，然后将模型数据传给 view，通过模型上的数据给 view的子控件赋值
/**
* 纯代码初始化控件时一定会走这个方法
*/
- (instancetype)initWithFrame:(CGRect)frame
{
if(self = [super initWithFrame:frame])
{
[self setup];
}

return self;
}

/**
* 通过 xib初始化控件时一定会走这个方法
*/
- (id)initWithCoder:(NSCoder *)aDecoder
{
if(self = [super initWithCoder:aDecoder])
{
[self setup];
}

return self;
}

- (void)setup
{
// 初始化代码
}


6。如何进行适配
通过判断版本来控制，来执行响应的代码
功能适配：保证同一个功能在哪里都能用
UI 适配：保证各自的显示风格
// iOS版本适配
#define iOS11 ([[UIDevice currentDevice].systemVersion
doubleValue]>=11.0)

7。如何渲染 UILabel的文字？

通过 NSAttributedString/NSMutableAttributedString（富文本）

8。UIScrollView 的 contentSize能否在viewDidLoad中设置？
能
因为 UIScrollView 的内容尺寸是根据其内部的内容来决定的，所以是可以在viewDidLoad 中设置的。
补充：（这仅仅是一种特殊情况）
前提，控制器 B 是控制器 A 的一个子控制器，且控制器 B 的内容只在控制器 A 的view 的部分区域中显示。
假设控制器 B 的 view 中有一个 UIScrollView 这样一个子控件。
如果此时在控制器 B 的 viewDidLoad 中设置 UIScrollView 的 contentSize 的话会导致不准确的问题。
因为任何控制器的 view 在 viewDidLoad 的时候的尺寸都是不准确的，
如果有子控件的尺寸依赖父控件的尺寸，在这个方法中设置会导致子控件的 frame 不准确，所以这时应该-(void)viewDidLayoutSubviews;方法中设置子控件的尺寸。



9。iOS 循环渐进轮播

用UICollectionView实现的支持水平和垂直两个方向上的的分页和渐进循环轮播效果
偏移量设置成初始状态并不代表scrollview会发生滚动，但是必须把动画关掉
思路	1：
图0  图1  图2
将middle的图片设为"图1", 然后将scrollView的偏移量设置成初始状态(注意,不能开启动画, 否则露馅);
将left的图片设置成"图0", 将right的图片设置成"图2";
然后就变成了这样的:

思路2：
  图3   图0  图1   图2   图3  图0
  in0  in1  in2   in3  in4  in5
  
  标号为0-3的四张图来轮播，在首位置多插入一张图3，在末位置多插入一张图0
  
  当处在上图所示的位置, 并且向右滑动之后, 显示的是"图3"(也就是index = 0);
  这时候, 后台需要做的事情是:
  悄悄地将index = 0 变成 index = 4;
   同样的, 当向左滑到最右侧的"图3"的时候, 后台需要做的是:
   悄悄地将index = 5 变成 index = 1;
    通过这种思路实现无线轮播.

3,两种思路的优劣对比
其实两种思路差别并不是很大, 主要的优劣是这样的:
思路A :  
优点: 只需要创建三个图片框, 占用内存少;
缺点: 实现思路稍微复杂一点, 而且代码比较多; 在实际使用里面, 当网速比较慢的时候, 首次加载图片变慢的话可能会出现滚动灰色背景的画面.
思路B :
优点: 实现思路比较简单, 而且代码量少, 容易理解一点, 而且相对于A,网速慢的情况下出现轮播灰色背景框的几率少一点;
缺点: 创建比较多的图片框, 占用内存比较多一点




10.iOS 全屏侧滑手势/UIScrollView/UISlider间滑动手势冲突
https://www.jianshu.com/p/a9a322052f26
问题1：一个侧滑控件，右边是一个控制器a，点击控制器a push到控制器b，控制器b是一个uiscrollview，当uiscrollview偏移是0的时候，
右滑，应该pop到控制器a,但是结果不然，而是在scrollview上出现空白的区域

如果你了解事件的传递和响应链机制的话，应该能想到，是由于UIScrollView的内部手势方法阻断了全屏侧滑返回手势的的响应，
那我们就找到这个方法，代码如下 ；
创建一个UIScrollView的类别UIScrollView+GestureConflict，重写如下方法：

//处理UIScrollView上的手势和侧滑返回手势的冲突
-(BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer{

    // 首先判断otherGestureRecognizer是不是系统pop手势
    if ([otherGestureRecognizer.view isKindOfClass:NSClassFromString(@"UILayoutContainerView")]) {
        // 再判断系统手势的state是began还是fail，同时判断scrollView的位置是不是正好在最左边
        if (otherGestureRecognizer.state == UIGestureRecognizerStateBegan && self.contentOffset.x == 0) {
            return YES;//则scrollview支持这个全屏侧滑返回手势
        }
    }
    return NO;
}


问题2：控制器b是一个uiscrollview,scrollview上添加了一个uislider,点击uislider滑杆滑动时没反应，必须长按滑杆150秒后拖动才有反应

方案一：这个跟UIScrollView的一个属性delaysContentTouches有关。
scrollView.delaysContentTouches = NO;
delaysContentTouches 默认值为YES 表示延迟scrollView上子视图的响应，所以当直接拖动UISlider时，如果此时touch时间在150ms以内，UIScrollView会认为是拖动自己，从而拦截了event，导致UISlider接收不到滑动的event。但是只要长按住UISlider一会儿再拖动，此时touch时间超过150ms，因此滑动的event会发送到UISlider上，然后UISlider再作出响应；设置为NO后，拖动UISlider时就可以直接做出响应，解决了UISlider与UIScrollView之间的冲突，同时也解决了向右拖拽时却触发了全屏侧滑pop返回的问题。


方案二： 重写类别UIScrollView+GestureConflict中的如下方法来解决UISlider与UIScrollView之间的冲突，然后还需要执行下面 问题补充 中的操作来处理UISlider的滑动与全屏侧滑pop返回事件的冲突。
//拦截事件的处理 事件传递给谁，就会调用谁的hitTest:withEvent:方法。
//处理UISlider的滑动与UIScrollView的滑动事件冲突
- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {
    /*
     直接拖动UISlider，此时touch时间在150ms以内，UIScrollView会认为是拖动自己，从而拦截了event，导致UISlider接受不到滑动的event。但是只要按住UISlider一会再拖动，此时此时touch时间超过150ms，因此滑动的event会发送到UISlider上。
     */
    UIView *view = [super hitTest:point withEvent:event];
    
    if([view isKindOfClass:[UISlider class]]) {
        //如果接收事件view是UISlider,则scrollview禁止响应滑动
        self.scrollEnabled = NO;
    } else {   //如果不是,则恢复滑动
        self.scrollEnabled = YES;
    }
    return view;
}

示例Demo中的UISlider是在UIScrollView上的，如果UISlider不是在UIScrollView上，
而是直接就在ViewControllerb.view上，那也就会出现拖拽UISlider时却响应了全屏侧滑pop返回手势的问题。



在支持全屏侧滑返回的UINavigationController的子类WSLNavigatioController中，遵守协议<UIGestureRecognizerDelegate>,实现如下方法：

#pragma mark -- UIGestureRecognizerDelegate
//触发之后是否响应手势事件
//处理侧滑返回与UISlider的拖动手势冲突
- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch{
    //如果手势是触摸的UISlider滑块触发的，侧滑返回手势就不响应
    if ([touch.view isKindOfClass:[UISlider class]]) {
        return NO;
    }
    return YES;
}


11.WKWebView

在开发过程中，iOS 中实现加载 web 页面主要有两种控件，UIWebView 和 WKWebview，两种控件对应具体的实现方法不同。WKWebView 是苹果在iOS 8中引入的新组件，目的是提供一个现代的支持最新Webkit功能的网页浏览控件，摆脱过去 UIWebView的老、旧、笨，特别是内存占用量巨大的问题。它使用与Safari中一样的Nitro JavaScript引擎，大大提高了页面js执行速度。的。 
相比于UIWebView的优势： 
在性能、稳定性、占用内存方面有很大提升； 
允许JavaScript的Nitro库加载并使用（UIWebView中限制） 
增加加载进度属性：estimatedProgress，不用在自己写假进度条了 
支持了更多的HTML的属性

具体分析WKWebView的优劣势 
1.内存占用是UIWebView的1/4~1/3 
2.页面加载速度有提升，有的文章说它的加载速度比UIWebView提升了一倍左右。 
3.更为细致地拆分了 UIWebViewDelegate 中的方法 
4.自带进度条。不需要像UIWebView一样自己做假进度条（通过NJKWebViewProgress和双层代理技术实现），技术复杂度和代码量，根贴近实际加载进度优化好的多。 
5.允许JavaScript的Nitro库加载并使用（UIWebView中限制） 
6.可以和js直接互调函数，不像UIWebView需要第三方库WebViewJavascriptBridge来协助处理和js的交互。 
7.不支持页面缓存，需要自己注入cookie,而UIWebView是自动注入cookie。 
8.无法发送POST参数问题

最近项目中的UIWebView被替换为了WKWebView，因此来总结一下。
示例Demo：WKWebView的使用
本文将从以下几方面介绍WKWebView：

1、WKWebView涉及的一些类
2、WKWebView涉及的代理方法
3、网页内容加载进度条和title的实现
4、JS和OC的交互
5、本地HTML文件的实现


一、WKWebView涉及的一些类

WKWebView：网页的渲染与展示

    注意： #import <WebKit/WebKit.h>
     //初始化
       _webView = [[WKWebView alloc] initWithFrame:CGRectMake(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT) configuration:config];
        // UI代理
        _webView.UIDelegate = self;
        // 导航代理
        _webView.navigationDelegate = self;
        // 是否允许手势左滑返回上一级, 类似导航控制的左滑返回
        _webView.allowsBackForwardNavigationGestures = YES;
        //可返回的页面列表, 存储已打开过的网页 
       WKBackForwardList * backForwardList = [_webView backForwardList];

        //        NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"http://www.chinadaily.com.cn"]];
        //        [request addValue:[self readCurrentCookieWithDomain:@"http://www.chinadaily.com.cn"] forHTTPHeaderField:@"Cookie"];
        //        [_webView loadRequest:request];
        //页面后退
        [_webView goBack];
        //页面前进
         [_webView goForward];
        //刷新当前页面
        [_webView reload];
        
        NSString *path = [[NSBundle mainBundle] pathForResource:@"JStoOC.html" ofType:nil];
        NSString *htmlString = [[NSString alloc]initWithContentsOfFile:path encoding:NSUTF8StringEncoding error:nil];
      //加载本地html文件
        [_webView loadHTMLString:htmlString baseURL:[NSURL fileURLWithPath:[[NSBundle mainBundle] bundlePath]]];
        



WKWebViewConfiguration：为添加WKWebView配置信息

       //创建网页配置对象
        WKWebViewConfiguration *config = [[WKWebViewConfiguration alloc] init];
        
        // 创建设置对象
        WKPreferences *preference = [[WKPreferences alloc]init];
        //最小字体大小 当将javaScriptEnabled属性设置为NO时，可以看到明显的效果
        preference.minimumFontSize = 0;
        //设置是否支持javaScript 默认是支持的
        preference.javaScriptEnabled = YES;
        // 在iOS上默认为NO，表示是否允许不经过用户交互由javaScript自动打开窗口
        preference.javaScriptCanOpenWindowsAutomatically = YES;
        config.preferences = preference;
        
        // 是使用h5的视频播放器在线播放, 还是使用原生播放器全屏播放
        config.allowsInlineMediaPlayback = YES;
        //设置视频是否需要用户手动播放  设置为NO则会允许自动播放
        config.requiresUserActionForMediaPlayback = YES;
        //设置是否允许画中画技术 在特定设备上有效
        config.allowsPictureInPictureMediaPlayback = YES;
        //设置请求的User-Agent信息中应用程序名称 iOS9后可用
        config.applicationNameForUserAgent = @"ChinaDailyForiPad";
         //自定义的WKScriptMessageHandler 是为了解决内存不释放的问题
        WeakWebViewScriptMessageDelegate *weakScriptMessageDelegate = [[WeakWebViewScriptMessageDelegate alloc] initWithDelegate:self];
        //这个类主要用来做native与JavaScript的交互管理
        WKUserContentController * wkUController = [[WKUserContentController alloc] init];
        //注册一个name为jsToOcNoPrams的js方法
        [wkUController addScriptMessageHandler:weakScriptMessageDelegate  name:@"jsToOcNoPrams"];
        [wkUController addScriptMessageHandler:weakScriptMessageDelegate  name:@"jsToOcWithPrams"]; 
       config.userContentController = wkUController;
        


WKUserScript：用于进行JavaScript注入

    //以下代码适配文本大小，由UIWebView换为WKWebView后，会发现字体小了很多，这应该是WKWebView与html的兼容问题，解决办法是修改原网页，要么我们手动注入JS
        NSString *jSString = @"var meta = document.createElement('meta'); meta.setAttribute('name', 'viewport'); meta.setAttribute('content', 'width=device-width'); document.getElementsByTagName('head')[0].appendChild(meta);";
        //用于进行JavaScript注入
        WKUserScript *wkUScript = [[WKUserScript alloc] initWithSource:jSString injectionTime:WKUserScriptInjectionTimeAtDocumentEnd forMainFrameOnly:YES];
        [config.userContentController addUserScript:wkUScript];



WKUserContentController：这个类主要用来做native与JavaScript的交互管理


      //这个类主要用来做native与JavaScript的交互管理
        WKUserContentController * wkUController = [[WKUserContentController alloc] init];
        //注册一个name为jsToOcNoPrams的js方法，设置处理接收JS方法的代理
        [wkUController addScriptMessageHandler:self  name:@"jsToOcNoPrams"];
        [wkUController addScriptMessageHandler:self  name:@"jsToOcWithPrams"];
        config.userContentController = wkUController;
       //用完记得移除
       //移除注册的js方法
        [[_webView configuration].userContentController removeScriptMessageHandlerForName:@"jsToOcNoPrams"];
       [[_webView configuration].userContentController removeScriptMessageHandlerForName:@"jsToOcWithPrams"];


WKScriptMessageHandler：这个协议类专门用来处理监听JavaScript方法从而调用原生OC方法，和WKUserContentController搭配使用。

注意：遵守WKScriptMessageHandler协议，代理是由WKUserContentControl设置

   //通过接收JS传出消息的name进行捕捉的回调方法
- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message{
    NSLog(@"name:%@\\\\n body:%@\\\\n frameInfo:%@\\\\n",message.name,message.body,message.frameInfo);
    //用message.body获得JS传出的参数体
    NSDictionary * parameter = message.body;
    //JS调用OC
    if([message.name isEqualToString:@"jsToOcNoPrams"]){
        UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@"js调用到了oc" message:@"不带参数" preferredStyle:UIAlertControllerStyleAlert];
        [alertController addAction:([UIAlertAction actionWithTitle:@"OK" style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) {
        }])];
        [self presentViewController:alertController animated:YES completion:nil];
        
    }else if([message.name isEqualToString:@"jsToOcWithPrams"]){
        UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@"js调用到了oc" message:parameter[@"params"] preferredStyle:UIAlertControllerStyleAlert];
        [alertController addAction:([UIAlertAction actionWithTitle:@"OK" style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) {
        }])];
        [self presentViewController:alertController animated:YES completion:nil];
    }
}


二、WKWebView涉及的代理方法

WKNavigationDelegate  ：主要处理一些跳转、加载处理操作


    // 页面开始加载时调用
- (void)webView:(WKWebView *)webView didStartProvisionalNavigation:(WKNavigation *)navigation {
}
    // 页面加载失败时调用
- (void)webView:(WKWebView *)webView didFailProvisionalNavigation:(null_unspecified WKNavigation *)navigation withError:(NSError *)error {
    [self.progressView setProgress:0.0f animated:NO];
} 
    // 当内容开始返回时调用
- (void)webView:(WKWebView *)webView didCommitNavigation:(WKNavigation *)navigation {
}
    // 页面加载完成之后调用
- (void)webView:(WKWebView *)webView didFinishNavigation:(WKNavigation *)navigation {
    [self getCookie];
}
    //提交发生错误时调用
- (void)webView:(WKWebView *)webView didFailNavigation:(WKNavigation *)navigation withError:(NSError *)error {
    [self.progressView setProgress:0.0f animated:NO];
}  
   // 接收到服务器跳转请求即服务重定向时之后调用
- (void)webView:(WKWebView *)webView didReceiveServerRedirectForProvisionalNavigation:(WKNavigation *)navigation {
}
    // 根据WebView对于即将跳转的HTTP请求头信息和相关信息来决定是否跳转
- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler {
    
    NSString * urlStr = navigationAction.request.URL.absoluteString;
    NSLog(@"发送跳转请求：%@",urlStr);
    //自己定义的协议头
    NSString *htmlHeadString = @"github://";
    if([urlStr hasPrefix:htmlHeadString]){
        UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@"通过截取URL调用OC" message:@"你想前往我的Github主页?" preferredStyle:UIAlertControllerStyleAlert];
        [alertController addAction:([UIAlertAction actionWithTitle:@"取消" style:UIAlertActionStyleCancel handler:^(UIAlertAction * _Nonnull action) {   
        }])];
        [alertController addAction:([UIAlertAction actionWithTitle:@"打开" style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) {
            NSURL * url = [NSURL URLWithString:[urlStr stringByReplacingOccurrencesOfString:@"github://callName_?" withString:@""]];
            [[UIApplication sharedApplication] openURL:url];
        }])];
        [self presentViewController:alertController animated:YES completion:nil];
        decisionHandler(WKNavigationActionPolicyCancel);
    }else{
        decisionHandler(WKNavigationActionPolicyAllow);
    }
}
    
    // 根据客户端受到的服务器响应头以及response相关信息来决定是否可以跳转
- (void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler{
    NSString * urlStr = navigationResponse.response.URL.absoluteString;
    NSLog(@"当前跳转地址：%@",urlStr);
    //允许跳转
    decisionHandler(WKNavigationResponsePolicyAllow);
    //不允许跳转
    //decisionHandler(WKNavigationResponsePolicyCancel);
} 
    //需要响应身份验证时调用 同样在block中需要传入用户身份凭证
- (void)webView:(WKWebView *)webView didReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential * _Nullable credential))completionHandler{
    //用户身份信息
    NSURLCredential * newCred = [[NSURLCredential alloc] initWithUser:@"user123" password:@"123" persistence:NSURLCredentialPersistenceNone];
    //为 challenge 的发送方提供 credential
    [challenge.sender useCredential:newCred forAuthenticationChallenge:challenge];
    completionHandler(NSURLSessionAuthChallengeUseCredential,newCred);
}
    //进程被终止时调用
- (void)webViewWebContentProcessDidTerminate:(WKWebView *)webView{
}



WKUIDelegate ：主要处理JS脚本，确认框，警告框等


 /**
     *  web界面中有弹出警告框时调用
     *
     *  @param webView           实现该代理的webview
     *  @param message           警告框中的内容
     *  @param completionHandler 警告框消失调用
     */
- (void)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(void))completionHandler {
    UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@"HTML的弹出框" message:message?:@"" preferredStyle:UIAlertControllerStyleAlert];
    [alertController addAction:([UIAlertAction actionWithTitle:@"OK" style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) {
        completionHandler();
    }])];
    [self presentViewController:alertController animated:YES completion:nil];
}
    // 确认框
    //JavaScript调用confirm方法后回调的方法 confirm是js中的确定框，需要在block中把用户选择的情况传递进去
- (void)webView:(WKWebView *)webView runJavaScriptConfirmPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(BOOL))completionHandler{
    UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@"" message:message?:@"" preferredStyle:UIAlertControllerStyleAlert];
    [alertController addAction:([UIAlertAction actionWithTitle:@"Cancel" style:UIAlertActionStyleCancel handler:^(UIAlertAction * _Nonnull action) {
        completionHandler(NO);
    }])];
    [alertController addAction:([UIAlertAction actionWithTitle:@"OK" style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) {
        completionHandler(YES);
    }])];
    [self presentViewController:alertController animated:YES completion:nil];
}
    // 输入框
    //JavaScript调用prompt方法后回调的方法 prompt是js中的输入框 需要在block中把用户输入的信息传入
- (void)webView:(WKWebView *)webView runJavaScriptTextInputPanelWithPrompt:(NSString *)prompt defaultText:(NSString *)defaultText initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(NSString * _Nullable))completionHandler{
    UIAlertController *alertController = [UIAlertController alertControllerWithTitle:prompt message:@"" preferredStyle:UIAlertControllerStyleAlert];
    [alertController addTextFieldWithConfigurationHandler:^(UITextField * _Nonnull textField) {
        textField.text = defaultText;
    }];
    [alertController addAction:([UIAlertAction actionWithTitle:@"OK" style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) {
        completionHandler(alertController.textFields[0].text?:@"");
    }])];
    [self presentViewController:alertController animated:YES completion:nil];
}
    // 页面是弹出窗口 _blank 处理
- (WKWebView *)webView:(WKWebView *)webView createWebViewWithConfiguration:(WKWebViewConfiguration *)configuration forNavigationAction:(WKNavigationAction *)navigationAction windowFeatures:(WKWindowFeatures *)windowFeatures {
    if (!navigationAction.targetFrame.isMainFrame) {
        [webView loadRequest:navigationAction.request];
    }
    return nil;
}


三、网页内容加载进度条和title的实现
   //添加监测网页加载进度的观察者
    [self.webView addObserver:self
                   forKeyPath:@"estimatedProgress"
                      options:0
                      context:nil];
   //添加监测网页标题title的观察者
    [self.webView addObserver:self
                   forKeyPath:@"title"
                      options:NSKeyValueObservingOptionNew
                      context:nil];

   //kvo 监听进度 必须实现此方法
-(void)observeValueForKeyPath:(NSString *)keyPath
                     ofObject:(id)object
                       change:(NSDictionary<NSKeyValueChangeKey,id> *)change
                      context:(void *)context{
    if ([keyPath isEqualToString:NSStringFromSelector(@selector(estimatedProgress))]
        && object == _webView) {
       NSLog(@"网页加载进度 = %f",_webView.estimatedProgress);
        self.progressView.progress = _webView.estimatedProgress;
        if (_webView.estimatedProgress >= 1.0f) {
            dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
                self.progressView.progress = 0;
            });
        } 
    }else if([keyPath isEqualToString:@"title"]
             && object == _webView){
        self.navigationItem.title = _webView.title;
    }else{
        [super observeValueForKeyPath:keyPath
                             ofObject:object
                               change:change
                              context:context];
    }
}
    //移除观察者
    [_webView removeObserver:self
                  forKeyPath:NSStringFromSelector(@selector(estimatedProgress))];
    [_webView removeObserver:self
                  forKeyPath:NSStringFromSelector(@selector(title))];


四、JS和OC的交互

JS调用OC


这个实现主要是依靠WKScriptMessageHandler协议类和WKUserContentController两个类：WKUserContentController对象负责注册JS方法，设置处理接收JS方法的代理，代理遵守WKScriptMessageHandler，实现捕捉到JS消息的回调方法，详情可以看第一步中对这两个类的介绍。

 //这个类主要用来做native与JavaScript的交互管理
        WKUserContentController * wkUController = [[WKUserContentController alloc] init];
        //注册一个name为jsToOcNoPrams的js方法，设置处理接收JS方法的代理
        [wkUController addScriptMessageHandler:self  name:@"jsToOcNoPrams"];
        [wkUController addScriptMessageHandler:self  name:@"jsToOcWithPrams"];
        config.userContentController = wkUController;

注意：遵守WKScriptMessageHandler协议，代理是由WKUserContentControl设置
 //通过接收JS传出消息的name进行捕捉的回调方法  js调OC
- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message{
    NSLog(@"name:%@\\\\n body:%@\\\\n frameInfo:%@\\\\n",message.name,message.body,message.frameInfo);
}





OC调用JS


 //OC调用JS  changeColor()是JS方法名，completionHandler是异步回调block
    NSString *jsString = [NSString stringWithFormat:@"changeColor('%@')", @"Js参数"];
    [_webView evaluateJavaScript:jsString completionHandler:^(id _Nullable data, NSError * _Nullable error) {
        NSLog(@"改变HTML的背景色");
    }];
    
    //改变字体大小 调用原生JS方法
    NSString *jsFont = [NSString stringWithFormat:@"document.getElementsByTagName('body')[0].style.webkitTextSizeAdjust= '%d%%'", arc4random()%99 + 100];
    [_webView evaluateJavaScript:jsFont completionHandler:nil];



12。iOS UITableView/UICollectionView获取特定位置的cell

获取偏移后顶部cell的index

方案一(不推荐原因会在后面提到)：获得当前可见的所有cell，然后取可见cell数组中的第一个cell就是目标cell，再根据cell获得indexPath。代码如下
- (void)scrollViewDidScroll:(UIScrollView *)scrollView{
    
  if (scrollView == _rightTableView && _isSelected == NO) {
      //返回tableView可见的cell数组
        NSArray * array = [_rightTableView visibleCells];
       //返回cell的IndexPath
        NSIndexPath * indexPath = [_rightTableView indexPathForCell:array.firstObject];
        NSLog(@"滑到了第 %ld 组 %ld个",indexPath.section, indexPath.row);
        _currentIndexPath = [NSIndexPath indexPathForRow:0 inSection:indexPath.section];
        [_leftTableView reloadData];
        [_leftTableView scrollToRowAtIndexPath:[NSIndexPath indexPathForRow:0 inSection:indexPath.section] atScrollPosition:UITableViewScrollPositionMiddle animated:NO];
    }
    
}


方案二(推荐使用)：利用偏移量！偏移量的值实际上可以代表当时处于tableView顶部的cell在tableView上的相对位置， 那么我们就可以根据偏移量获得处于顶部的cell的indexPath。代码如下
- (void)scrollViewDidScroll:(UIScrollView *)scrollView{
    
   if (scrollView == _rightTableView && _isSelected == NO) {
       //系统方法返回处于tableView某坐标处的cell的indexPath
        NSIndexPath * indexPath = [_rightTableView indexPathForRowAtPoint:scrollView.contentOffset];
        NSLog(@"滑到了第 %ld 组 %ld个",indexPath.section, indexPath.row);
        _currentIndexPath = [NSIndexPath indexPathForRow:0 inSection:indexPath.section];
        [_leftTableView reloadData];
        [_leftTableView scrollToRowAtIndexPath:[NSIndexPath indexPathForRow:0 inSection:indexPath.section] atScrollPosition:UITableViewScrollPositionMiddle animated:NO];
    }
    
}


二、 获取处于UITableView中心的cell

获取处于tableView中间cell的效果，用上述方案一比较麻烦：要考虑可见cell 的奇、偶个数问题，还有cell是否等高的情况；方案二用起来就快捷方便多了，取的cell的位置的纵坐标相当于在偏移量的基础上又增加了tableView高度的一半。代码如下：

- (void)scrollViewDidScroll:(UIScrollView *)scrollView{

    //获取处于UITableView中心的cell
    //系统方法返回处于tableView某坐标处的cell的indexPath
    NSIndexPath * middleIndexPath = [_rightTableView  indexPathForRowAtPoint:CGPointMake(0, scrollView.contentOffset.y + _rightTableView.frame.size.height/2)];
    NSLog(@"中间的cell：第 %ld 组 %ld个",middleIndexPath.section, middleIndexPath.row);
}



UICollectionView获取特定位置的item与UITableView相似，仅仅是获取的方法名不同，如下：

 NSIndexPath * indexPath = [_collectionView  indexPathForItemAtPoint:scrollView.contentOffset];
 NSLog(@"滑到了第 %ld 组 %ld个",indexPath.section, indexPath.row);


获取某个cell在当前tableView/collectionView上的坐标位置

 //获取某个cell在当前tableView上的坐标位置
    CGRect rectInTableView = [_rightTableView rectForRowAtIndexPath:middleIndexPath];
    //获取cell在当前屏幕的位置
    CGRect rectInSuperview = [_rightTableView convertRect:rectInTableView toView:[_rightTableView superview]];
    NSLog(@"中间的cell处于tableView上的位置: %@ /n 中间cell在当前屏幕的位置：%@", NSStringFromCGRect(rectInTableView), NSStringFromCGRect(rectInSuperview));
    
     //获取cell在当前collection的位置
     CGRect cellInCollection = [_collectionView convertRect:item.frame toView:_collectionView];
     UICollectionViewCell * item = [_collectionView cellForItemAtIndexPath:indexPath]];
     //获取cell在当前屏幕的位置
     CGRect cellInSuperview = [_collectionView convertRect:item.frame toView:[_collectionView superview]];
     NSLog(@"获取cell在当前collection的位置: %@ /n 获取cell在当前屏幕的位置：%@", NSStringFromCGRect(cellInCollection), NSStringFromCGRect(cellInSuperview));
    

13。iOS 自定义转场动画
本文记录分享下自定义转场动画的实现方法，具体到动画效果：新浪微博图集浏览转场效果、手势过渡动画、网易音乐启动屏转场动画、开关门动画、全屏侧滑返回效果 的代码可以到Github WSLTransferAnimation下载查看，注释还算清晰。

模态化present和dismiss 自定义转场
1、创建一个遵循<UIViewControllerAnimatedTransitioning>协议的动画过渡管理对象，并实现如下两个方法：
//返回动画事件
- (NSTimeInterval)transitionDuration:(nullable id <UIViewControllerContextTransitioning>)transitionContext{
    return 0.3;
}
//所有的过渡动画事务都在这个方法里面完成
- (void)animateTransition:(id <UIViewControllerContextTransitioning>)transitionContext{

 //取出转场前后的视图控制器
  UIViewController * fromVC = (UIViewController *)[transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey];
  UIViewController * toVC = (UIViewController *)[transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];

 //取出转场前后视图控制器上的视图view
    UIView * toView = [transitionContext viewForKey:UITransitionContextToViewKey];
    UIView * fromView = [transitionContext viewForKey:UITransitionContextFromViewKey];

 //这里有个重要的概念containerView，要做转场动画的视图就必须要加入containerView上才能进行，可以理解containerView管理着所有做转场动画的视图
    UIView *containerView = [transitionContext containerView];

  //如果加入了手势交互转场，就需要根据手势交互动作是否完成/取消来做操作，完成标记YES，取消标记NO，必须标记，否则系统认为还处于动画过程中，会出现无法交互之类的bug
   [transitionContext completeTransition:![transitionContext transitionWasCancelled]];
     if ([transitionContext transitionWasCancelled]) { 
    //如果取消转场
          }else{
   //完成转场
     }
}

2、自定义一个继承于UIPercentDrivenInteractiveTransition的手势过渡管理对象，可以根据手势需要设置控制动画转场进度的百分比。
//必要调用实现的系统方法

//手势过程中，通过updateInteractiveTransition设置转场过程动画进行的百分比，然后系统会根据百分比自动布局动画控件，不用我们控制了
 [self updateInteractiveTransition:percentComplete];
//完成转场操作
 [self finishInteractiveTransition];
//取消转场操作
 [self cancelInteractiveTransition];


3、转场时最上层的视图控制器需要遵循<UIViewControllerTransitioningDelegate>的协议，并设置为代理，并实现如下代理方法：
//设置转场代理
self.transitioningDelegate = self;

#pragma mark -- UIViewControllerTransitioningDelegate

//返回一个处理present动画过渡的对象
-(id<UIViewControllerAnimatedTransitioning>)animationControllerForPresentedController:(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source{
    return self.transitionAnimation;
}
//返回一个处理dismiss动画过渡的对象
- (id<UIViewControllerAnimatedTransitioning>)animationControllerForDismissedController:(UIViewController *)dismissed{
    //这里我们初始化dismissType
    self.transitionAnimation.transitionType = WSLTransitionOneTypeDissmiss;
    return self.transitionAnimation;
}
//返回一个处理present手势过渡的对象 
- (nullable id <UIViewControllerInteractiveTransitioning>)interactionControllerForPresentation:(id <UIViewControllerAnimatedTransitioning>)animator{
    return self.transitionInteractive;
}
//返回一个处理dismiss手势过渡的对象
- (nullable id <UIViewControllerInteractiveTransitioning>)interactionControllerForDismissal:(id <UIViewControllerAnimatedTransitioning>)animator{
    return self.transitionInteractive;
}

导航控制器push和pop 自定义转场
1、略...同上
2、略... 同上
3、在push动画之前设置导航控制器的转场动画代理，转场时最上层的视图控制器需要遵循<UINavigationControllerDelegate>的协议，并设置为代理，并实现如下代理方法：
 //在push动画之前设置转场动画代理
 self.navigationController.delegate = animationFour;

#pragma mark -- UINavigationControllerDelegate
//返回处理push/pop动画过渡的对象
- (nullable id <UIViewControllerAnimatedTransitioning>)navigationController:(UINavigationController *)navigationController
                                            animationControllerForOperation:(UINavigationControllerOperation)operation
                                                         fromViewController:(UIViewController *)fromVC
                                                           toViewController:(UIViewController *)toVC{
    
    if (operation == UINavigationControllerOperationPush) {
        self.transitionAnimation.transitionType = WSLTransitionTwoTypePush;
        return self.transitionAnimation;
    }else if (operation == UINavigationControllerOperationPop){
        self.transitionAnimation.transitionType = WSLTransitionTwoTypePop;
    }
    return self.transitionAnimation;
}

//返回处理push/pop手势过渡的对象 这个代理方法依赖于上方的方法 ，这个代理实际上是根据交互百分比来控制上方的动画过程百分比
- (nullable id <UIViewControllerInteractiveTransitioning>)navigationController:(UINavigationController *)navigationController
                                   interactionControllerForAnimationController:(id <UIViewControllerAnimatedTransitioning>) animationController{
    
    //手势开始的时候才需要传入手势过渡代理，如果直接pop或push，应该返回nil，否者无法正常完成pop/push动作
    if ( self.transitionAnimation.transitionType == WSLTransitionTwoTypePop) {
        return self.transitionInteractive.isInteractive == YES ? self.transitionInteractive : nil;
    }
    return nil;
}


全屏侧滑返回

创建一个继承于UINavigationController的一个对象WSLNavigatioController，遵守协议<UIGestureRecognizerDelegate>,实现如下方法：

  // 获取系统自带滑动手势的target对象
    id target = self.interactivePopGestureRecognizer.delegate;
    // 创建全屏滑动手势，调用系统自带滑动手势的target的action方法
    UIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc] initWithTarget:target action:@selector(handleNavigationTransition:)];
    // 设置手势代理，拦截手势触发
    pan.delegate = self;
    // 给导航控制器的view添加全屏滑动手势
    [self.view addGestureRecognizer:pan];
    // 禁止使用系统自带的滑动手势
    self.interactivePopGestureRecognizer.enabled = NO;

#pragma mark -- UIGestureRecognizerDelegate
// 什么时候调用：每次触发手势之前都会询问下代理，是否触发。
// 作用：拦截手势触发
- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer
{
    // 注意：只有非根控制器才有滑动返回功能，根控制器没有。
    // 判断导航控制器是否只有一个子控制器，如果只有一个子控制器，肯定是根控制器
    if (self.childViewControllers.count == 1) {
        // 表示用户在根控制器界面，就不需要触发滑动手势，
        return NO;
    }
    return YES;
}


解决UIScrollView的滑动手势与全屏侧滑手势的冲突

创建一个UIScrollView的类别UIScrollView+GestureConflict，重写如下方法：

-(BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer{
    
    // 首先判断otherGestureRecognizer是不是系统pop手势
    if ([otherGestureRecognizer.view isKindOfClass:NSClassFromString(@"UILayoutContainerView")]) {
        // 再判断系统手势的state是began还是fail，同时判断scrollView的位置是不是正好在最左边
        if (otherGestureRecognizer.state == UIGestureRecognizerStateBegan && self.contentOffset.x == 0) {
            return YES;
        }
    }
    return NO;
}

作者：且行且珍惜_iOS
链接：https://www.jianshu.com/p/a9b1307b305b
来源：简书
简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。







      
        
        


    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
            
            
         
          
         
 






 
 
 
 
 
 
 




