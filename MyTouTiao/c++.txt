c++

完成任务后, 您可以点击图标, 修改为已完成.

iostream.h老版的c++使用它，新版的使用iostream

为什么引入命名空间namesapce

多个开源库之间定义了相同的变量，程序不知道使用哪个开源库的变量

namespace的创建

namespace NamespaceA
{
	int a = 10;
}

namespace NamespaceB
{
	int a = 20;

	namespace NamespaceC
	{
		struct Teacher
		{
			char name[64]; 
			int age;
		};
	}
}

namespace的使用

void main()
{
	using namespace NamespaceB::NamespaceC;
	Teacher t1;
	t1.age = 35;
	system("pause");

}

实用性增强

//在c语言中int c必须定义在函数块的前面才可以很好的使用，而c++不需要这样作
void main()
{
	int a;
	int b;
	printf("hello....\n");
	int c;
	system("pause");
	return ;
}

register功能增强

前期的电脑内存有限，硬件性能有限，所以用register关键字放寄存器中运算
在c语言中register修饰的变量是不可以取地址的，但在c++中register修饰的变量可以取地址
由于循环次数太多，c++会自动把变量放入寄存器中处理，使速度更快
	//1C++编译器会对经常使用的变量 自动优化成 寄存器变量 提高速度
	for (int i=0; i<100000; i++)
	{
		i ++ ;
	}

功能检测增强


在C语言中，重复定义多个同名的全局变量是合法的
	在C++中，不允许定义多个同名的全局变量
C语言中多个同名的全局变量最终会被链接到全局数据区的同一个地址空间上
//错误案例不行 ...
int g_var;
int g_var = 1;
C++直接拒绝这种二义性的做法。

strcut类型增强

//定义一个结构体
//类型上 做了加强 
//1 C++编译器 认为 定义了一个新的数据类型 
//内部成员是公有的，如果是class定义的，内部默认是私有的
struct Teacher
{
	char name[64];
	int age ;

	int getAge()
	{
		return age;
	}

	void  setAge(int _age)
	{
			age = _age;
		
	}
};

void main()
{
	Teacher t1;   //c++可以这样申明，如果是c需要要struct Teacher t1
	t1.age = 36;

	t1.setAge(80); //调用成员函数 修改 变量的属性
	cout<<t1.getAge()<<endl;   //
	
	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

类型检查根据严格

/*
C++中所有的变量和函数都必须有类型
C语言中的默认类型在C++中是不合法的


函数f的返回值是什么类型，参数又是什么类型？
函数g可以接受多少个参数？
*/

/*
//更换成.cpp试试，会报错

f(i)
{
	printf("i = %d\n", i);

}

g()
{
	return 5;
}

int main(int argc, char *argv[])
{

	f(10);

	printf("g() = %d\n", g(1, 2, 3, 4, 5));


	getchar();	
	return 0;
}

*/

bool类型

//数据类型  :本质是告诉c++编译器分配固定大小的内存块的别名  
void main()
{
	//Teacher t1;
	
	bool b = true; //只有 ture false; 
	printf("sizeof(b): %d sizeof(bool) :%d \n", sizeof(b),sizeof(bool));//打印结果为1
	return ;
}

三目运算符

	int a = 10;
	int b = 20;
(a < b ? a : b )= 30;//在c++中成立
因为给表达值赋值，左边的三目运算符返回的要么是a变量，要么是b变量
但在c中不成立，c 中左边表达式要么返回10,要么返回20


const专题

struct Teacher 
{
	char name[64];
	int age;
};

//p所指向的内存空间不能被修改
void ModifyT1(const Teacher *p)
{
	//p->age = 10;
}

//p变量 是const的..p的值 不能被修改
void ModifyT2(Teacher * const p)
{
	/*
	//p = NULL;
	p = 1;
	p = 3;
	*/
}
//指针变量 和 它 所指向的内存空间变量 是两个不同的概念 
void main()
{
	Teacher t1;
	ModifyT2(&t1);
	//const int a; //int const b;//这两种无区别

	//const int *c;//c指向的内存空间的值不能被修改*c=3;错误
	//int * const d;//d存的内存空间地址不能被修改 d=0x2e34错误
	//const int * const e ;
	system("pause");
	return ;
}

引用的语法及引用本质的探究

void main()
{
        //引用的本质，引用必须先赋值，在c++编译器中，遇见引用，会自动把它处理成int *const b = &a;的常量指针，b存的内存地址不可以修改，但是b指向的内存空间值可以改,b=3可以被c++编译器优化为*b=3;
	int a =10; 
	int &b = a;  //1很想给常量赋值  // int *const b = &a;
	return ;
}

第二章  2.1类相关


#include <iostream>
using namespace std;

//圆形的面积

//1 是封装了 属性(成员变量 )和方法 (成员函数)
//2 面向对象 加工的是类 

class MyCircle
{

	int m_age;
private:
	int m_r;
	int m_s;

public:
	char name[64];
	int getR()
	{
		return m_r;
	}

	void setR(int r)
	{
		m_r = r;
	}

	int getS()
	{
		m_s = 3.14*m_r*m_r;
		return m_s;
	}

protected:
private:
};


//public 修饰的成员变量 成员函数  可以在类的内部 使用 ,也可以在类的外部使用
//private  修饰的成员变量 成员函数  只能在类的内部使用 ,不能在类的外部使用
//protected  修饰的成员变量 成员函数 只能在类的内部使用 不能在类的外部使用(继承 场景先不说)

//3 对属性和方法进行访问控制

//4 类的内部 类的外部
void main11()
{
	MyCircle c1, c2;//类的初始化
	//c1.m_r = 10;
	c1.setR(10);
	cout<<"c1:" << c1.getS() << endl;

	c2.setR(20);
	cout<<"c2:" << c2.getS() << endl;
	
	cout<<"hello..."<<endl;
	system("pause");

	//c2.m_age = 33;
	return ;
}

struct Teacher
{
	
	int age;
	char name[64];
public:
	int getAge()
	{
		return age;
	}
};

void main12()
{

	Teacher  t1;

	t1.age  = 41;

	system("pause");
}


void printMyCircle1(MyCircle *pC)//类类型指针作为函数参数传参以及处理方式
{
	pC->getR();
	pC->getS();
}

void printMyCircle2(MyCircle &mycircle)//类类型引用作为函数参数传参以及处理方式
{
	mycircle.getS();
	mycircle.getR();
}


//
void printMyCircle3(MyCircle mycircle)//类对象作为函数参数传参的处理方式和类引用的处理方式一样，用.
{
	mycircle.setR(1999);
}

void main()
{
	MyCircle c1, c2;
	//c1.m_r = 10;
	c1.setR(10);
	cout<<"c1:" << c1.getS() << endl;

	c2.setR(20);
	cout<<"c2:" << c2.getS() << endl;

	//printMyCircle2(c1);
	printMyCircle3(c1);

	system("pause");

}

案例设计立方体面积和体积类，求立方体是否相等


#include <iostream>
using namespace std;

//案例1	设计立方体类(cube)，求出立方体的面积和体积
//求两个立方体，是否相等（全局函数和成员函数）

class  Cube
{
public:
	int getA()
	{
		return m_a;
	}
	int getB()
	{
		return m_b;
	}
	int getC()
	{
		return m_c;
	}

	void setABC(int a=0, int b=0,int c=0)
	{
		m_a = a; m_b = b; m_c = c;
	}

	int getS()
	{
		m_s = 2*(m_a*m_b + m_b*m_c + m_c*m_a);
		return m_s;
	}
	int getV()
	{
		m_v = m_a*m_b*m_c;
		return m_v;
	}
public:
	//ret = c1.judgeCube(c1, c2, &tag);
	//c1.judgeCube2(c2);
	int judgeCube2(Cube &c2, int *tag)
	{
		if (tag == NULL)
		{
			return -1;
		}
		// 执行 //c1.judgeCube2(c2); 相等于 执行c1对象的 类的 成员函数judgeCube2, 在这个judgeCube2函数中
		// m_a 代表的是 c1的m_a
		if (m_a  == c2.getA() &&
			m_b == c2.getB() &&
			m_c == c2.getC() )
		{
			*tag = 1;
		}
		else
		{
			*tag = 0;
		}
		return 0;
	}

	int judgeCube(Cube &c1, Cube &c2, int *tag)
	{
		if (tag == NULL)
		{
			return -1;
		}

		if (c1.getA() == c2.getA() &&
			c1.getB() == c2.getB() && 
			c1.getC() == c2.getC() )
		{
			*tag = 1;
		}
		else
		{
			*tag = 0;
		}
		return 0;
	}

private:
	int m_a;	int m_b;	int m_c;	int m_v;	int m_s;
};
//通过全局函数求解
//1 相等 0不相等
int judgeCube(Cube &c1, Cube &c2, int *tag)
{
	if (tag == NULL)
	{
		return -1;
	}

	if (c1.getA() == c2.getA() &&
		c1.getB() == c2.getB() && 
		c1.getC() == c2.getC() )
	{
		*tag = 1;
	}
	else
	{
		*tag = 0;
	}
	return 0;
}


void main()
{
	int ret = 0;
	int tag = 0;
	Cube c1, c2;
	c1.setABC(1, 2, 3);
	c2.setABC(10, 20, 30);

	//类的成员函数的调用方法
	ret = c1.judgeCube2(c2, &tag);
	if (ret !=  0)
	{
		printf("func judgeCube2() err %d \n ", ret);
		return ;
	}

	if (tag == 1)
	{
		printf("相等\n");
	}
	else
	{
		printf("不相等\n");
	}

	//int judgeCube2(Cube &c2, int *tag)

	//全局函数的测试方法
	
	ret = judgeCube(c1, c2, &tag);
	if (ret !=  0)
	{
		printf("func judgeCube() err %d \n ", ret);
		return ;
	}

	if (tag == 1)
	{
		printf("相等\n");
	}
	else
	{
		printf("不相等\n");
	}
	system("pause");
	return ;
}


void main21()
{
	int ret = 0;
	Cube c1, c2;
	c1.setABC(1, 2, 3);
	c2.setABC(10, 20, 30);
	cout << "the s of c1: " << c1.getS();
	cout << "the v of c1: " << c1.getV();
	
	cout<<"hello..."<<endl;

	int tag = 0;
	ret = judgeCube(c1, c2, &tag);
	if (ret !=  0)
	{
		printf("func judgeCube() err %d \n ", ret);
		return ;
	}

	if (tag == 1)
	{
		printf("相等\n");
	}
	else
	{
		printf("不相等\n");
	}
	system("pause");
	return ;
}

求点和圆的关系（圆内和圆外）



/*案例2	设计一个圆形类（AdvCircle），和一个点类（Point），计算点在圆内部还是圆外
	即：求点和圆的关系（圆内和圆外）
	*/

#include <iostream>
using namespace std;

class Point
{
public:
	int getX1()
	{
		return x1;
	}
	int getY1()
	{
		return y1;
	}

	void setX1(int _x1)
	{
		x1 = _x1;
	}
	void setY1(int _y1)
	{
		y1 = _y1;
	}
private:
	int x1;
	int y1;
};

class AdvCircle
{
public:
	void setXYR(int _x0, int _y0, int _r)
	{
		x0 = _x0;
		y0 = _y0;
		r = _r;
	}
	int getX0()
	{
		return x0;
	}
	int getY0()
	{
		return y0;
	}
	int getR()
	{
		return r;
	}
public:
	//int tag = c1.judgeD(&p1);
	int judgeD(Point &myp)
	{
		int dd = ( x0-myp.getX1() ) *( x0-myp.getX1() ) + (y0-myp.getY1())* (y0-myp.getY1());
		if (dd > r*r)
		{
			return 0;
		}
		else
		{
			return 1;
		}
	}
private:
	int x0;
	int y0;
	int r;

private:
	Point myp1;  //UML
};

void main()
{
	
	AdvCircle  c1;
	c1.setXYR(3, 3, 2);

	Point p1;
	p1.setX1(7);
	p1.setY1(7);

	//tag	1 在圆形	内部   
	//		0			外部
	int tag = c1.judgeD(p1);
	if (tag == 1)
	{
		printf("点在圆形的内部\n");
	}
	else
	{
		printf("点在圆形的外部\n");
	}

	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

指针做函数参数内存印象图



#include <iostream>
using namespace std;

struct Teacher
{
	char name[64];
	int age;
};

//通过getTeacher分配内存，用二级指针作为形参，如何分配内存
int getTeacher(Teacher **p)
{
	Teacher *tmp =NULL;//临时指针
	tmp = (Teacher * )malloc(sizeof(Teacher));
	if (tmp == NULL)
	{
		return -1;
	}
	memset(tmp, 0, sizeof(Teacher));

	tmp->age = 36;
	strcpy(tmp->name, "tmptmp");

	//间接赋值 

	//p是实参的地址  *实参的地址 去间接的修改实参的值
	*p = tmp;
	return 0;
}


void  ModfyTeacher(Teacher *p)
{
	p->age = 88;
}

void FreeTeacher(Teacher *p)
{
	if ( p == NULL)
	{
		return ;
	}
	free(p);
}

//指针做函数参数
void main()
{
	Teacher t1; //分配栈变量
	t1.age = 35;

	Teacher *myP = NULL;

	//myp 是一个变量 它的值是NULL 0

	//函数调用的时候 , 形参2级指针 去修改了实参1级指针的值
	//函数调用的时候 , 形参n级指针 去修改了实参n-1级指针的值

	//步骤1 分配内存
	getTeacher(&myP);//当形参是二级指针时的传参方式
	cout<< "myp->name:" << myP->name << " " << "myp->age:" <<myP->age <<endl;

	//步骤2 使用内存 .修改内存
	ModfyTeacher(myP);//当形参是一级指针时的传参方式
	cout<< "myp->name:" << myP->name << " " << "myp->age:" <<myP->age <<endl;

	//步骤3
	FreeTeacher(myP);

	system("pause");
	return ;
}



间接赋值成立的三个条件


#include <iostream>
using namespace std;

void ModfyA(int *p)//间接赋值 方式1：一级指针作为形参，在函数内修改值
{
	*p = 20;//间接赋值 *a的地址 去间接的了修改a
}
void main01()
{
	int a = 0;  //0级指针

	a = 11;//直接赋值  //条件1 定义了两个变量 实参a 形参 p


	
	{
		int *p  = NULL;
		p = &a;  //条件2 建立关联     
		*p = 20;//间接赋值 *a的地址 去间接的了修改a  //条件3 *p 间接赋值
	}
	//

	{
		ModfyA(&a);
	}

	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

void ModfyP(char **p2)//二级指针作为形参，为P2赋值，p2是地址
{
	*p2 = (char *)0x20; //间接赋值 p2是实参 p的地址 

	char *tmp = (char *)malloc(1000);
	*p2 = tmp;//p2的值为tmp，tmp存的是地址
}

void main02()
{
	char * p = NULL;

	p = (char*)0x1;
	p = (char *)0x2;

	//间接的修改p的值
	{
		char **p2 = NULL;
		p2 = &p ;//一级指针取地址符的地址可赋给二级指针p2
		*p2 = (char *)0x20; //间接赋值 p2是实参 p的地址 
	}  

	//通过函数调用 
	{
		ModfyP(&p);
	}
}


char ** getMem(int num)
{
	char **p = NULL;
	p = (char **)malloc(num*sizeof(char *)); // char *array[10];
	if (p == NULL)
	{
		return NULL;

	}
	for (int i=0; i<num; i++)
	{
		p[i] = (char *)malloc(64*sizeof(char)) ;// char buf[64];
		sprintf(p[i], "%d%d%d", i, i, i);
	}
	
	return p;
}

int getMem2(char ***p3, int num)
{
	char **p = NULL;
	p = (char **)malloc(num*sizeof(char *)); // char *array[10];
	if (p == NULL)
	{
		return -1;

	}
	for (int i=0; i<num; i++)
	{
		p[i] = (char *)malloc(64*sizeof(char)) ;// char buf[64];
		if (p[i] == NULL )
		{
			return -2;
		}
		sprintf(p[i], "%d%d%d", i, i, i);
	}
	//间接赋值

	*p3 = p; //间接赋值 去修改 二级指针 p2的值
	return 0;
}

void MOdifyP2(char ***p3, int num)
{
	*p3 = (char **)3; //间接赋值 去修改 二级指针 p2的值
}


void FreeMem2p(char **p, int num)
{
	if (p==NULL)
	{
		return ;
	}
	for (int i=0; i<num; i++)
	{
		free(p[i]);
	}
	free(p);
}

void main2111()
{
	int num = 10;
	char **p = NULL;
	//p = getMem(num);

	getMem2(&p, num);

	for (int i= 0; i< num; i++)
	{
		printf("%s", p[i]);
	}

	FreeMem2p(p, num);

	{
		p = NULL;
		p = (char **)1;

	}

	//间接的修改二级指针p
	{
		char ***p3 = NULL;
		//p3 = &p2;

		//*p3 = (char **)3; //间接赋值 去修改 二级指针 p2的值
	}
	system("pause");
}


//间接赋值成立的3个条件


//条件1 定义了两个变量 实参a 形参 p
//条件2 建立关联  
//条件3 *p 间接赋值

//间接赋值应用场景
//1 2 3 
//12 写在一个函数里面      3 写在被调用函数 ===>指针做函数参数 

//1					23  //引用

int ModfyAA(int &b)
{
	b = 100;
}

int main()
{
	int a = 10; //定义两个变量
	int &b = a;
	b = 11;

	ModfyAA(a);

}
/*
void main()
{
	char buf1[100];
	char buf2;
	char *p1 = buf1;
	char *p2 = buf2;
	strcpy(buf1, "buf1113233");

	int i = 0;
	while(buf1[i] != '\0')
	{
		*p2 = *p1;
		p2 ++; 
		p1 ++;
		i ++;
	}
}*/



_函数返回值是一个引用


#include <iostream>
using namespace std;

//
int* getAA2()
{
	int a;
	a = 10;
	return &a;
}

int getAA1()
{
	int a;
	a = 10;
	return a;
}
//
int& getAA3()
{
	int a;
	a = 28;
	return a;
}


//结论1: 当函数返回值为引用时 若返回栈变量 	不能成为其它引用的初始值 
//2	不能作为左值使用

void main01()
{
	int mya = getAA1();
	int myb = getAA3();

	 mya = getAA1();
	 
	
	printf("mya:%d \n", mya);   //ok

	
	myb = getAA3();  
	int &myc = getAA3();
	printf("myb:%d \n", myb);  //?
	
	printf("myc:%d \n", myc); //?? 乱码  //*myC


	cout<<"hello..."<<endl;
	system("pause");
	return ;
}


//如果让函数当左值 返回 一定要是一个引用


int& getBB()
{
	static int a = 100;
	a ++;
	printf("a:%d \n", a);
	return a;
}
int main()
{//
	//getAA1() = 100;

	int c = getBB(); //101
	printf("c:%d \n", c);

	getBB() = 200;
	getBB();
	getBB();
	system("pause");
}

常引用


#include <iostream>
using namespace std;


//void opA(const int * const c)
void OpA(const int &c)
{
	printf("c:%d \n", c);
	//c = 100;
}

void main()
{
	//1 普通引用
	int a = 10;
	int &b = a;


	//常引用 

	//1 用变量初始化 常引用 让变量拥有只读属性
	{
		const int &c = a;  //c就是a的别名 
		//c = 20;  //不能通过c来修改a
		a = 100;
		OpA(a);
	}

	//2 用字面量初始化常引用
	{
		const  int myd = 10;  //myd入符号表  &myd
		const int &d = 10;  //c++编译器 会额外的分配内存 
	}


	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

inline

//内联函数由编译器处理，把编译后的函数插入到调用的地方，省去了压栈跳转返回，现代的C++编译器更智能，为了优化性能，有些函数自动处理成内联函数
//宏代码片段由预处理器处理，进行简单的文本替换，没有任何编译过程
#include <iostream>
using namespace std;

/*
inline void printAAA()
{
	cout<<"aaaadddd"<<endl;
}
void main()
{
	int a;
	
	//printAAA();
	{
		cout<<"aaaadddd"<<endl;
	}

	cout<<"hello..."<<endl;
	system("pause");
	return ;
}
*/

#include "iostream"
using namespace std;
#define MYFUNC(a, b) ((a) < (b) ? (a) : (b))  

inline int myfunc(int a, int b) 
{
	return a < b ? a : b;
}

int main21()
{
	int a = 1;
	int b = 3;
	int c = myfunc(++a, b);  //头疼兄弟 c
	//int c = MYFUNC(++a, b);  //===>  ((++a) < (b) ? (++a) : (b))  

	printf("a = %d\n", a); //3（宏的结果）  2 （内联函数的结果）
	printf("b = %d\n", b); //3（宏的结果）	3	
	printf("c = %d\n", c); //3（宏的结果）	2

	system("pause");
	return 0;
}


函数的扩展



#include <iostream>
using namespace std;

//1  

void printAAa(int x = 3)
{
	printf("x:%d \n", x);
}

//2  一旦在一个函数调用中开始使用默认参数值，那么这个参数后的所有参数都必须使用默认参数值
void printAA2(int a, int b, int x = 3, int y=4, int z=100 )
{
	printf("x:%d \n", x);
}

void main22_1()
{
	printAAa(5);
	printAAa();
	
	cout<<"hello..."<<endl;
	system("pause");
	return ;
}


//函数占位参数 ，可传多个参数
void printA(int a, int b, int)
{
	cout<<"aadddd" <<endl;
}

void main22_2()
{
	//printA(1, 2);  //调用 函数占位参数 的函数的规则  : 参数个数要写全
	printA(1, 2, 3);

	system("pause");
}

//函数默认参数 和  占位参数 在一起 

void fun3(int a, int b, int =0)
{
	cout<<"ddddd"<<endl;
}

//结论: 可以写2个参数 3个参数
void main22()
{
	//fun3(1, 2, 3);
	fun3(1, 2);

	system("pause");
}

函数重载


#include <iostream>
using namespace std;

//1 函数重载的概念

//2 函数返回类型  不是 函数重载的判断标准，函数名相同，返回类型不同将报错
/*
int printAA(int a)
{
	cout<<"a:"<<a<<endl;
	return 10;
}
*/

void printAA(int a)
{
	cout<<"a:"<<a<<endl;
}

/*
void printAA(int a, int  b)
{
	cout<<"a:"<<a<<endl;
}


void printAA(char *p)
{
	//cout<<"a:"<<a<<endl;
}

*/
void printAA(char *p, int a)
{
	//cout<<"a:"<<a<<endl;
}

void printAA(int a, char *p)
{
	//cout<<"a:"<<a<<endl;
}


void main23_1()
{
	printAA("aaaaa", 10);
	printAA(1);
	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

void myfunc(int a, int b, int c = 0)//二义性问题，因为这里可以写两个参数，也可以写三个参数
{
	;
}

void myfunc(int a, int b)
{
	;
}

void main()
{
	myfunc(10, 2, 3);

	myfunc(1, 3); //二义性问题
	system("pause");
}

函数重载和函数指针在一起


#include <iostream>
using namespace std;

//函数重载 遇上 函数指针 

//函数指针的知识体系的梳理

int myPrint(int a)
{
	return a;
}

int myfunc(int a)
{
	printf("func1.....\n");
	return 0;
}


int myfunc(int a, int b)
{
	printf("func1.....\n");
	return 0;
}


int myfunc(char *p)
{
	printf("func1.....\n");
	return 0;
}

//1 定义一个函数类型 

typedef int (MyFuncTypePrint)(int a);

//2 定义一个函数指针类型  
typedef int (*MyPFuncTypePrint)(int a);

//3 定义一个指针变量 函数指针变量


int test_callback( int (*myfuncp)(int a), int a, int b)
{
	return 0;
}


int test_callback2( MyFuncTypePrint *pFunc, int a, int b)
{
	return 0;
}


int test_callback3( MyPFuncTypePrint pFunc, int a, int b)
{
	return 0;
}

void main()
{
	//1
	{
		MyFuncTypePrint *funcp = NULL;
		funcp = &myPrint;
		
	}


	//2
	{
		MyPFuncTypePrint pMyFunc = NULL;
	}
	

	//3
	{
		int (*myFuncVar)(int a); //myFuncVar告诉cc++编译器给我分配内存
		 myFuncVar = myPrint;

	}

	//4 函数重载 和 函数指针在一起
	{
		int (*myFuncVar)(int a);
		myFuncVar = myfunc; //函数类型的变量赋值
		myfunc(1); //直接调用
		myFuncVar(1); //间接调用

		///myFuncVar(1, 2); //间接调用
	}

	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

带.h的类创建和使用

MyTeacher.h

//设计一个类 老师类 MyTeacher 属性(age name) 方法(set get)
//测试

/* //避免头文件的 重复包含头文件，在C语言中
#ifndef _MY_TEACHER_H__
#define _MY_TEACHER_H__


#endif 
*/

#pragma  once//在c++中避免重复包含头文件


class MyTeacher
{
public:
	int getAge();
	void  setAge(int _age);
	char *getName();
	void setName(char *_name);

private:
	int age;
	char name[64];
};



MyTeacher.cpp


#include <iostream>
using namespace std;

#include "MyTeacher.h"

int MyTeacher::getAge()
{
	return age;
}

void  MyTeacher::setAge(int _age)
{
	age = _age;
	return ;
}

char *  MyTeacher::getName()
{
	return name;
}

void MyTeacher::setName(char *_name)
{
	if (_name == NULL)
	{
		memset(name, 0, sizeof(name));
	}
	else
	{
		strcpy(name, _name);
	}
	
	return ;
}


mainClass.cpp



#include <iostream>
using namespace std;

#include "MyTeacher.h"


void main()
{

	MyTeacher t1;
	t1.setAge(36);
	t1.setName("老王");

	cout << "age: " << t1.getAge()<< endl;
	cout << "name:" << t1.getName() << endl;

	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

第三章  对象构造和析构基础

#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
using namespace std;

//1 不写构造函数 c++编译器默认提供构造函数  
//2 若写了构造函数  c++编译器 会自动调用 我们写的构造函数  析构函数在对象销毁时自动被调用

//3 作用 

class Test01
{
public:
	~Test01()
	{
		if (p != NULL)
		{
			free(p);
		}
		cout << "我是析构函数 我会被C++编译器自动调用...\n"; 
	}

public:
	Test01()
	{
		age = 35;
		strcpy(name, "myname");
		p = (char *)malloc(128);
		strcpy(p, "malloc的数据");

		cout << "我是构造函数 我会被C++编译器自动调用...\n"; 
	}
	
	char *getP()
	{
		return p;
	}
protected:
private:


	Test01(int a)
	{
		age = 35;
		strcpy(name, "myname");
		p = (char *)malloc(128);
		strcpy(p, "malloc的数据");

		cout << "我是构造函数 我会被C++编译器自动调用...\n"; 
	}
	
	int age ;
	char name[64];
	char *p;
};

//让对象唱戏
void playobj()
{
	Test01 t1; //
	cout << t1.getP() << endl;
}

void main11()
{
	playobj();
	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

构造函数的分类


#include <iostream>
using namespace std;

class Test2
{
public:
	//无参数构造函数
	Test2()
	{
		cout << "无参数构造函数" << endl;
	}

	//有参构造函数
	Test2(int _a)
	{
		cout << "有参构造函数" << endl;
	}

	Test2(int _a, int _b)
	{
		cout << "有参构造函数" << endl;
	}


	//拷贝构造函数 
	Test2(const Test2 & obj)
	{
		cout << "我是拷贝构造函数 ,我也是构造函数啊....." << endl;
		cout << "我也是用来完成对象的初始化 用一个对象来初始化 另外一个对象 而已....." << endl;
	}

	//默认构造函数 ...
	/*
	Test2()
	{
		cout << "无参数构造函数" << endl;
	}*/

	~Test2()
	{
		cout << "析构函数 call \n";
	}


protected:
private:
};

//无参数构造函数的调用
void playobj2_无参数构造函数调用方法()
{
	Test2 t1, t2, t3;
	//无参数构造函数错误调用方法
	//Test2  t4(); 不能在t4后面加括号
}

void playobj3()
{
	//1 括号法
	Test2 t1(1);  //C++编译器 会自动的调用构造函数 
	Test2 t2(1, 2);

	//2  = 
	Test2 t3 = 1; //1   //C++编译器 会自动的调用构造函数  = 

	Test2 t4 = (1, 2, 100); //2

	//3 有参数构造函数的第三种方法

	Test2 t5 = Test2(200); //程序员 主动  调用构造函数  
	Test2 t6 = Test2(200, 300);

	//早期版本 //1匿名对象  2匿名对象初始化 创建t5构造函数会被调用2次..
	//现带版本 对象初始化的流程 是不一样的..

}

void main21()
{
	playobj3();

	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

为什么要有初始化方案


#include <iostream>
using namespace std;

class Test3
{
public:

	void init(int a = 0)
	{
		cout << "a : " << a << endl;
	}
	
	//有参构造函数
	Test3(int _a)
	{
		cout << "有参构造函数" << endl;
	}

	Test3(int _a, int _b)
	{
		cout << "有参构造函数" << endl;
	}


	//拷贝构造函数 
	Test3(const Test3 & obj)
	{
		cout << "我是拷贝构造函数 ,我也是构造函数啊....." << endl;
		cout << "我也是用来完成对象的初始化 用一个对象来初始化 另外一个对象 而已....." << endl;
	}

	//默认构造函数 ...
	/*
	Test3()
	{
		cout << "无参数构造函数" << endl;
	}*/

	~Test3()
	{
		cout << "析构函数 call \n";
	}


protected:
private:
};

void main()
{
	Test3  t1(1);
	t1.init(100);

	Test3  t21(1);
	Test3  t22(1);
	Test3  t23(1);

	Test3  myArray[3] = {t21, t22, t23};
	//Test3  myArray[9999] = {t21, t22, t23};

	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

拷贝构造函数调用时机

/*
在有指针的情况下，浅拷贝只是增加了一个指针指向已经存在的内存，而深拷贝就是增加一个指针并且申请一个新的内存，使这个增加的指针指向这个新的内存，采用深拷贝的情况下，释放内存的时候就不会出现在浅拷贝时重复释放同一内存的错误！
*/
#include <iostream>
using namespace std;

class AA
{
public:
	AA()
	{
		cout << "无参数 构造函数 \n"; 
	}
	AA(int _a)
	{
		cout << "有参数 构造函数 \n"; 
		a = _a;
	}
	//AA a2 = a1;
	AA(const AA& obj1)
	{
		cout << "我是拷贝构造函数 用一个对象初始化另外一个对象\n"; 
		a = obj1.a + 10000;
	}
	void printAA()
	{
		cout << "a:" << a << endl;
	}
	~AA()
	{
		cout << "我析构函数 \n"; 
	}
protected:
private:
	int a;

};

void 	objplay()
{
	AA  a1(100);

	AA  a3(200);
	a1.printAA();

	AA a2 = a1; //用对象a1 来 初始化 对象 a2  ;会调用 a2类的 拷贝copy构造函数
	a2.printAA();

	a3 = a1;//  对象的=操作   // 对象的初始化  和 对象的=操作 是两个不同的概念 
				//这个场景 会使用C++编译器给我们提供的默认的=等号操作   会执行一个浅copy ...抛砖...
#include <iostream>
using namespace std;

class AA
{
public:
	AA()
	{
		cout << "无参数 构造函数 \n"; 
	}
	AA(int _a)
	{
		cout << "有参数 构造函数 \n"; 
		a = _a;
	}
	//AA a2 = a1;
	AA(const AA& obj1)
	{
		cout << "我是拷贝构造函数 用一个对象初始化另外一个对象\n"; 
		a = obj1.a + 10000;
	}
	void printAA()
	{
		cout << "a:" << a << endl;
	}
	~AA()
	{
		cout << "我析构函数 \n"; 
	}
protected:
private:
	int a;

};

void 	objplay()
{
	AA  a1(100);

	AA  a3(200);
	a1.printAA();

	AA a2 = a1; //用对象a1 来 初始化 对象 a2  ;会调用 a2类的 拷贝copy构造函数
	a2.printAA();

	a3 = a1;//  对象的=操作   // 对象的初始化  和 对象的=操作 是两个不同的概念 
				//这个场景 会使用C++编译器给我们提供的默认的=等号操作   会执行一个浅copy ...抛砖...因为a3和a1开始已经创建 出来了
	
}

void objplay02()
{
	AA  a1(100);
	a1.printAA();

	AA a2(a1);
	a2.printAA();

}


void main()
{
	objplay02();
	
	cout<<"hello..."<<endl;
	system("pause");
	return ;
}
	
}

void objplay02()
{
	AA  a1(100);
	a1.printAA();

	AA a2(a1);
	a2.printAA();

}


void main()
{
	objplay02();
	
	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

第三种场景的使用




#include <iostream>
using namespace std;

class Location 
{ 
public:
	Location( int xx = 0 , int yy = 0 ) 
	{ 
		X = xx ;  Y = yy ;  cout << "Constructor Object.\n" ; 
	}

	/*
	//类的拷贝构造函数
	//Location a2 = a1;
	Location( Location & obj)
	{
		X = obj.X + 100;
		Y = obj.Y + 100;

		cout << "我是copy构造函数.\n" ; 
	}
	*/

	Location(const Location& obj)
	{
		X = obj.X + 100;
		Y = obj.Y + 100;

		cout << "我是copy构造函数.\n" ; 
	}
	

	~Location() 
	{ 
		cout << X << "," << Y << " Object destroyed." << endl ; 
	}
	int  GetX () 
	{ 
		return X ; 
	}		
	int GetY () 
	{
		return Y ; 
	}
private :   
	int  X , Y ;
} ;

//元素做函数参数，当传参时会执行深拷贝
void g(Location b)
{
	cout << b.GetX()  << endl;
	cout << b.GetY()  << endl;
}
void objPlay()
{
	Location a;
	g(a);
}

void main()
{
	Location a1;
	Location a2 = a1;
	objPlay();
	cout<<"hello..."<<endl;
	cout<<"hello...\n";
	cout<<"hello...";

	printf("hello.....");
	printf("hello.....\n");
	system("pause");
	return ;
}


第四种场景的应用



#include <iostream>z
using namespace std;

class Location 
{ 
public:
	Location( int xx = 0 , int yy = 0 ) 
	{ 
		X = xx ;  Y = yy ;  cout << "Constructor Object.\n" ; 
	}

	Location(const Location& obj)
	{
		X = obj.X + 100;
		Y = obj.Y + 100;

		cout << "我是copy构造函数.\n" ; 
	}
	
	~Location() 
	{ 
		cout << X << "," << Y << " Object destroyed." << endl ; 
	}
	int  GetX () 
	{ 
		return X ; 
	}		
	int GetY () 
	{
		return Y ; 
	}
private :   
	int  X , Y ;
} ;

Location j()
{
	Location a;
	cout << a.GetY() << endl;
	return a; // 会调用copy构造函数，创建一个新对象，此时的a是栈变量将消失
}
//匿名对象的对和留需要看调用后怎么接收
////没有使用匿名对象  匿名对象马上消失
void objPlay1()
{
	//1
	Location  b = j();//因为b这个时候才创建，匿名对象转换成b
	cout << "\n" << b.GetY() << endl;
	cout << "objPlay1" << endl;
}

void objPlay2()
{
	//2
	Location  b2(1, 2);
	b2 = j();//因为b2已经创建，所以匿名对象赋值给b2，然后匿名对象消失
	cout << "\n" << b2.GetY() << endl;
	cout << "objPlay2" << endl;
}
void main()
{
	Location g = j();//此时的匿名对象直接转化为g
    Location m = Location(1,2);
    m = j();//因为m已经被创建，所以g会把它的属性赋值给m，j()这个匿名对象自动消失
	objPlay1();
	objPlay2();
	
	system("pause");
	return ;
}


构造函数的调用规则研究


#include <iostream>
using namespace std;


//总结：只要你写了构造函数，那么你必须用，如果没写,c++编译器会提供默认构造函数和拷贝构造函数
class  Test07
{
public:
	//1定义了拷贝构造函数  c++编译器 不会在提供 无参数 构造函数 
	Test07(const Test07 & obj2)
	{
		cout << "我是拷贝构造函数" << endl;
	}
	//2 当类中定义了任意的非拷贝构造函数（即：当类中提供了有参构造函数或无参构造函数），c++编译器不会提供默认无参构造函数
	Test07(int a, int b)
	{
		cout << "我有参构造函数" << endl;
	}

protected:

private:

};


void main()
{
	//Test07 t1;
	
	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

深拷贝和浅拷贝

#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
using namespace std;

class Name
{
public:
	Name(char *p)
	{
		m_p = (char *)malloc(strlen(p) + 1);
		if (m_p == NULL)
		{
			return ;
		}
		strcpy(m_p, p);
		age = 35;
	}

	Name(char *p, int _age)//初始化构造函数一点要避免浅拷贝
	{
		m_p = (char *)malloc(strlen(p) + 1);
		if (m_p == NULL)
		{
			return ;
		}
		strcpy(m_p, p);
		age = _age;
		cout << "避免浅拷贝 显示的写了一个copy构造函数 \n";
	}

	//Name  n2 = n1;
	Name(const Name & n1)//拷贝构造函数也要避免浅拷贝
	{
		//根据n1.m_p分配内存
		m_p = (char *)malloc( strlen(n1.m_p) + 1);
		strcpy(m_p, n1.m_p);
		age = n1.age;
	}

	~Name()
	{
		if (m_p != NULL)
		{
			free(m_p);
			m_p = NULL;
		}
	}
	void printN()
	{
		cout << "m_p: " << m_p << endl;
	}

protected:
private:
	int age;
	char *m_p;
};

void objplay()
{
	Name  n1("n1n1n1n1");
	n1.printN();

	Name  n2("n2n2n2n2");
	n1.printN();

	Name  n3 = n1; //避免delete的时候出现两次释放，报错，所以类中写深拷贝
	n3.printN();
	n3 = n1;  //有问题
}


////初始化操作  如果没有写copy构造函数 ,c++会给我们提供默认的copy构造函数 浅拷贝
//=操作  //如果没有写=操作函数 (没有重载=操作符)  ,c++会给我们提供默认的=操作函数   浅拷贝

void main()
{
	 objplay();
	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

多个对象初始化研究


#include <iostream>
using namespace std;

//varchar
//vaarchar2
class A
{
public:
	A(int _a)
	{
		a = _a;
		cout << "A的构造函数a: " << a << endl;
	}
	~A()
	{
		cout << "A的析构函数 do\n" << "a:" << a << endl;
	}
protected:
private:
	int a;
};

class B
{
public:
	B(int b) : a1(1), a2(2), m_const_b(100)
	{
		m_b = b;
		cout << "B" << endl;
	}

	//1 参数化传递 
	B(int a, int b) : a2(a+2), a1(a+1) ,  m_const_b(200)
	{
		m_b = b;
		cout << "B2222" << endl;
	}
	~B()
	{
		cout << "B的析构函数do\n";
	}
protected:
private:
	//2被组合对象的 构造函数的 调用顺序 和 定义顺序有关;与构造函数的参数化列表没有关系
	A a1;
	A a2;
	int m_b;
	const int m_const_b;
};

void playobj()
{
	 B b1(0, 1);
	 cout << "----------\n";
}
void main()
{
	playobj();
	
	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

构造函数和析构函数综合训练


//对象做函数参数
//1 研究拷贝构造 
//2 研究构造函数，析构函数的调用顺序，最先构造的对象最后析构，释放

//总结 构造和析构的调用顺序

#include "iostream"
using namespace std;

class ABCD 
{
public:
	ABCD(int a, int b, int c)
	{
		this->a = a;
		this->b = b;
		this->c = c;
		printf("ABCD() construct, a:%d,b:%d,c:%d  \n", this->a, this->b, this->c);
	}
	~ABCD()
	{
		printf("~ABCD() construct,a:%d,b:%d,c:%d  \n", this->a, this->b, this->c);
	}
	int getA() 
	{
		return this->a;
	}
protected:
private:
	int a;
	int b;
	int c;
};


class MyE
{
public:
	MyE():abcd1(1,2,3),abcd2(4,5,6),m(100)//这里初始化调用的顺序和类的定义顺序有关，先调用abcd1的构造函数，再调用abcd2，最后调用自己的构造函数
	{
		cout<<"MyD()"<<endl;
	}
	~MyE()
	{
		cout<<"~MyD()"<<endl;
	}
	MyE(const MyE & obj):abcd1(7,8,9),abcd2(10,11,12),m(100)
	{
		printf("MyD(const MyD & obj)\n");
	}

protected:
	//private:
public:
	ABCD abcd1; //c++编译器不知道如何构造abc1
	ABCD abcd2;
	const int m;

};

int doThing(MyE mye1)
{
	printf("doThing() mye1.abc1.a:%d \n", mye1.abcd1.getA()); 
	return 0;
}

int run2()
{
	MyE myE;
	doThing(myE);
	return 0;
}

//
int run3()
{
	printf("run3 start..\n");

	//ABCD(400, 500, 600); //临时对象的生命周期   //直接调用构造函数 将产生匿名对象

	ABCD abcd = ABCD(100, 200, 300);
	//若直接调用构造函数呢？
	//想调用构造函数对abc对象进行再复制，可以吗？
	//在构造函数里面调用另外一个构造函数，会有什么结果？

	printf("run3 end\n");
	return 0;
}

int main()
{
	//run2();
	run3();
	system("pause");
	return 0;
}



构造中调用构造，初学者常犯的错误


#include "iostream"z
using namespace std;

class MyTest
{
public:
	MyTest(int a, int b, int c)
	{
		this->a = a;
		this->b = b;
		this->c = c;
	}

	MyTest(int a, int b)//总是先初始化完成匿名对象然后再初始化自己
	{
		this->a = a;
		this->b = b;
		//c = 100;//其实在这里给C赋值是最合理的

		MyTest(a, b, 100); //产生一个匿名对象，这样赋值不合理，此时的c是匿名对象的c
	}
	~MyTest()
	{
		printf("MyTest~:%d, %d, %d\n", a, b, c);
	}

protected:
private:
	int a;
	int b;
	int c;

public:
	int getC() const { return c; }
	void setC(int val) { c = val; }
};

int main()
{
	MyTest t1(1, 2);
	printf("c:%d", t1.getC()); //请问c的值是？乱码，因为没赋值
	system("pause");
	return 0;
}

static成员变量，所有类的对象共享这个成员变量，修改这个成员变量将会改变其它类的成员变量

在普通类函数里是可以使用类的静态成员变量的

静态成员函数用static修钸，可以用对象调用，可以以类名::方式调用

静态成员函数不能使用非静态成员变量，因为普通成员变量和函数为具体的某一个对象所有


#include <iostream>
using namespace std;

class Test12
{
public:
	static int c; //声明一个静态成员变量

	void printAB() //1 普通成员函数 是可以 使用静态成员变量的..
	{
		cout << "a:" << a << "b:" << b << endl; 
		cout << "c:" << c << endl; 
	}


	static void printC()  //静态成员函数
	{
		cout << "我是静态成员函数 ,欢迎call我...\n";
		//cout << "a:" << a << "b:" << b << endl; 
		cout << "c" << c << endl;
	}
protected:

private:
	int a; //声明普通成员变量
	int b;
};

int Test12::c = 100;

/*
c++编译器 的静态成员函数 printC
	区分不出来 a 是t1.a  t2.a  t3.a
	导致编译器出错

结论: 在静态成员函数里面 ,不能调用 普通成员变量 
	但是可以调用静态成员变量
//普通的成员变量 a  b 归 具体的 对象所有 
*/
void main()
{
	//Test12  t1, t2;
	//t1.printC();

	Test12::printC();

	system("pause");
}


void main12_1_静态成员变量测试()
{
	Test12 t1, t2, t3, t4;

	cout << t1.c << endl;
	cout << t2.c << endl;
	cout << t3.c << endl;
	cout << t4.c << endl;
	t2.c = 200;
	t1.printAB();

	cout <<Test12::c << endl;

	
	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

c++对象模型初探


#include <iostream>
using namespace std;


class C1
{
public:
	int i;  //4
	int j; //4
	int k;  //4
protected:
private:
}; //12

class C2
{
public:
	int i; //4 
	int j; //4
	int k; //4

	static int m; //4
public:
	int getK() const { return k; } //4
	void setK(int val) { k = val; }  //4

protected:
private:
}; //12 16 24 



void main()
{
	
	printf("sizeof(c1): %d \n", sizeof(C1)); //12
	printf("sizeof(c2): %d \n", sizeof(C2)); //12 成员变量是存放在对象的空间的，而静态成员变量和成员函数以及静态成员函数是存放在全局数据data区的

	C2 c2_a, c2_b, c2_c; //===>静态成员变量   和 函数的入口地址 都没有 变量中
	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

对象模型初探_练习this



#include <iostream>
using namespace std;

class Test14
{

public:
	
	static int c; //声明一个静态成员变量
	Test14(int a, int b)  // ==> Test14(Test14  *this, int a, int b) 
	{
		this->a = a;
		this->b = b;
	}

	//2 const 修饰的是谁
	void  printAB() const //1 普通成员函数 是可以 使用静态成员变量的.. ==> g_printAB(Test14 *this)
	{
		cout << "a:" << this->a << "b:" << b << endl; 
		cout << "c:" << c << endl; 
	}


	//1 const 修饰的不是形参 m n
	//2 const printAB
	// const 有可能修饰的a  b
	//
	const void  printAB(const int m , int n)   //1 普通成员函数 是可以 使用静态成员变量的.. ==> g_printAB(Test14 *this)
	{
		//m = 100;
		//a = 1000;
		b = 100;

		cout << "a:" << this->a << "b:" << b << endl; 
		cout << "c:" << c << endl; 
	}
	// void  printAB(const Test14* this, int m , int n) 


	static void printC()  //静态成员函数
	{
		cout << "我是静态成员函数 ,欢迎call我...\n";
		//cout << "a:" << a << "b:" << b << endl; 
		cout << "c" << c << endl;
	}
protected:

private:
	int a; //声明普通成员变量
	int b;
};

int Test14::c = 100;
//1  const修饰成员函数 写在什么地方 都没有问题


void main()
{
	
	Test14  t1(1, 2); //  g_Test14(&t1, 1, 2);
	t1.printAB();
	t1.c = 100;
	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

this指针修饰类创建的对象

在C语言中const变量是只读变量，有自己的存储空间
在c++中的const常量，可能分配存储空间，也可能不分配存储空间，当const常量为全局，并且需要在其它文件中使用，会分配存储空间，当使用&操作符，取const常量地址时，会分配存储空间，当const int &a = 10,修钸引用时，也会分配存储空间

const和成员函数在一起，当const修钸成员函数时，写在哪里都没有问题
void printAB() const;const修钸的是那个隐藏的this指针指向的内存空间不能被修改，例如 void printAB(const Test14 *this,int m, int n),所以这个时候不能修改成员变量的值

第四章  运算符重载入门技术推演


#include <iostream>
using namespace std;

//类  复数类 
// a + bi 

class Complex
{
public:
	Complex(int a = 0, int b = 0)
	{
		this->a = a;
		this->b = b;
	}
	void printCom()
	{
		cout << a << " + " << b << "i" << endl; 
	}
public:
	int a;
	int b;

};

//1 普通函数
Complex MyAdd(Complex &c1, Complex &c2)
{
	Complex tmp(c1.a + c2.a, c1.b + c2.b);
	return tmp;
}

// 函数名 做文章
Complex operator+(Complex &c1, Complex &c2)
{
	Complex tmp(c1.a + c2.a, c1.b + c2.b);
	return tmp;
}

void main()
{
	Complex c1(1, 2), c2(3, 4);

	//1 定义不同全局函数
	Complex c3 = MyAdd(c1, c2);
	c3.printCom();

	//2 operator入场
	Complex c4 = operator+(c1, c2);
	c4.printCom();

	//3 + 入场
	Complex c5 = c1 + c2;
	c5.printCom();

	//结论: 运算符重载是C++编译器器给我们程序员提供的机制.运算符重载的本质: 是一个函数, 运算符重载函数

	// 运算符重载函数  operator+     operator-   operator/     operator+*

	c1++;
	++c1;
	cout<<"hello..."<<endl;
	system("pause");

}

void main_自定义数据类型_不能直接加减()
{
	Complex c1(1, 2), c2(3, 4);

	int a = 10; 
	int b = 20 ;
	int c ;
	c = a +b;

	//Complex c3 = c1 + c2; //1 自定义数据类型 类,C++编译器 不知道如何进行 + -

	//2 C++编译器会提供一种机制 让自定义对象进行 + -  ====>运算符重载机制...

	
	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

运算符重载的两种方法


#include <iostream>
using namespace std;

//类  复数类 
// a + bi 

class Complex
{
	friend Complex operator+(Complex &c1, Complex &c2);
	friend Complex & operator++ (Complex &c1);
	friend 	Complex operator++(Complex &c1, int) ;
public:
	Complex(int a = 0, int b = 0)
	{
		this->a = a;
		this->b = b;
	}
	void printCom()
	{
		cout << a << " + " << b << "i" << endl; 
	}
public:
	// 通过成员函数 实现 -运算符重载
	//Complex c4 = c1 - c2; 
	Complex operator-(Complex &c2)
	{
		Complex tmp(this->a -c2.a , this->b - c2.b);
		return tmp;
	}
	// --运算符重载
	////--c1;
	 Complex& operator-- ()
	 {
		 a--;
		 b--;
		 return *this;
	 }

	 //类成员函数 实现后置--
	 // c1.operator--
	 Complex operator--(int)
	 {
		 Complex tmp = *this;
		 this->a --;
		 this->b --;
		 return tmp;
	 }
private:
	int a;
	int b;

};


//通过全局函数 实现 +运算符重载
Complex operator+(Complex &c1, Complex &c2)
{
	Complex tmp(c1.a+c2.a, c1.b + c2.b);
	return tmp;
}

//前置++操作符 用全局函数实现
Complex & operator++ (Complex &c1)
{
	c1.a ++;
	c1.b ++;
	return c1;
}

//后置++操作符 用全局函数实现
// c1++		先使用		再让c1的属性++
Complex operator++(Complex &c1, int) 
{
	Complex tmp = c1;
	c1.a ++;
	c1.b ++;
	return tmp;
}

/*
全局函数、类成员函数方法实现运算符重载步骤

	1、要承认操作符重载是一个函数，写出函数名称
	2）根据操作数，写出函数参数 
	3、根据业务，完善函数返回值，及实现函数业务
	*/
void main()
{
	Complex c1(1, 2), c2(3, 4);

	//1 通过全局函数 实现 +运算符重载

	Complex c3 = c1 + c2; 
	//1-1 函数的调用方式 operator+(c1, c2)
	//1-2 Complex operator+(Complex &c1, Complex c2)
	c3.printCom();

	//2 通过成员函数 实现 -运算符重载
	Complex c4 = c1  - c2; //需要我们程序员 写一个 -运算符重载函数
	c4.printCom();
	//operator-();
	//2-1 函数调用 c1.operator-(c2)
	//2-2 函数原形 
	//Complex operator-(Complex &c2)

	//3 //前置++操作符 用全局函数实现
	++c1;
	//3-1 函数原形 Complex & operator++ (Complex &c1)
	//3-2 函数调用 	operator++(c1);
	c1.printCom();

	//4 //前置--操作符 用成员函数实现
	--c1;
	//4-1 函数原形  Complex & operator-- ();
	//4-2 函数调用 	 c1.operator--();
	c1.printCom();

	//5 后置++ 用全局函数实现
	c1++;
	c1.printCom();
	//
	//函数调用语句  operator++(&c1);
	//函数定义: Complex operator++(Complex &c1) ;

	//6 后置-- 用成员函数实现
	c1--;
	c1.printCom();

	//Complex operator--();
	//c1.operator--()

	cout<<"hello..."<<endl;
	system("pause");
}



对象模型初探_全局函数pk成员函数


#include <iostream>
using namespace std;

class Test
{
public:
	Test(int a=0, int b=0)
	{
		this->a = a;
		this->b = b;
	}
	
	void printT()
	{
		cout << "a:" << a << "b: " << b << endl;
	}

	Test myAdd(Test &t2)
	{
		Test t3(this->a + t2.a , this->b + t2.b);
		return t3;
	}
	//成员函数 返回 this对象的元素 
	Test& myAdd2(Test &t2)
	{
		this->a = this->a + t2.a;
		b =  b + t2.b;
		return *this;
	}

public:
	int a;
	int b;
};


//把成员函数 转成 全局函数  多了一个参数
void printT(const Test * pTest)
{
	//pTest = 19;
	//pTest->a = 1009;
	cout << "a:" << pTest->a << "b: " << pTest->b << endl;
}


//函数返回元素  和 返回引用的 意义
//1 函数返回元素: 相当于t1+t2的运算结果 放入到新的变量中 (匿名对象)
//2 
Test myAdd(Test &t1, Test &t2)
{
	Test t3(t1.a + t2.a , t1.b + t2.b);
	return t3;
}

//全局函数
Test& myAdd2(Test &t1, Test &t2)
{
	t1.a = t1.a + t2.a;
	t1.b = t1.b + t2.b;
	return t1;
}

//全局函数
void  myAdd3(Test &t1, Test &t2)
{
	t1.a = t1.a + t2.a;
	t1.b = t1.b + t2.b;
}


void main()
{
	Test t1(1, 2), t2(3, 4);
	myAdd2 (t1, t2);
	t1.printT();

	//
	t1.myAdd2(t2);

	myAdd3(t1, t2);
	t1.printT();

	// 
	//void + t3 + t4;

	system("pause");

}


void main_把全局函数转换成成员函数()
{
	
	Test t1(1, 2), t2(3, 4);

	Test t3  = myAdd(t1, t2);
	t3.printT();

	//把全局函数转换成成员函数 
	//结论:少了一个参数
	Test t4 = t1.myAdd(t2);
	t4.printT();
	printT(&t4);

	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

new和delete基本语法


#include <iostream>
using namespace std;


//1 c:		malloc	free 函数
//	c++		new		delete  //运算符

//2 可以用new 基础数据类型  数组类型 对象

//3 混搭 new和delete的深入分析

void main16_01()
{
	//new 基础数据类型 
	int *p = (int *)malloc(sizeof(int));
	*p = 10;
	printf("*p:%d \n", *p);

	free(p);

	int *p2 = new int;
	*p2 = 20;
	printf("*p2:%d \n", *p2);

	delete p2;

	int *p3 = new int(100);

	delete p3;

	printf("*p3:%d \n", *p3);
	system("pause");
}

void main_1602()
{
	//c
	int *p = (int *)malloc(sizeof(int) * 10)  ;//int array[10]
	p[0] = 1;
	p[1] = 2;

	free(p);
	
	int *p2 = new int[10]{1, 2, 3};
	p2[0] = 10;
	printf("p2[0]: %d \n", p2[0]);

	delete [] p2;

	
	return ;

}

class  Test16
{
public:
	Test16(int a =0, int b=0)
	{
		this->a = a;
		this->b = b;
		cout << "我是Test16的构造函数\n";
	}
	void printT()
	{
		cout << "a:" << a << "b:" << b << endl;
	}
	~Test16()
	{
		cout << "我是Test16的析构函数"  << "a:" << a << "b:" << b << endl;
	}

protected:
private:
	int a;
	int b;
};


//结论: new不光 分配内存 而且会调用对象的构造函数
		//delete 不光释放内存 而且会调用对象的析构函数

void main_1603()
{
	//c
	Test16 *p1 = (Test16 *)malloc(sizeof(Test16));
	p1->printT();
	free(p1);

	Test16 *p2 = new Test16(1, 2);
	p2->printT();
	delete p2;


}
void main()
{
	//main16_01();
	//main_1602();
	main_1603();

	cout<<"hello..."<<endl;
	system("pause");
}

new和malloc混搭


#include <iostream>
using namespace std;


//1 c:		malloc	free 函数
//	c++		new		delete  //运算符

//2 可以用new 基础数据类型  数组类型 对象

//3 混搭 new和delete的深入分析

void main16_01()
{
	//new 基础数据类型 
	int *p = (int *)malloc(sizeof(int));
	*p = 10;
	printf("*p:%d \n", *p);

	//free(p);
	delete(p);

	int *p2 = new int;
	*p2 = 20;
	printf("*p2:%d \n", *p2);

	//delete p2;
	free(p2);

	int *p3 = new int(100);

	printf("*p3:%d \n", *p3);
	//delete p3;
	free(p3);

}

void main_1602()
{
	//c
	int *p = (int *)malloc(sizeof(int) * 10)  ;//int array[10]
	p[0] = 1;
	p[1] = 2;

	//free(p);
	//delete  p;
	delete [] p;

	int *p2 = new int[10];
	p2[0] = 10;
	printf("p2[0]: %d \n", p2[0]);

	//delete [] p2;
	free(p2);


	return ;

}

class  Test16
{
public:
	Test16(int a =0, int b=0)
	{
		this->a = a;
		this->b = b;
		cout << "我是Test16的构造函数\n";
	}
	void printT()
	{
		cout << "a:" << a << "b:" << b << endl;
	}
	~Test16()
	{
		cout << "我是Test16的析构函数"  << "a:" << a << "b:" << b << endl;
	}

protected:
private:
	int a;
	int b;
};


//结论: new不光 分配内存 而且会调用对象的构造函数
//delete 不光释放内存 而且会调用对象的析构函数

void main_1603()
{
	//c
	Test16 *p1 = (Test16 *)malloc(sizeof(Test16));
	p1->printT();
	//free(p1);
	delete (p1);

	Test16 *p2 = new Test16(1, 2);
	p2->printT();
	//delete p2;
	free(p2);
}

void main17_04()
{
	char *p = (char *)malloc(100);
	strcpy(p, "11112222");
	//free(p);

	free(p+1);

}

void main()
{
	//main16_01();
	main_1602();
	//main_1603();
	//main17_04();

	cout<<"hello..."<<endl;
	system("pause");
}



/*
1. delete 用于释放 new 分配的空间，free 有用释放 malloc 分配的空间
2. delete [] 用于释放 new [] 分配的空间
3. delete 释放空间的时候会调用 相应对象的析构函数
     顺便说一下new在分配空间的时候同时会调用对象的构造函数，对对象进行初始化，使用malloc则只是分配内存
4. 调用free 之前需要检查 需要释放的指针是否为空，使用delete 释放内存则不需要检查指针是否为NULL
5. free 和 delete 不能混用，也就是说new 分配的内存空间最好不要使用使用free 来释放，malloc 分配的空间也不要使用 delete来释放
     举个例子，<string.h>里通常有个strdup函数，它得到一个char*字符串然后返回其拷贝：
     char * strdup(const char *ps); // 返回ps所指的拷贝
     在有些地方，c和c++用的是同一个strdup版本，所以函数内部是用malloc分配内存。这样的话，一些不知情的c++程序员会在调用strdup后忽视了必须对   strdup返回的指针进行free操作。为了防止这一情况，有些地方会专门为c++重写strdup，并在函数内部调用了new，这就要求其调用者记得最后delete。你可以想象，这会导致多么严重的移植性问题，因为代码中strdup以不同的形式在不同的地方之间颠来倒去。
 
补充一个问题，free和delete 是如何知道需要释放的内存块的大小的？
     
     在调用malloc或new 分配内存空间的时候，实际分配的空间会比程序员申请的空间要大。实际分配的内存空间前面有一部分空间用于保存所分配内存的大小，校验和等信息。当分配函数返回时，将会返回实际可操作的地址（也就是实际分配空间加上前面用于记录分配信息的空间之后的地址）。下面举个例子，例子通过破坏 new 返回地址的前面四个字节的数据导致内存空间释放出问题。如果不破坏前面的数据则不会出现内存不能释放的情况。
复制代码
#include <stdio.h>
#include <new>
#include <iostream>
#include <stdlib.h>
#include <string.h>

int main()
{
    int *p = NULL,*p1=NULL;
    int i;
    //p = (int *) malloc(10 * sizeof(int));
    p = new int[10];

    memset(p,0,sizeof(int) * 10);
    for(i=0;i<10;i++)
        printf("P:%d\t",p[i]);
    printf("addr p: %x\n",p);

    *(p-1) = 2; //如果不注释掉这一行则程序运行不正确
    *(p+11) = 3;
    printf("addr before p: %x\n",p+11);
    printf("%x %x\n",*(p-1),*(p+11));

    //free(p);
    delete [] p;
    printf("free successfully! \n");
    return 0;
}
复制代码
当注释了*(p-1) = 2之后运行结果为：



*/



子主题 3

友元函数


#include <iostream>
using namespace std;

class Test
{
	friend void ModfyA(Test *p, int mya);
public:

	Test(int a = 0, int b = 0)
	{
		this->a = a;
		this->b = 0;
	}
	void printA()
	{
		cout << "a:" << a << endl;
	}
private:
	int a;
	int b;
};

//友元函数 是一个全局函数  不是Test类的成员函数
//void Test::ModfyA(Test *p, int mya)

void ModfyA(Test *p, int mya)
{
	p->a = mya;
}

void playobj()
{
	Test t1(3, 4);
	t1.printA();

	ModfyA(&t1, 30);  //通过友元函数来修改t1的私有属性  破坏了类的封装性

	t1.printA();

}

void main()
{
	playobj();
	
	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

友元类


#include <iostream>
using namespace std;

class A
{
	friend class B ; // 类B是类A的好朋友, 
					 //	类B中的成员函数可以访问类A的私有变量/调用私有函数
public:
	A(int a=0)
	{
		this->m_a = a;
	}
protected:
private:
	int m_a;
};

//friend破坏了类的封装性
// 为什么
// java 1.java ==> 1.class (jvm虚拟机), 1.class是字节码  ====>汇编语言

/*
gcc -E hello.c -o hello.i（预处理）
gcc -S hello.i -o hello.s（编译）
gcc -c hello.s -o hello.o（汇编）
gcc hello.o -o hello（链接）
以上四个步骤，可合成一个步骤
gcc hello.c -o hello（直接编译链接成可执行目标文件）
gcc -c hello.c或gcc -c hello.c -o hello.o（编译生成可重定位目标文件）
*/


class B
{
public:
	void setA(int a)
	{
		this->a.m_a = a;
	}

	void printA()
	{
		cout << "a.m_a : " << a.m_a << endl;
	}
protected:
private:
	A a;
};
void main()
{
	B bobj;

	bobj.setA(100);
	bobj.printA();
	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

c++实现数组案例

MyArray.h

#pragma  once

class MyArray
{
public:
	MyArray(int len);
	MyArray(const MyArray &obj);
	~MyArray();
public:
	void setData(int index, int data);
	int getData(int index);
	int getLength();

private:

	int m_len;
	int *m_space;

};

MyArray.cpp


#include <iostream>
using namespace std;

#include "MyArray.h"


//MyArray a1(10); //构造函数
MyArray::MyArray(int len)
{
	if (len <= 0)
	{
		return;
	}
	m_space = new int[len];
	m_len  = len;
}

//MyArray a2 = a1;
MyArray::MyArray(const MyArray &obj)
{
	//根据a1内存的大小   来初始化 一个内存

	m_len = obj.m_len;
	m_space = new int[m_len];
	
	//把a1的内存 copy给 a2 
	for (int i=0; i<m_len; i++)  //速度慢 一个一个元素赋值
	{
		m_space[i] = obj.m_space[i];
	}

	//内存块copy
	//memcpy(m_space, obj.m_space,sizeof(int)*m_len);

}

MyArray::~MyArray()
{
	if (m_space != NULL)
	{
		delete[] m_space;
		m_len = 0;
		m_space = NULL;
	}
}

//a1.setData(i, i+1);
void MyArray::setData(int index, int data)
{
	m_space[index] = data;
	return;
}

int MyArray::getData(int index)
{
	return m_space[index];
}

int MyArray::getLength()
{
	return m_len;
}


main.cpp


#include <iostream>
using namespace std;

#include "MyArray.h"

void mainobj()
{

	MyArray a1(3); //构造函数

	//set
	for (int i=0; i<a1.getLength(); i++)
	{
		a1.setData(i, i+1);
	}

	//get
	for (int i=0; i<a1.getLength(); i++)
	{
		printf("%d ", a1.getData(i));
	}

	//

	MyArray a2 = a1;
	for (int i=0; i<a2.getLength(); i++)
	{
		printf("%d ", a2.getData(i));
	}
}

void main()
{
	mainobj();
	cout<<"hello..."<<endl;
	system("pause");
}

运算符重载的正规写法


#include <iostream>
using namespace std;

//类  复数类 
// a + bi 

class Complex
{
	friend ostream& operator<< (ostream &out, Complex &c1);
	friend istream& operator>> (istream &in, Complex &c1);
public:
	Complex(int a = 0, int b = 0)
	{
		this->a = a;
		this->b = b;
	}
	void printCom()
	{
		cout << a << " + " << b << "i" << endl; 
	}
public:

	//通过成员函数 实现 +运算符重载
	Complex operator+(Complex &c2)
	{
		Complex tmp(a+c2.a, b + c2.b);
		return tmp;
	}

	// 通过成员函数 实现 -运算符重载
	//Complex c4 = c1 - c2; 
	Complex operator-(Complex &c2)
	{
		Complex tmp(this->a -c2.a , this->b - c2.b);
		return tmp;
	}

	//前置++操作符 通过成员函数
	Complex & operator++ ()
	{
		a ++;
		b ++;
		return *this;
	}

	// 前置--运算符重载
	////--c1;
	 Complex& operator-- ()
	 {
		 a--;
		 b--;
		 return *this;
	 }


	 //后置++操作符 类成员函数
	 // c1++		先使用		再让c1的属性++
	 Complex operator++(int) 
	 {
		 Complex tmp = *this;
		 a ++;
		 b ++;
		 return tmp;
	 }

	 //类成员函数 实现后置--
	 // c1.operator--
	 Complex operator--(int)
	 {
		 Complex tmp = *this;
		 this->a --;
		 this->b --;
		 return tmp;
	 }

private:
	int a;
	int b;
	char buf[64];

};

ostream& operator<< (ostream &out, Complex &c1)
{
	out << "12345 上山打老虎" << endl;
	out <<c1.a << " + " << c1.b << "i" << endl; 
	return out;
}


istream& operator>> (istream &in, Complex &c1)
{
	in >> c1.buf;

	cout << "请输入a的值";
	in >> c1.a;
	
	cout << "请输入b的值";
	in >> c1.b;

	return in;
}

void main()
{
	Complex c1(1, 2);
	cin >> c1;
	c1.printCom();
	system("pause");

}

void main32()
{
	int a = 10;
	char *p = "dddsss";
	cout << a << endl;
	cout << (int)p << endl;  //结论 << 运算符 能按照一种规定的数据类型格式进行数据的输出 

	Complex c1(1, 2);
	cout << c1 ;

	//1友元函数的方法
	// 1 void operator<< (ostream &out, Complex &c1)
	// 2 调用语言  operator<<(cout, c1);
	
	/* 
	//2成员函数的方法
	void operator<<( Complex &c1); 
	cout.operator <<(c1);
	//这种情况下  需要在 cout对象的类中 ,添加 成员函数operator<< 但是我们程序员拿不到 cout的源码

	*/

	//3
	//函数返回值当左值 返回一个引用
	cout << c1 << "dddd" << "支持链式编程" << endl << c1;

	//(operator<<(cout, c1) );
	//operator<< (  (operator<<(cout, c1) )    .   "支持链式编程" )

	// ((cout.operator <<(c1) ).operator<< ( "支持链式编程") ).operator<< (endl);
	// (void.operator<< ( "支持链式编程") ).operator<< (endl);

	//xxx << "支持链式编程" << endl
	//yyy<< endl;

	// ostream& operator<< (ostream &out, Complex &c1) ;
	system("pause");
}


/*
//话题1 
{
	//"aaaa"  << c1 << cout  <<;
	// c1.operator<<(cout);
	// ostream & operator<<(Complex &c)
}
*/

/*
全局函数、类成员函数方法实现运算符重载步骤

	1、要承认操作符重载是一个函数，写出函数名称
	2）根据操作数，写出函数参数 
	3、根据业务，完善函数返回值，及实现函数业务
	*/
void main31()
{
	Complex c1(1, 2), c2(3, 4);

	//1 通过全局函数 实现 +运算符重载

	Complex c3 = c1 + c2; 
	//1-1 函数的调用方式 operator+(c1, c2)
	//1-2 Complex operator+(Complex &c1, Complex c2)
	c3.printCom();

	//2 通过成员函数 实现 -运算符重载
	Complex c4 = c1  - c2; //需要我们程序员 写一个 -运算符重载函数
	c4.printCom();
	//operator-();
	//2-1 函数调用 c1.operator-(c2)
	//2-2 函数原形 
	//Complex operator-(Complex &c2)

	//3 //前置++操作符 用全局函数实现
	++c1;
	//3-1 函数原形 Complex & operator++ (Complex &c1)
	//3-2 函数调用 	operator++(c1);
	c1.printCom();

	//4 //前置--操作符 用成员函数实现
	--c1;
	c1.printCom();
	//根全面的测试
	{
		Complex myTmp1 = --c1;
		myTmp1.printCom();
	}
	
	//4-1 函数原形  Complex & operator-- ();
	//4-2 函数调用 	 c1.operator--();
	

	//5 后置++ 用全局函数实现
	c1++;
	c1.printCom();
	//根全面的测试
	{
		Complex myTmp1 = ++c1;
		myTmp1.printCom();
	}
	//
	//函数调用语句  operator++(&c1);
	//函数定义: Complex operator++(Complex &c1) ;

	//6 后置-- 用成员函数实现
	c1--;
	c1.printCom();

	//Complex operator--();
	//c1.operator--()

	cout<<"hello..."<<endl;
	system("pause");

}



重载等号运算符

#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
using namespace std;

class Name
{
public:
	Name(char *p)
	{
		m_p = (char *)malloc(strlen(p) + 1);
		if (m_p == NULL)
		{
			return ;
		}
		strcpy(m_p, p);
		age = 35;
	}

	Name(char *p, int _age)
	{
		m_p = (char *)malloc(strlen(p) + 1);
		if (m_p == NULL)
		{
			return ;
		}
		strcpy(m_p, p);
		age = _age;
		cout << "避免浅拷贝 显示的写了一个copy构造函数 \n";
	}

	//Name  n2 = n1;
	Name(const Name & n1)
	{
		//根据n1.m_p分配内存
		m_p = (char *)malloc( strlen(n1.m_p) + 1);
		strcpy(m_p, n1.m_p);
		age = n1.age;
	}

	//n3 = n1; 
	Name& operator=(Name &n1)
	{
		//1 先把n3的旧内存给释放 
		if (m_p != NULL)
		{
			free(m_p);
			//delete m_p;
			age = 0;
			m_p = NULL;
		}

		//2 根据n1的大小分配内存
		int len = strlen(n1.m_p);
		this->m_p = (char *)malloc(len + 1);

		//3 根据n1的值 copy数据 到n3
		strcpy(m_p, n1.m_p);
		age = n1.age;
		return *this;
	}

	~Name()
	{
		if (m_p != NULL)
		{
			free(m_p);
			m_p = NULL;
		}
	}
	void printN()
	{
		cout << "m_p: " << m_p << endl;
	}

protected:
private:
	int age;
	char *m_p;
};

void objplay()
{
	Name  n1("n1n1n1n1");
	n1.printN();

	Name  n2("n2n2n2n2");
	n1.printN();

	Name  n3 = n1; 
	n3.printN();
	
	n3 = n2;
	n3 = n2 = n1; // =操作符的结合顺序
	//void operator=(Name &n3, Name &n1);
}

////初始化操作  如果没有写copy构造函数 ,c++会给我们提供默认的copy构造函数 浅拷贝
//=操作  //如果没有写=操作函数 (没有重载=操作符)  ,c++会给我们提供默认的=操作函数   浅拷贝

void main()
{
	objplay();
	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

_重载逻辑与逻辑或_不能这样做

逻辑与或能重载但不能实现短路规则！
在C语言中if(0 &&(a1+a2))如果0为假，后面的将不会执行！但在C++中不能通过重载&&实现短路规则！

#include <cstdlib>
#include <iostream>

using namespace std;

class Test
{
	int i;
public:
	Test(int i)
	{
		this->i = i;
	}

	Test operator+ (const Test& obj)
	{
		Test ret(0);

		cout<<"执行+号重载函数"<<endl;
		ret.i = i + obj.i;
		return ret;
	}

	bool operator&& (const Test& obj)
	{
		cout<<"执行&&重载函数"<<endl;
		return i && obj.i;
	}
};

// && 从左向右
void main()
{
	int a1 = 0;
	int a2 = 1;

	cout<<"注意：&&操作符的结合顺序是从左向右"<<endl;

	if( a1 && (a1 + a2) )
	{
		cout<<"有一个是假，则不在执行下一个表达式的计算"<<endl;
	}

	Test t1 = 0;
	Test t2 = 1;

	if ( t1 && (t1 + t2) ) 
	{
		//	T1.operator&&(   t1 + t2)  )
		//	T1.operator&&(   t1.operator+(t2) )

			//t1  && t1.operator+(t2)  

			// t1.operator(  t1.operator(t2)  )   
			cout<<"两个函数都被执行了，而且是先执行了+"<<endl;
	}

	system("pause");
	return ;
}


第六章   继承的基本语法



#include <iostream>
using namespace std;

class Parent
{
public:
	int a;
	void printA()
	{
		cout << "a : " << a << endl;
	}

protected:
private:
	int b;
};

class Child1 : public Parent
{
public:
	void printfC()
	{
		c = 100;
		cout << "c: " << c << endl;
	}
	
protected:
private:
	int c;
};

class Child2 : protected Parent
{
public:
protected:
private:
};

void main()
{
	{ // publice 继承测试
		Child1  c1;
		c1.a = 10;
		c1.printA();
		c1.printfC();

		//c1.b = 1000;
	}

	{
		//保护继承


		Child2 c1;
		c1.a = 110;

	}
	


	cout<<"hello..."<<endl;
	system("pause");
	return ;
}



class Child3 : private Parent
{
public:
protected:
private:
};




派生类的访问控制


#include <iostream>
using namespace std;

class Test
{
public:
	int a;
protected:
	int b;
private:
	int c;
};
// public 修饰的成员变量成员函数 ,在类的内部 和外部 都能被访问
// protected 修饰的成员变量成员函数 ,在类的内部 (子类中)可以被访问
//private 修饰的成员变量成员函数 , 只能在类的内部使用

class Parent
{
public:
	int a;  //老爹的名字
protected:
	int b; //老爹的密码
private:
	int c; //老爹的情人
};


class Child3 : protected Parent
{
public:
	void useABC()
	{
		a = 1;  //ok
		b = 2; //ok
		//c = 3; //err
	}
protected:
private:
};

void main()
{
	Child3 c3;
	//c3.a = 10;  //err
	//c3.b = 20; //err
	//c3.c = 30; //err

	system("pause");
}



class Child2 : private Parent 
{
public:
	void useABC()
	{
		a = 1; //ok
		b = 2; //ok
		//c = 3; //err
	}
protected:
private:
};


void main22()
{
	Child2 c2;
	//c2.a = 10; //err
	//c2.b = 20; //err
	//c2.c = 30; //err
	system("pause");
}

class Child : public Parent
{
public:
	void useABC()
	{
		a = 1;  //ok
		b = 2;  //ok
		//c = 3;	 //err
	}
protected:
private:
};

/*
C++中的继承方式（public、private、protected）会影响子类的对外访问属性	
	判断某一句话，能否被访问
	1）看调用语句，这句话写在子类的内部、外部
	2）看子类如何从父类继承（public、private、protected）	
	3）看父类中的访问级别（public、private、protected）
*/

void main21()
{
	Child  c1;
	c1.a = 10;  //ok
	//c1.b = 20;  //err
	//c1.c = 30; //err
	
	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

派生类的访问控制综合训练

//类的继承方式对子类对外访问属性影响

#include <cstdlib>
#include <iostream>

//通过派生类 来访问 父类的属性和方法 

using namespace std;

class A
{
private:
	int a;
protected:
	int b;
public:
	int c;
	A()
	{
		a = 0;		b = 0;		c = 0;
	}
	void set(int a, int b, int c)
	{
		this->a = a;		this->b = b;		this->c = c;
	}
};

class B : public A
{
public:
	void print()
	{
		//cout<<"a = "<<a; //err
		cout<<"b = "<<b; //ok
		cout<<"c = "<<endl; //ok
	}
};

class C : protected A
{
public:
	void print()
	{
		//cout<<"a = "<<a; //
		cout<<"b = "<<b; // ok 
		cout<<"c = "<<endl; //包含的，在子类的内部能被使用 //ok
	}
};

class D : private A
{
public:
	void print()
	{
		//cout<<"a = "<<a;  //err
		cout<<"b = "<<b<<endl;  //ok 
		cout<<"c = "<<c<<endl;  //ok
	}
};

int main()
{
	A aa;
	B bb;
	C cc;
	D dd;
	
	aa.c = 100;  //ok
	bb.c = 100; //ok
	//cc.c = 100; // err
	//dd.c = 100;  // err

	
	aa.set(1, 2, 3); //ok
	bb.set(10, 20, 30); //ok
	//cc.set(40, 50, 60); //err
	//dd.set(70, 80, 90); //errr

	
	bb.print();
	cc.print();
	dd.print();
	/*
	 */
	system("pause");
	return 0;
}


类型兼容性原则


#include <iostream>
using namespace std;


/*
子类对象可以当作父类对象使用
子类对象可以直接赋值给父类对象
子类对象可以直接初始化父类对象
父类指针可以直接指向子类对象
父类引用可以直接引用子类对象

*/
class Parent
{
public:

	void printP()
	{
		cout << "我是爹...." << endl;
	}

private:
};

class Child : public Parent
{
public:
	void printC()
	{
		cout << "我是孩子" << endl;
	}
protected:
private:
};

void print01(Parent  *p)
{
	p->printP();
}

void print02(Parent  &p)
{
	p.printP();
}

void main()
{
	
	//1 子类就是一种特殊的父类 
	//可以用父类指针 指向 子类对象
	Parent  *p = NULL;

	Child c1;
	c1.printC();

	//类型兼容性原则
	p = &c1;
	
	p->printP();  //执行父类的函数 

	//有类型兼容性原则 所有C++编译器不会报错
	{
		Child	c2;
		Parent  p2;

		print01(&p2);
		print01(&c2);

		print02(p2);
		print02(c2);
	}
	//类型兼容性原则的 第二层含义  用子类初始化父类对象
	{
		Child	c3;
		Parent p3 = c3; //
	}
	
	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

继承中的构造和析构

/*
    继承关系，先初始化父类
    再初始化子类，
    先析构子类
    再析构父类
*/


#include <iostream>
using namespace std;

class Parent
{
public:
	Parent (int a = 0, int b = 0)
	{
		this->a = a;
		this->b = b;
		cout << "Parent 的构造函数 \n";
	}
	~Parent()
	{
		cout << "Parent 的析构函数 \n";
	}
public:
	void printP()
	{
		printf("a:%d , b:%d \n", a, b);
	}
protected:
private:
	int a;
	int b;
};

class  Child : public Parent
{
public:
	Child (int a, int b, int c) : Parent(a, b)
	{
		this->c = c;
		cout << "子类的构造函数 \n";
	}
	~Child()
	{
		cout << "子类的析构函数 \n";
	}
protected:

private:
	int c;
};


void objplay()
{
	Child c1(1, 2, 3);
	cout << "c1对象创建成功 \n";
}

void main()
{
	//Parent p1;

	objplay();
	
	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

继承和组合混搭下的构造和析构

/*
	在孙类中有爷爷类的成员对象，在初始化顺序时先执行爷爷类的初始化函数，再执行父亲的初始化函数，再执行孙类中爷爷类成员对象的初始化函数，析构函数顺序相反
*/
#include <iostream>
using namespace std;

class Object
{
public:
	Object(int a, int b)
	{
		this->a = a;
		this->b = b;
		printf("Object 构造函数 do ...a:%d b:%d \n", a, b);
	}
	~Object()
	{
		printf("Object 析构函数 do ...a:%d b:%d \n", a, b);
	}
protected:
private:
	int a;
	int b;
};
class Parent : public Object
{
public:

	Parent(char *p, int a, int b) : Object(a, b)
	{
		this->p = p;
		printf("Parent 构造函数 do ...a:%d b:%d, p:%s\n", a, b, p);
	}
	~Parent()
	{
		printf("Parent 析构函数 do\n");
	}
	
protected:
private:
	char *p;
};

class  Child : public Parent//这里需要初始化列表初始化父类和成员对象
{
public:
	Child(char *p, int a, int b): Parent(p, a, b), obj1(a, b), obj2(a+10, b+10)
	{
		this->p = p;
		printf("Child 构造函数 do ...a:%d b:%d, p:%s\n", a, b, p);
	}
	~Child()
	{
		printf("Child 析构函数 do . p:%s\n", p);
	}

protected:
private:
	char *p;
	Object obj1;
	Object obj2;
};

void playobj6()
{
	Child c1("继承和组合混搭测试", 1, 2);
	printf("c1对象初始化完毕\n");

}

void main()
{
	playobj6();
		
	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

继承中的同名成员变量函数


#include <iostream>
using namespace std;

class A
{
public:
	int a;
	int b;
	void print_parent()
	{
		cout << "b: " << b << endl;
	}

	void printT()
	{
		cout << "AAA" <<endl;
	}
protected:
private:
	
};

class  B : public A
{
public:
	int b;
	int c;
	void print_child()
	{
		cout << "b: " << b << endl;
	}

	void printT()
	{
		cout << "BBB" <<endl;
	}
protected:
private:
};

void main()
{
	B b1;//子类对象
	b1.printT(); //默认情况下 执行子类的printT
	b1.A::printT();//执行父类的printT
	system("pause");
}

void main71()
{

	//默认下是修改子类的b
	//若访问父类的b 是使用::
	B bObj;
	bObj.b = 100;
	cout << "bObj.b " << bObj.b ;
	bObj.print_child();
	cout << bObj.A::b << endl;


	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

继承遇上static关键字


#include <iostream>
using namespace std;

class A
{
	A()//不通这样写，这样写构造函数变成了私有的，除非用单例
	{
		//cout << "A构造" << endl;
	}
public:
	//static int a;
protected:
private:

};

class A1
{
public:
	A1()
	{

	}
protected:
private:
};
//int A::a = 100;//static int a需要分配空间

/*
class B :  private A
{
	
public:
	
	void useA()
	{
		cout << "A::a" << a << endl;
	}
	
protected:
private:
};
*/

void main()
{
	A a;
	//B bobj;
	//bobj.useA();
	system("pause");
}

void main81()
{
	
	//B  bObj;//b private protected 继承A，在外部都不可以通过bObj.a访问父类的静态成员变量
	//bObj.a = 100; 
	//结论1: static修饰的静态的变量 函数 遵守派生类访问控制规则  三看原则
	//结论2: //int A::a = 100; 不要忘记 这句话是分配内存 分配内存是大;初始化是小
	//结论3: 类构造函数不要写成私有的    单例除外
	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

多继承的语法


#include <iostream>
using namespace std;

class base1
{
public:
	int b1;
	void printB1()
	{
		cout << "b1: " << b1 << endl;
 	}
protected:
private:
};

class base2
{
public:
	int b2;
	void printB2()
	{
		cout << "b2: " << b2 << endl;
	}
protected:
private:
};

class C : public base1, public base2
{
public:
	int c;
protected:
private:
};

void main111()
{
	C  cObj;
	cObj.b1 = 100;
	cObj.b2 = 100;
	cObj.c = 200;
	cObj.printB1();
	cObj.printB2();

	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

多继承的二义性和解决方案


#include <iostream>
using namespace std;

class B
{
public:
	 B(int b=0)
	 {
		 cout << "老祖宗的构造函数B执行....\n"; 
	 }
	 ~B()
	 {
		  cout << "老祖宗的析构函数~B执行....\n"; 
	 }
	int b;
protected:
private:
};  //4


class B1:   public B
{
public:
	int b1;
protected:
private:
	
};  //8

class B2:   public B
{
public:
	int b2;
protected:
private:
}; //8

class C : public B1, public B2
{
public:
protected:
private:
}; 
//16

void playobj()
{
	C c1;
	//c1.b = 100;  //虚继承 防止了二义性

	c1.B1::b = 100;
	c1.B2::b = 200;

	c1.B2::B::b = 300;

	printf("c1对象构建完毕\n");
}

void main()
{
	printf("sizeof(B): %d \n", sizeof(B));
	printf("sizeof(B1): %d \n", sizeof(B1));
	printf("sizeof(B2): %d \n", sizeof(B2));
	printf("sizeof(C): %d \n", sizeof(C));
	
	playobj();
	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

虚继承的不能解决的问题


#include <iostream>
using namespace std;


class Base1
{
public:
	int b1;
	int b;
protected:
private:
};//大小是8个字节

class Base2
{
public:
	int b2;
	int b;
protected:
private:
};大小是8个字节

class C : virtual public Base1, virtual public Base2
{
public:
	int c;

protected:
private:
};//如果没加virtual关键字大小是12个字节,如果加了virtual关键字大小是20个字节，编译器会自动加一个4个字节的变量作为virtual的标记

// 虚继承的解决方案 不能把所有的场景都能解决 虚继承只能解决共同老祖先的....
//
void main()
{
	C cobj;
	cobj.b = 10;//两个父类中没有相同的成员变量b，因为加了virtual关键字，所以直接可以访问cobj.如果两个父类同时virtual继承了一个爷爷类，virtual告诉编译器如果爷爷调用了一次初始化构造函数则不会再调用多次

	cobj.Base1::b = 10;//两个父亲都有b时不能很好的解决二义性问题
	cobj.Base2::b = 20;

	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

赋值兼容性原则遇上函数重写


#include <iostream>
using namespace std;


class Parent
{
public:
	Parent(int a = 0)
	{
		this->a = a;
		cout << "Parent构造函数执行 \n";
	}
	void print()
	{
		cout << "Parent print():  a:" << a << endl;;
	}
protected:
private:
	int a;

};

class  Child : public Parent
{
public:
	Child(int a, int b) : Parent(a)
	{
		this->b = b;
	}

	virtual void print()
	{
		cout << "Child print() b:" << b << endl;;
	}
protected:
private:
	int b;
};

//1 不会报错 
//2 只会按照类型base指针的类型 ,去 调用类型中的函数 
//静态联编 : 在编译器编译源码的时候,根据类型就已经确定了要调用的函数 
//动态联编: 迟绑定
void HowToPrint(Parent	*base, )
{
	base->print();  //同样一句话 表现出多种形态
					//传来父类对象 执行父类的printf函数 传来子类对象 执行子类的printf

	/*
	if (a == 10)
	{

	}
	else if (a == 20)
	{

	}
	*/

}

void HowToPrint2(Parent	&base)
{
	base.print();
}

void main()
{
	Parent	*base = NULL;
	Child	c1(1, 2);
	Parent	p1(10);

	{
		base = &p1;
		base->print(); //执行父类的print函数

		base = &c1; //类型兼容性原则 (1可以让父类指针 引用 指向子类对象  2 用子类初始化父类 )
		base->print(); //希望: 执行子类的printf函数

	}

	//
	{
		HowToPrint(&p1);
		HowToPrint(&c1);

	}

	{
		HowToPrint2(p1);
		HowToPrint2(c1);  ////希望: 执行子类的printf函数
	}






	
	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

多态案例


#include <iostream>
using namespace std;

class HeroFighter
{
public:
	virtual int power()
	{
		return 10;
	}
protected:
private:
};

class AdvHeroFighter : public HeroFighter
{
public:
	int power()
	{
		return 20;
	}
protected:
private:
};

//这块地 ....后来人写的e.....
class AdvAdvHeroFighter : public HeroFighter
{
public:
	int power()
	{
		return 30;
	}
protected:
private:
};

class EnemyFighter 
{
public:
	int attack()
	{
		return 15;
	}
protected:
private:
};

//多态的威力1
//看成一个框架   15:58 ===>
void PlayObj(HeroFighter *base, EnemyFighter *ef)
{
	if (base->power() > ef->attack())
	{
		printf("英雄win....\n");
	}
	else
	{
		printf("英雄挂了....\n");
	}
}


/*
1 封装 突破了C的函数的概念 obj(a, b, func11)
2 继承 复用以前人写的代码
3 多态 可以使用后来人写的代码  可扩展.....
*/

//多态这么重要 
//多态成立的3个条件
//1 要有继承  2  要有虚函数重写，如果不重写则指向的是父类的虚函数 3 父类指针 父类引用 指向 子类对象 


//间接赋值成立的3个条件
// 1 定义2个变量  2 建立关联   3 *p


void main()
{
	HeroFighter hf;
	EnemyFighter ef;
	AdvHeroFighter ahf;

	AdvAdvHeroFighter advAdvhf;

	PlayObj(&hf, &ef);

	PlayObj(&ahf, &ef);

	PlayObj(&advAdvhf, &ef);

	system("pause");
}
void main222()
{
	HeroFighter hf;
	EnemyFighter ef;
	AdvHeroFighter ahf;

	if (hf.power() > ef.attack())
	{
		printf("主角win...\n");
	}
	else
	{
		printf("主角挂了...\n");
	}

	if (ahf.power() > ef.attack())
	{
		printf("主角win...\n");
	}
	else
	{
		printf("主角挂了...\n");
	}


	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

虚析构函数



#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
using namespace std;

class A
{
public:
	A()
	{
		pa = new char[64];
		strcpy(pa, "aaaaa");
	}
	virtual ~A()  //虚析构函数
	{
		if (pa != NULL)
		{
			delete [] pa;
			cout << "A析构执行"<< endl;
		}
	}
	void printA()
	{
		cout << pa << endl;
	}
protected:
private:
	char *pa ;
};



class B : public A
{
public:

	~B()
	{
		if (pb != NULL)
		{
			delete [] pb;
			cout << "B析构执行"<< endl;
		}
	}
	B()
	{
		pb = new char[64];
		strcpy(pb, "bbbbb");
	}
	void printB()
	{
		cout << pb << endl;
	}
protected:
private:
	char *pb ;
};


//希望通过 父类指针 释放所有的子类的资源,(执行子类的所有的析构函数,如果父类是虚 析构函数，delete mypa,将执行所有继承自父类的子类的析构函数
void howToDelete( A *pa)
{
	delete pa;
}
void main()
{
	A *mypa = new A;
	B *mypb = new B;
	
	mypa->printA();
	mypb->printB();

	howToDelete(mypa);
	howToDelete(mypb);



	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

重写 重载 重定义


#include <iostream>
using namespace std;

//重写 重载 重定义
//重写发生在2个类之间
//重载必须在一个类之间

//重写分为2类
//1虚函数重写  讲发生多态
//2 非虚函数重写 （重定义）


//结论:
//重载: 在一个作用域中 在一个类里面
//重写: 分两路 
	//virtual 函数重写 
	//非虚函数重写, 重定义.

class Parent
{
	//这个三个函数都是重载关系
public: 

	virtual void abc()
	{
		cout << "aaa" << endl;
	}	
	virtual void func() 
	{
		cout<<"func() do..."<<endl;
	}
	virtual void func(int i)
	{
		cout<<"func() do..."<<i<<endl;
	}
	virtual void func(int i, int j)
	{
		cout<<"func() do..."<<i<< " "<<j<<endl;
	}
protected:
private:
};


class Child : public Parent
{
	//
public: 
	virtual void func(int i, int j)
	{
		cout<<"func(int i, int j) do..."<<i<< " "<<j<<endl;
	}
	virtual void func(int i, int j, int k)
	{
		cout<<"func(int i, int j) do.."<< endl; 
	}
protected:
private:
};


//重载重写和重定义
void main()
{
	//: error C2661: “Child::func”: 没有重载函数接受 0 个参数
	Child c1;
	c1.Parent::func();//1 因为func函数在子类中已经存在,不会去执行父类的func函数
					//2 只会在子类中查找func函数 
					//3 如果没有就报错 ....函数重载只发生在一个类中 不会发生在父子之间
	c1.abc();



	//c1.abc();
	//c1.func();
	//c1.Parent::func(); //func函数的名字，在子类中发生了名称覆盖；子类的函数的名字，占用了父类的函数的名字的位置
	//因为子类中已经有了func名字的重载形式。。。。
	//编译器开始在子类中找func函数。。。。但是没有0个参数的func函数 


	cout<<"hello..."<<endl;
	system("pause");
	return ;
}


多态原理探究


#include <iostream>
using namespace std;
//为含有虚函数的类（父类）生成对象的时候, 偷偷的提前布局了一个vptr指针
						//vptr指针作用: 指向虚函数表
							//C++编译器的提前布局 
                           //当对象执行虚函数时，会看这个函数是否是虚函数，如果是虚函数，则从父类的对象中找vptr指针，再通过vptr指针找到对应的那张虚函数表，然后执行对应的函数
//多态成立的三个条件 
//1 继承  2 virtual函数重写 3 父类指针指向子类对象

class Parent
{
public:
	Parent(int a = 0)
	{
		this->a = a;
	}
	virtual void print() //动手脚1: 加上virtual关键字 C++编译器会特殊处理 
							//把虚函数的入口地址 存入到一个虚函数表中
							//应该是把 函数指针做函数参数(技术点)
	{
		cout << "Parent print() a:" << a << endl;
	}

	virtual void print2() //动手脚1: 加上virtual关键字 C++编译器会特殊处理 
		//
	{
		cout << "Parent print() a:" << a << endl;
	}

	virtual void print3() //动手脚1: 加上virtual关键字 C++编译器会特殊处理 
		//
	{
		cout << "Parent print() a:" << a << endl;
	}
	
protected:
private:
	int a ;
};


class Child : public Parent
{
public:
	Child(int a=0, int b = 0) : Parent(a)
	{
		this->b = b;
	}
	void print()
	{
		cout << " Child: print() b:" << b << endl;
	}
protected:
private:
	int b;
};

void HowToPrint(Parent *base)
{
	base->print(); //动手脚2: 效果:传来一个子类对象 执行子类的print 传来一个父类对象 执行父类的print
					// C++编译器 好像是 能自动区分子类对象 父类对象 ...
					//其实不是这样:


	//综合 如何把这3点联系起来:
	//当传来一个父类对象 ,看printf函数是否是虚函数 
	//1 是虚函数:	//传来父类对象, 从base中,找vptr,====>找虚函数表====>再找printf函数的入口地址
					//传来子类对象, 从base中,找vptr,====>找虚函数表====>再找printf函数的入口地址
					
}

void main111()
{
	
	Parent	p1(10);  //动手脚3: 初学者 最想不到的地方 怎么样由类生成对象由 大牛们说的算.
						//为含有虚函数的类生成对象的时候, 偷偷的提前布局了一个vptr指针
						//vptr指针作用: 指向虚函数表
							//C++编译器的提前布局 
	Child	c1(20, 30);

	HowToPrint(&p1);
	HowToPrint(&c1);


	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

证明vptr指针的存在


#include <iostream>
using namespace std;

class AA
{
public:
	virtual void print()
	{
		;
	}
	virtual void print2()
	{
		;
	}
	virtual void print3()
	{
		;
	}
protected:
private:
	int a;
};  //4 + 4 +4 +4 = 8如果创建对象，将会提前布局三个vptr指针指向不同的虚函数表

class BB
{
public:
	void print()
	{
		;
	}
protected:
private:
	int a;
}; //4
void main()
{
	printf("sizeof(AA):%d  sizeof(BB):%d \n", sizeof(AA), sizeof(BB));//打印结果 16 4
	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

指针数据类型



#include <iostream>
using namespace std;

void main001()
{
	int a[10]; //a代表数组首元素的地址
				//&a C语言规定: 代表整个数组的地址   //数组是有类型 
	//怎么定义一个数组类型
	//typedef int (TypeArray)[10];
	//TypeArray array; //int array[10];
	//printf("a:%d &a:%d \n", a, &a); //0xaa11
	//printf("a+1:%d &a+1:%d \n", a+1; &a+1);
	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

class Parent
{
public:
	Parent(int a = 0)
	{
		this->a = a;
	}
	virtual void print() //动手脚1: 加上virtual关键字 C++编译器会特殊处理 
		//把虚函数的入口地址 存入到一个虚函数表中
		//应该是把 函数指针做函数参数(技术点)
	{
		cout << "Parent print() a:" << a << endl;
	}


protected:
private:
	int a ;
};


class Child : public Parent
{
public:
	Child(int a=0) : Parent(a)
	{
		//this->b = b;
	}

	void print()
	{
		cout << "aaaaaa" << endl;
		//cout << " Child: print() b:" << b << endl;
	}

protected:
private:
	//int b;
	int b;
};

// 一次偶然的成功 比必然的失败更可怕 
void main()
{
	//定义子类对象数组

	Parent *base = NULL;
	Child *p = NULL;

	Child array[] = {Child(1), Child(2),Child(3),Child(4)};
	base = array;
	p  = array;

	base->print();  //打印子类的pritnf 多态发生
	p->print();


	base++;
	p++;
	base->print();  //打印子类的pritnf 多态发生
	p->print();

	base++;
	p++;
	base->print();  //打印子类的pritnf 多态发生
	p->print();


	system("pause");
}



抽象类基本语法



#include <iostream>
using namespace std;

class Figure  //抽象类只要有纯虚函数，就是抽象类，继承它的所有子类必须实现，如果有纯虚函数，只能被继承，不能补初始化为对象
{
public:
	virtual int Area() = 0; //纯虚函数  //统一界面  统一一套接口
};

// Circle Tri Squre

class Circle : public Figure
{
public:
	Circle(int a=0, int b=0)
	{
		this->a = a;
		this->b = b;
	}
	virtual int Area()
	{
		s = 3.14*a*a;
		cout << "Circle:Area: " << s << endl;
		return s;
	}
protected:
private:
	int a ;
	int b; 
	int s;
};



class Tri : public Figure
{
public:
	Tri(int a=0,int b = 0)
	{
		this->a = a;
		this->b = b;
	}
	virtual int Area()
	{
		s = a*b/2;
		cout << "Tri:Area: " << s << endl;
		return s;
	}
private:
	int a ;
	int b; 
	int s;

};

class Squre: public Figure
{
public:
	Squre(int a = 0, int b = 0)
	{
		this->a = a;
		this->b = b;
	}
	virtual int Area()
	{
		s = a*b;
		cout << "Squre:Area: " << s << endl;
		return s;
	}
protected:
private:
	int a ;
	int b; 
	int s;
};


//面向抽象类 编程
void playObj(Figure *base)
{
	base->Area(); //C++编译器的多态原理   
	//因area是虚函数,是纯虚函数, 传来base指针  找对象的vptr指针 ==>在找虚函数表====>Area入口地址 ===>调用后来人写的代码
} 

void main()
{
	//Figure f1;
	Figure *base;


	Squre s1(10, 20);
	//s1.Area();
	//base = &s1;
	//base->Area();  //会发生多态

	Tri tri1(30, 40);
	//tri1.Area();
	//base = &tri1;
	//base->Area();


	Circle c1(30, 40);
	/*
	//c1.Area();     //3000
	base = &c1;
	base->Area();
	*/



	playObj(&tri1);
	playObj(&c1);
	playObj(&s1);
	
	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

多继承的二义性


#include <iostream>
using namespace std;

class B
{
public:
	int b;
protected:
private:
};



class B1 : virtual public B
{
public:
protected:
private:
};


class B2 : virtual public B
{
public:
protected:
private:
};


class C : public B1, public B2
{
public:
protected:
private:
};

//多


void main()
{
	C c1;
	//c1.b = 10;
	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

_抽象类在多继承中的应用


#include <iostream>
using namespace std;

class Interface1
{
public:
	virtual int add(int a, int b) = 0;
	virtual void print() = 0;

};

class Interface2
{
public:
	virtual int div(int a, int b) = 0;
	virtual void print() = 0;
};


class  Parent
{
public:
	int c;
protected:
private:
};
class Child : public Parent, public Interface1, public Interface2
{
public:
	Child(int a=10, int b=10)
	{
		this->a = a;
		this->b = b;
	}
	virtual int add(int a, int b)
	{
		cout << "add do...\n";
		return a + b;
	}
	virtual void print()
	{
		cout << "print do...\n";
	}
	virtual int div(int a, int b)
	{
		cout << "div do...\n";
		return a / b;
	}
protected:
private:
	int a;
	int b;
};



void main()
{
	
	Child c1(10, 10);
	c1.print();
	Interface1 * it1 = &c1;
	it1->add(1, 2);
	it1->print();

	Interface2 * it2 = &c1;
	it2->div(10, 10);
	it2->print();



	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

面向抽象类编程计算程序员工资


#include <iostream>
using namespace std;


/*
编写一个C++程序, 计算程序员( programmer )工资  
	1 要求能计算出初级程序员( junior_programmer ) 中级程序员 ( mid_programmer )高级程序员( adv_programmer)的工资
	2 要求利用抽象类统一界面,方便程序的扩展, 比如:新增, 计算 架构师 (architect ) 的工资
*/

class programmer
{
public:
	virtual void getSal() = 0;

};

//初级
class junior_programmer : public programmer
{
public:
	junior_programmer(char *name, char *job, int sal)
	{
		this->name = name;
		this->job = job;
		this->sal = sal;
	}
	virtual void getSal()
	{
		cout << "name: " << name << " job:" << job << " sal:" << sal << endl;
	}
private:
	int sal;
	char *name;
	char *job;
};


// 中级
class mid_programmer : public programmer
{
public:
	mid_programmer(char *name, char *job, int sal)
	{
		this->name = name;
		this->job = job;
		this->sal = sal;
	}
	virtual void getSal()
	{
		cout << "name: " << name << " job:" << job << " sal:" << sal << endl;
	}
private:
	int sal;
	char *name;
	char *job;
};

// 高级 
class adv_programmer : public programmer
{
public:
	adv_programmer(char *name, char *job, int sal)
	{
		this->name = name;
		this->job = job;
		this->sal = sal;
	}
	virtual void getSal()
	{
		cout << "name: " << name << " job:" << job << " sal:" << sal << endl;
	}
private:
	int sal;
	char *name;
	char *job;
};

//后来增加的代码
class architect : public programmer
{
public:
	architect(char *name, char *job, int sal)
	{
		this->name = name;
		this->job = job;
		this->sal = sal;
	}
	virtual void getSal()
	{
		cout << "name: " << name << " job:" << job << " sal:" << sal << endl;
	}
private:
	int sal;
	char *name;
	char *job;
};


void  Prog_Cal_Sal(programmer *base)
{
	base->getSal();
}

void main()
{
	junior_programmer	jp("小王", "初级job", 4000 );
	mid_programmer		mp("小李" , "中级job", 8500);
	adv_programmer		ap("小赵", "高级job", 15000);

	architect		arch("itcast架构师", "高高级", 25000);

	Prog_Cal_Sal(&jp);
	Prog_Cal_Sal(&mp);
	Prog_Cal_Sal(&ap);
	Prog_Cal_Sal(&arch);


	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

信息系统框架集成第三方产品

CCiscoImp.h

#pragma once

#include "CEncDesProtocol.h"

class CCiscoImp : public CEncDesProtocol
{
public:
	virtual int EncData(unsigned char *in, int inlen, unsigned char *out, int *outlen);
	virtual int DecData(unsigned char *in, int inlen, unsigned char *out, int *outlen);
};

CCiscoImp.cpp


#include "CEncDesProtocol.h"
#include "CCiscoImp.h"

#include "des.h"

int CCiscoImp::EncData(unsigned char *in, int inlen, unsigned char *out, int *outlen)
{
	int ret = 0;
	ret = DesEnc(in, inlen, out, outlen);

	return ret;
}
int CCiscoImp::DecData(unsigned char *in, int inlen, unsigned char *out, int *outlen)
{
	return DesDec(in, inlen, out, outlen);
}

CEncDesProtocol.h

#pragma  once

class CEncDesProtocol
{
public:
	CEncDesProtocol()
	{

	}
	virtual ~CEncDesProtocol()
	{
		
	}
public:
	virtual int EncData(unsigned char *in, int inlen, unsigned char *out, int *outlen) = 0;
	virtual int DecData(unsigned char *in, int inlen, unsigned char *out, int *outlen) = 0;
};

CHwImp.h

#pragma once

#include "CEncDesProtocol.h"

class CHwImp : public CEncDesProtocol
{
public:
	virtual int EncData(unsigned char *in, int inlen, unsigned char *out, int *outlen);
	virtual int DecData(unsigned char *in, int inlen, unsigned char *out, int *outlen);
};

CHwImp.cpp


#include "CEncDesProtocol.h"
#include "CHwImp.h"

#include "des.h"

int CHwImp::EncData(unsigned char *in, int inlen, unsigned char *out, int *outlen)
{
	int ret = 0;
	ret = DesEnc(in, inlen, out, outlen);

	return ret;
}
int CHwImp::DecData(unsigned char *in, int inlen, unsigned char *out, int *outlen)
{
	return DesDec(in, inlen, out, outlen);
}

CSckFactoryImp1.h



#pragma  once
#include "CSocketProtocol.h"

class CSckFactoryImp1 : public CSocketProtocol
{
public:
	CSckFactoryImp1();

	//客户端环境初始化
	virtual int clientsocket_init();

	//客户端 数据的发送
	virtual int clientsocket_send(unsigned char *p/*in*/ , int len);

	//客户端 数据的接受

	virtual  int clientsocket_recv(unsigned char *p/*in*/, int *len);

	//客户端环境释放
	virtual  int client_destroy();
private:
	unsigned char *m_p ;
	int m_len;

};

CSckFactoryImp1.cpp


#include <iostream>
using namespace std;

#include "CSckFactoryImp1.h"


CSckFactoryImp1::CSckFactoryImp1()
{
	m_len = 0;
	m_p = NULL;
}
//客户端环境初始化
int CSckFactoryImp1::clientsocket_init()
{
	m_len = 0;
	m_p = NULL;
	return 0;
}

//客户端 数据的发送
int CSckFactoryImp1::clientsocket_send(unsigned char *p , int len)
{
	//把发送的数据 缓存 在内存中 
	if (p == NULL || len < 0)
	{
		return -1;
	}
	m_len = len;
	m_p = new  unsigned char[m_len] ;
	memcpy(m_p, p, m_len);
	return 0;
}

//客户端 数据的接受

int CSckFactoryImp1::clientsocket_recv(unsigned char *p, int *len)
{
	if (p == NULL || len == NULL)
	{
		return -1;
	}
	memcpy(p, m_p, m_len); //把缓存的数据 copy 出去
	*len = m_len;

	//释放内存
	delete [] m_p;
	m_len = 0;
	m_p = NULL;

	return 0;
}

//客户端环境释放
int CSckFactoryImp1::client_destroy()
{
	//释放内存
	if (m_p != NULL)
	{
		delete [] m_p;
		m_len = 0;
		m_p = NULL;
	}
	return 0;
}

CSocketFactoryImp2.h



#pragma  once
#include "CSocketProtocol.h"

class CSocketFactoryImp2 : public CSocketProtocol
{
public:
	CSocketFactoryImp2();

	//客户端环境初始化
	virtual int clientsocket_init();

	//客户端 数据的发送
	virtual int clientsocket_send(unsigned char *p/*in*/ , int len);

	//客户端 数据的接受

	virtual  int clientsocket_recv(unsigned char *p/*in*/, int *len);

	//客户端环境释放
	virtual  int client_destroy();
private:
	unsigned char *m_p ;
	int m_len;

};

CSocketFactoryImp2.cpp


#include <iostream>
using namespace std;

#include "CSocketFactoryImp2.h"


CSocketFactoryImp2::CSocketFactoryImp2()
{
	m_len = 0;
	m_p = NULL;
}
//客户端环境初始化
int CSocketFactoryImp2::clientsocket_init()
{
	m_len = 0;
	m_p = NULL;
	return 0;
}

//客户端 数据的发送
int CSocketFactoryImp2::clientsocket_send(unsigned char *p , int len)
{
	//把发送的数据 缓存 在内存中 
	if (p == NULL || len < 0)
	{
		return -1;
	}
	m_len = len;
	m_p = new  unsigned char[m_len] ;
	memcpy(m_p, p, m_len);
	return 0;
}

//客户端 数据的接受

int CSocketFactoryImp2::clientsocket_recv(unsigned char *p, int *len)
{
	if (p == NULL || len == NULL)
	{
		return -1;
	}
	memcpy(p, m_p, m_len); //把缓存的数据 copy 出去
	*len = m_len;

	//释放内存
	delete [] m_p;
	m_len = 0;
	m_p = NULL;

	return 0;
}

//客户端环境释放
int CSocketFactoryImp2::client_destroy()
{
	//释放内存
	if (m_p != NULL)
	{
		delete [] m_p;
		m_len = 0;
		m_p = NULL;
	}
	return 0;
}

CSocketProtocol.h



#pragma once


class CSocketProtocol
{
public:
	CSocketProtocol()  //内联函数
	{
		;
	}
	virtual ~CSocketProtocol()
	{
		;
	}


	//客户端环境初始化
	virtual int clientsocket_init() = 0;

	//客户端 数据的发送
	virtual int clientsocket_send(unsigned char *p , int len) = 0;

	//客户端 数据的接受

	virtual  int clientsocket_recv(unsigned char *p, int *len) = 0;

	//客户端环境释放
	virtual  int client_destroy() = 0;

};

des.h

/*********************************************************
 *  des.h
 *  用户使用des算法头文件
 *	
 *********************************************************/
#ifndef _OPENDESS_H_
#define _OPENDESS_H_

#ifdef __cplusplus
extern "C" {
#endif

//ab\0defg

//用户使用的函数
int DesEnc(
		unsigned char *pInData,
		int            nInDataLen,
		unsigned char *pOutData,
		int           *pOutDataLen);

//用户使用函数des解密
int DesDec(
	   unsigned char *pInData,
	   int            nInDataLen,
	   unsigned char *pOutData,
	   int           *pOutDataLen);

#ifdef __cplusplus
}
#endif

#endif



des.cpp

/******************************************************
 *
 *  des.c
 *  common des......
 *
 ******************************************************/

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include "des.h"

/*********************************************************
  data type definition for Des;
**********************************************************/
#define EN0	0
#define DE1	1

#define DES_KEYBYTES	128
#define DES_KEYLONGS	32
#define DES_BLOCKLEN	8

typedef struct {
	unsigned char ek[DES_KEYBYTES];
	int	ekLen;
	unsigned char dk[DES_KEYBYTES];
	int	dkLen;
	unsigned char CbcCtx[DES_BLOCKLEN];
} DES_CTX;

typedef struct {
	unsigned char ek1[DES_KEYBYTES];
	int	ek1Len;
	unsigned char dk1[DES_KEYBYTES];
	int	dk1Len;
	unsigned char ek2[DES_KEYBYTES];
	int	ek2Len;
	unsigned char dk2[DES_KEYBYTES];
	int	dk2Len;
	unsigned char CbcCtx[DES_BLOCKLEN];
	//int	IsFirstBlock;
} DES3_CTX;


static unsigned char pc1[56] = {
	56, 48, 40, 32, 24, 16,  8,  0, 57, 49, 41, 33, 25, 17,
	 9,  1, 58, 50, 42, 34, 26, 18, 10,  2, 59, 51, 43, 35,
	62, 54, 46, 38, 30, 22, 14,  6, 61, 53, 45, 37, 29, 21,
	13,  5, 60, 52, 44, 36, 28, 20, 12,  4, 27, 19, 11,  3 };

static unsigned char pc2[48] = {
	13, 16, 10, 23,  0,  4,		 2, 27, 14,  5, 20,  9,
	22, 18, 11,  3, 25,  7, 	15,  6, 26, 19, 12,  1,
	40, 51, 30, 36, 46, 54,		29, 39, 50, 44, 32, 47,
	43, 48, 38, 55, 33, 52, 	45, 41, 49, 35, 28, 31 };

static unsigned short bytebit[8] = {0200,0100,040,020,010,04,02,01 };
static unsigned char totrot[16] = {1,2,4,6,8,10,12,14,15,17,19,21,23,25,27,28};
static unsigned long bigbyte[24] = {
	0x800000L,	0x400000L,	0x200000L,	0x100000L,
	0x80000L,	0x40000L,	0x20000L,	0x10000L,
	0x8000L,	0x4000L,	0x2000L,	0x1000L,
	0x800L,		0x400L,		0x200L,		0x100L,
	0x80L,		0x40L,		0x20L,		0x10L,
	0x8L,		0x4L,		0x2L,		0x1L	};

//insert digits
static unsigned long SP1[64] ={
       0x01010400l,0x00000000l,0x00010000l,0x01010404l,
       0x01010004l,0x00010404l,0x00000004l,0x00010000l,
       0x00000400l,0x01010400l,0x01010404l,0x00000400l,
       0x01000404l,0x01010004l,0x01000000l,0x00000004l,
       0x00000404l,0x01000400l,0x01000400l,0x00010400l,
       0x00010400l,0x01010000l,0x01010000l,0x01000404l,
       0x00010004l,0x01000004l,0x01000004l,0x00010004l,
       0x00000000l,0x00000404l,0x00010404l,0x01000000l,
       0x00010000l,0x01010404l,0x00000004l,0x01010000l,
       0x01010400l,0x01000000l,0x01000000l,0x00000400l,
       0x01010004l,0x00010000l,0x00010400l,0x01000004l,
       0x00000400l,0x00000004l,0x01000404l,0x00010404l,
       0x01010404l,0x00010004l,0x01010000l,0x01000404l,
       0x01000004l,0x00000404l,0x00010404l,0x01010400l,
       0x00000404l,0x01000400l,0x01000400l,0x00000000l,
       0x00010004l,0x00010400l,0x00000000l,0x01010004l };
       
       
static unsigned long SP2[64]={
       0x80108020l,0x80008000l,0x00008000l,0x00108020l,
       0x00100000l,0x00000020l,0x80100020l,0x80008020l,
       0x80000020l,0x80108020l,0x80108000l,0x80000000l,
       0x80008000l,0x00100000l,0x00000020l,0x80100020l,
       0x00108000l,0x00100020l,0x80008020l,0x00000000l,
       0x80000000l,0x00008000l,0x00108020l,0x80100000l,
       0x00100020l,0x80000020l,0x00000000l,0x00108000l,
       0x00008020l,0x80108000l,0x80100000l,0x00008020l,
       0x00000000l,0x00108020l,0x80100020l,0x00100000l,
       0x80008020l,0x80100000l,0x80108000l,0x00008000l,
       0x80100000l,0x80008000l,0x00000020l,0x80108020l,
       0x00108020l,0x00000020l,0x00008000l,0x80000000l,
       0x00008020l,0x80108000l,0x00100000l,0x80000020l,
       0x00100020l,0x80008020l,0x80000020l,0x00100020l,
       0x00108000l,0x00000000l,0x80008000l,0x00008020l,
       0x80000000l,0x80100020l,0x80108020l,0x00108000l };
       
       
static unsigned long SP3[64]={ 
       0x00000208l,0x08020200l,0x00000000l,0x08020008l,
       0x08000200l,0x00000000l,0x00020208l,0x08000200l,
       0x00020008l,0x08000008l,0x08000008l,0x00020000l,
       0x08020208l,0x00020008l,0x08020000l,0x00000208l,
       0x08000000l,0x00000008l,0x08020200l,0x00000200l,
       0x00020200l,0x08020000l,0x08020008l,0x00020208l,
       0x08000208l,0x00020200l,0x00020000l,0x08000208l,
       0x00000008l,0x08020208l,0x00000200l,0x08000000l,
       0x08020200l,0x08000000l,0x00020008l,0x00000208l,
       0x00020000l,0x08020200l,0x08000200l,0x00000000l,
       0x00000200l,0x00020008l,0x08020208l,0x08000200l,
       0x08000008l,0x00000200l,0x00000000l,0x08020008l,
       0x08000208l,0x00020000l,0x08000000l,0x08020208l,
       0x00000008l,0x00020208l,0x00020200l,0x08000008l,
       0x08020000l,0x08000208l,0x00000208l,0x08020000l,
       0x00020208l,0x00000008l,0x08020008l,0x00020200l };
       
       
static unsigned long SP4[64]={             
       0x00802001l,0x00002081l,0x00002081l,0x00000080l,
       0x00802080l,0x00800081l,0x00800001l,0x00002001l,
       0x00000000l,0x00802000l,0x00802000l,0x00802081l,
       0x00000081l,0x00000000l,0x00800080l,0x00800001l,
       0x00000001l,0x00002000l,0x00800000l,0x00802001l,
       0x00000080l,0x00800000l,0x00002001l,0x00002080l,
       0x00800081l,0x00000001l,0x00002080l,0x00800080l,
       0x00002000l,0x00802080l,0x00802081l,0x00000081l,
       0x00800080l,0x00800001l,0x00802000l,0x00802081l,
       0x00000081l,0x00000000l,0x00000000l,0x00802000l,
       0x00002080l,0x00800080l,0x00800081l,0x00000001l,
       0x00802001l,0x00002081l,0x00002081l,0x00000080l,
       0x00802081l,0x00000081l,0x00000001l,0x00002000l,
       0x00800001l,0x00002001l,0x00802080l,0x00800081l,
       0x00002001l,0x00002080l,0x00800000l,0x00802001l,
       0x00000080l,0x00800000l,0x00002000l,0x00802080l };
       
       
static unsigned long SP5[64]={   
       0x00000100l,0x02080100l,0x02080000l,0x42000100l,
       0x00080000l,0x00000100l,0x40000000l,0x02080000l,
       0x40080100l,0x00080000l,0x02000100l,0x40080100l,
       0x42000100l,0x42080000l,0x00080100l,0x40000000l,
       0x02000000l,0x40080000l,0x40080000l,0x00000000l,
       0x40000100l,0x42080100l,0x42080100l,0x02000100l,
       0x42080000l,0x40000100l,0x00000000l,0x42000000l,
       0x02080100l,0x02000000l,0x42000000l,0x00080100l,
       0x00080000l,0x42000100l,0x00000100l,0x02000000l,
       0x40000000l,0x02080000l,0x42000100l,0x40080100l,
       0x02000100l,0x40000000l,0x42080000l,0x02080100l,
       0x40080100l,0x00000100l,0x20000000l,0x42080000l,
       0x42080100l,0x00080100l,0x42000000l,0x42080100l,
       0x02080000l,0x02000100l,0x40000100l,0x00080000l,
       0x00080100l,0x02000100l,0x40000100l,0x00080000l,
       0x00000000l,0x40080000l,0x02080100l,0x40000100l };
       
       
static unsigned long SP6[64]={ 
       0x20000010l,0x20400000l,0x00004000l,0x20404010l,
       0x20400000l,0x00000010l,0x20404010l,0x00400000l,
       0x20004000l,0x00404010l,0x00400000l,0x20000010l,
       0x00400010l,0x20004000l,0x20000000l,0x00004010l,
       0x00000000l,0x00400010l,0x20004010l,0x00004000l,
       0x00404000l,0x20004010l,0x00000010l,0x20400010l,
       0x20400010l,0x00000000l,0x00404010l,0x20404000l,
       0x00004010l,0x00404000l,0x20404000l,0x20000000l,
       0x20004000l,0x00000010l,0x20400010l,0x00404000l,
       0x20404010l,0x00400000l,0x00004010l,0x20000010l,
       0x00400000l,0x20004000l,0x20000000l,0x00004010l,
       0x20000010l,0x20404010l,0x00404000l,0x20400000l,
       0x00404010l,0x20404000l,0x00000000l,0x20400010l,
       0x00000010l,0x00004000l,0x20400000l,0x00404010l,
       0x00004000l,0x00400010l,0x20004010l,0x00000000l,
       0x20404000l,0x20000000l,0x00400010l,0x20004010l };  
            
static unsigned long SP7[64] = {
	0x00200000L, 0x04200002L, 0x04000802L, 0x00000000L,
	0x00000800L, 0x04000802L, 0x00200802L, 0x04200800L,
	0x04200802L, 0x00200000L, 0x00000000L, 0x04000002L,
	0x00000002L, 0x04000000L, 0x04200002L, 0x00000802L,
	0x04000800L, 0x00200802L, 0x00200002L, 0x04000800L,
	0x04000002L, 0x04200000L, 0x04200800L, 0x00200002L,
	0x04200000L, 0x00000800L, 0x00000802L, 0x04200802L,
	0x00200800L, 0x00000002L, 0x04000000L, 0x00200800L,
	0x04000000L, 0x00200800L, 0x00200000L, 0x04000802L,
	0x04000802L, 0x04200002L, 0x04200002L, 0x00000002L,
	0x00200002L, 0x04000000L, 0x04000800L, 0x00200000L,
	0x04200800L, 0x00000802L, 0x00200802L, 0x04200800L,
	0x00000802L, 0x04000002L, 0x04200802L, 0x04200000L,
	0x00200800L, 0x00000000L, 0x00000002L, 0x04200802L,
	0x00000000L, 0x00200802L, 0x04200000L, 0x00000800L,
	0x04000002L, 0x04000800L, 0x00000800L, 0x00200002L };
	
static unsigned long SP8[64] = {
	0x10001040L, 0x00001000L, 0x00040000L, 0x10041040L,
	0x10000000L, 0x10001040L, 0x00000040L, 0x10000000L,
	0x00040040L, 0x10040000L, 0x10041040L, 0x00041000L,
	0x10041000L, 0x00041040L, 0x00001000L, 0x00000040L,
	0x10040000L, 0x10000040L, 0x10001000L, 0x00001040L,
	0x00041000L, 0x00040040L, 0x10040040L, 0x10041000L,
	0x00001040L, 0x00000000L, 0x00000000L, 0x10040040L,
	0x10000040L, 0x10001000L, 0x00041040L, 0x00040000L,
	0x00041040L, 0x00040000L, 0x10041000L, 0x00001000L,
	0x00000040L, 0x10040040L, 0x00001000L, 0x00041040L,
	0x10001000L, 0x00000040L, 0x10000040L, 0x10040000L,
	0x10040040L, 0x10000000L, 0x00040000L, 0x10001040L,
	0x00000000L, 0x10041040L, 0x00040040L, 0x10000040L,
	0x10040000L, 0x10001000L, 0x10001040L, 0x00000000L,
	0x10041040L, 0x00041000L, 0x00041000L, 0x00001040L,
	0x00001040L, 0x00040040L, 0x10000000L, 0x10041000L };

void deskey(unsigned char *key,short edf, unsigned long *kn);
void cookey(register unsigned long *raw1, unsigned long *dough);
//void cpkey(register unsigned long *into);
//void usekey(register unsigned long *from);
//void des(unsigned char *inblock,unsigned char *outblock);
void scrunch(register unsigned char *outof, register unsigned long *into);
void unscrun(register unsigned long *outof, register unsigned char *into);
void desfunc(register unsigned long *block,register unsigned long *keys);

/*****************  DES Function  *****************/
unsigned long OPENCOMM_DesExpandEncKey(
		unsigned char *pbDesKey,
		unsigned long  ulDesKeyLen,
		unsigned char *pbDesEncKey,
		unsigned long *ulDesEncKeyLen);

unsigned long OPENCOMM_DesExpandDecKey(
		unsigned char *pbDesKey,
		unsigned long  ulDesKeyLen,
		unsigned char *pbDesDecKey,
		unsigned long *ulDesDecKeyLen);

unsigned long OPENCOMM_DesEncRaw(
		unsigned char *pbDesEncKey,
		unsigned long  ulDesEncKeyLen,
		unsigned char *pbInData,
		unsigned long  ulInDataLen,
		unsigned char *pbOutData,
		unsigned long *ulOutDataLen);

unsigned long OPENCOMM_DesDecRaw(
		unsigned char *pbDesDecKey,
		unsigned long  ulDesDecKeyLen,
		unsigned char *pbInData,
		unsigned long  ulInDataLen,
		unsigned char *pbOutData,
		unsigned long *ulOutDataLen);


int myic_DESDecrypt(
		unsigned char *pDesKey,
		int            nDesKeyLen,
		unsigned char *pInData,
		int            nInDataLen,
		unsigned char *pOutData,
		int           *pOutDataLen);

int myic_DESEncrypt(
		unsigned char *pDesKey,
		int            nDesKeyLen,
		unsigned char *pInData,
		int            nInDataLen,
		unsigned char *pOutData,
		int           *pOutDataLen);


void deskey(unsigned char *key,short edf, unsigned long *kn)
{
	register int i, j, l, m, n;
	unsigned long pc1m[56],pcr[56];
	
	
	for ( j = 0; j < 56; j++ ) 
	{
		l = pc1[j];
		m = l & 07;
		pc1m[j] = (((unsigned long) key[l >> 3] & (unsigned long)bytebit[m] ) ? 1:0);
	}
	for ( i = 0;i < 16; i++)
	{
		if ( edf == DE1 )	m = (15 - i) << 1;
		else	m = i << 1;
		n = m + 1;
		kn[m] = kn[n] = 0L;
		for ( j = 0; j < 28; j++ )
		{
			l = j + totrot[i];
			if ( l < 28 )	pcr[j] = pc1m[l];
			else	pcr[j] = pc1m[l-28];
		}
		for (j = 28; j < 56; j++ ) 
		{
			l = j + totrot[i];
			if ( l < 56 )	pcr[j] = pc1m[l];
			else	pcr[j] = pc1m[l-28];
		} 
		for ( j = 0; j < 24; j++ ) 
		{
			if ( pcr[pc2[j]] )	kn[m] |= bigbyte[j];
			if ( pcr[pc2[j+24]] )	kn[n] |= bigbyte[j];
		}
	}
	return;
}

void cookey(register unsigned long *raw1, unsigned long *dough)
{
	register unsigned long *cook,*raw0;
	register int i;
	
	cook = dough;
	for ( i = 0; i < 16; i++, raw1++ ) {
		raw0 = raw1++;
		*cook	 = (*raw0 & 0x00fc0000L) << 6;
		*cook	|= (*raw0 & 0x00000fc0L) << 10;
		*cook	|= (*raw1 & 0x00fc0000L) >> 10;
		*cook++	|= (*raw1 & 0x00000fc0L) >> 6;
		*cook	 = (*raw0 & 0x0003f000L) << 12;
		*cook	|= (*raw0 & 0x0000003fL) << 16;
		*cook	|= (*raw1 & 0x0003f000L) >> 4;
		*cook++	|= (*raw1 & 0x0000003fL);
	}
	return;
}

void scrunch(register unsigned char *outof, register unsigned long *into)
{
	*into	 = (*outof++ & 0xffL) << 24;
	*into	|= (*outof++ & 0xffL) << 16;
	*into	|= (*outof++ & 0xffL) << 8;
	*into++	|= (*outof++ & 0xffL);
	*into	 = (*outof++ & 0xffL) << 24;
	*into	|= (*outof++ & 0xffL) << 16;
	*into	|= (*outof++ & 0xffL) << 8;
	*into++	|= (*outof   & 0xffL);
	return;
}

void unscrun(register unsigned long *outof, register unsigned char *into)
{
	*into++	 = (unsigned char)((*outof >> 24) & 0xffL);
	*into++	 = (unsigned char)((*outof >> 16) & 0xffL);
	*into++	 = (unsigned char)((*outof >>  8) & 0xffL);
	*into++	 = (unsigned char)( *outof++	  & 0xffL);
	*into++	 = (unsigned char)((*outof >> 24) & 0xffL);
	*into++	 = (unsigned char)((*outof >> 16) & 0xffL);
	*into++	 = (unsigned char)((*outof >>  8) & 0xffL);
	*into	 = (unsigned char)( *outof		  & 0xffL);
	return;
}

void desfunc(register unsigned long *block,register unsigned long *keys)
{
	register unsigned long fval, work, right, leftt;
	register int round;
	
	leftt = block[0];
	right = block[1];
	work = ((leftt >> 4) ^ right) & 0x0f0f0f0fL;
	
	right ^= work;
	leftt ^= (work << 4);
	work = ((leftt >> 16) ^ right) & 0x0000ffffL;
	
	right ^= work;
	leftt ^= (work << 16);
	work = ((right >> 2) ^ leftt) & 0x33333333L;
	
	leftt ^= work;
	right ^= (work << 2);
	work = ((right >> 8) ^ leftt) & 0x00ff00ffL;
	
	leftt ^= work;
	right ^= (work << 8);
	right = ((right << 1) | ((right >>31) & 1L)) & 0xffffffffL;
	work = (leftt ^ right) & 0xaaaaaaaaL;
	
	leftt ^= work;
	right ^= work;
	leftt = ((leftt << 1) | ((leftt >> 31)&1L)) & 0xffffffffL;
	
	for (round = 0; round < 8; round++) {
		work  = (right << 28) | (right >> 4);
		work ^= *keys++;
		fval  = SP7[ work	& 0x3fL];
		fval |= SP5[(work >>  8) & 0x3fL];
		fval |= SP3[(work >> 16) & 0x3fL];
		fval |= SP1[(work >> 24) & 0x3fL];
		work  = right ^ *keys++;
		fval |= SP8[ work 	& 0x3fL];
		fval |= SP6[(work >>  8) & 0x3fL];
		fval |= SP4[(work >> 16) & 0x3fL];
		fval |= SP2[(work >> 24) & 0x3fL];
		leftt ^= fval;
		work  = (leftt << 28) | (leftt >> 4);
		work ^= *keys++;
		fval  = SP7[ work 	& 0x3fL];
		fval |= SP5[(work >>  8) & 0x3fL];
		fval |= SP3[(work >> 16) & 0x3fL];
		fval |= SP1[(work >> 24) & 0x3fL];
		work  = leftt ^ *keys++;
		fval |= SP8[ work 	& 0x3fL];
		fval |= SP6[(work >>  8) & 0x3fL];
		fval |= SP4[(work >> 16) & 0x3fL];
		fval |= SP2[(work >> 24) & 0x3fL];
		right ^= fval;
	}
	
	right = (right << 31) | (right >> 1);
	work = (leftt ^ right) & 0xaaaaaaaaL;
	leftt ^= work;
	right ^= work;
	leftt = (leftt << 31) | (leftt >> 1);
	work = ((leftt >>  8) ^ right) & 0x00ff00ffL;
	right ^= work;
	leftt ^= (work << 8);
	work = ((leftt >>  2) ^ right) & 0x33333333L;
	right ^= work;
	leftt ^= (work << 2);
	work = ((right >> 16) ^ leftt) & 0x0000ffffL;
	leftt ^= work;
	right ^= (work << 16);
	work = ((right >>  4) ^ leftt) & 0x0f0f0f0fL;
	leftt ^= work;
	right ^= (work << 4);
	*block++ = right;
	*block = leftt;
	return;
}

/*****************************************************************
	OPENCOMM_DesExpandEncKey	: Expand Des Enc Key 扩展des加密密钥
	Return value:
		0         : Success
		other     : failed
	Parameters:
		pbDesKey        : 扩展前的DES密钥(8字节)       input
		ulDesKeyLen     : 扩展前的DES密钥长度          input
		pbDesEncKey     : 扩展后的DES加密密钥(128字节)  output
		*ulDesEncKeyLen : 扩展后的DES加密密钥长度       output
*****************************************************************/
unsigned long OPENCOMM_DesExpandEncKey(
		unsigned char *pbDesKey,
		unsigned long  ulDesKeyLen,
		unsigned char *pbDesEncKey,
		unsigned long *ulDesEncKeyLen)
{
	unsigned long kn[32], dough[32];
	
	if (ulDesKeyLen != 8)
		return 0xEE20;

	deskey(pbDesKey, EN0, kn);
	cookey(kn, dough);
	*ulDesEncKeyLen = DES_KEYBYTES;  //32 long = 128 bytes
	memcpy(pbDesEncKey, dough, *ulDesEncKeyLen);
	
	return 0;
}

/*****************************************************************
	OPENCOMM_DesExpandDecKey	: Expand Des Dec Key 扩展des解密密钥
	Return value:
		0       : Success
		other   : failed
	Parameters:
		pbDesKey        : 扩展前的DES密钥(8字节)      input
		ulDesKeyLen     : 扩展前的DES密钥长度         input
		pbDesDecKey     : 扩展后的DES解密密钥(128字节) output
		*ulDesDecKeyLen : 扩展后的DES解密密钥长度      output
*****************************************************************/
unsigned long OPENCOMM_DesExpandDecKey(
		unsigned char *pbDesKey,
		unsigned long  ulDesKeyLen,
		unsigned char *pbDesDecKey,
		unsigned long *ulDesDecKeyLen)
{
	unsigned long kn[32], dough[32];
	
	if (ulDesKeyLen != 8)
		return 0xEE20;

	deskey(pbDesKey, DE1, kn);
	cookey(kn, dough);
	*ulDesDecKeyLen = DES_KEYBYTES;  //32 long = 128 bytes
	memcpy(pbDesDecKey, dough, *ulDesDecKeyLen);
	
	return 0;
}

/****************************************************************
	OPENCOMM_DesEncRaw		: Des算法加密小整块明文8字节 
	Return value:
		0       : Success
		other   : failed
	Parameters:
		pbDesEncKey    : DES加密密钥    input
		ulDesEncKeyLen : DES加密密钥长度 input
		pbInData       : 待加密的明文    input
		ulInDataLen    : 待加密的明文长度 input
		pbOutData      : 加密后的密文    output
		*ulOutDataLen  : 加密后的密文长度 output
*****************************************************************/
unsigned long OPENCOMM_DesEncRaw(
		unsigned char *pbDesEncKey,
		unsigned long  ulDesEncKeyLen,
		unsigned char *pbInData,
		unsigned long  ulInDataLen,
		unsigned char *pbOutData,
		unsigned long *ulOutDataLen)
{
	unsigned long work[2], ek[DES_KEYLONGS];
	unsigned char cp[DES_BLOCKLEN];

	if (ulInDataLen != DES_BLOCKLEN)
		return 0xEE20;
	
	if (ulDesEncKeyLen != DES_KEYBYTES)
		return 0xEE20;

	memcpy(cp, pbInData, DES_BLOCKLEN);
	scrunch(cp,work);  // 8 bytes -> 2 long
	memcpy(ek, pbDesEncKey, ulDesEncKeyLen);
	desfunc(work,ek);
	unscrun(work,cp); // 2 long -> 8 bytes
	memcpy(pbOutData, cp, DES_BLOCKLEN);
	*ulOutDataLen = DES_BLOCKLEN;

	return 0;
}

/*****************************************************************
	OPENCOMM_DesDecRaw : Des算法解密小整块密文8字节 
	Return value:
		0     : Success
		other : failed
	Parameters:
		pbDesDecKey    : DES解密密钥     input
		ulDesDecKeyLen : DES解密密钥长度  input
		pbInData       : 待解密的密文     input
		ulInDataLen    : 待解密的密文长度  input
		pbOutData      : 解密后的明文     output
		*ulOutDataLen  : 解密后的明文长度  output
*****************************************************************/
unsigned long OPENCOMM_DesDecRaw(
		unsigned char *pbDesDecKey,
		unsigned long  ulDesDecKeyLen,
		unsigned char *pbInData,
		unsigned long  ulInDataLen,
		unsigned char *pbOutData,
		unsigned long *ulOutDataLen)
{
	unsigned long work[2], dk[DES_KEYLONGS];
	unsigned char cp[DES_BLOCKLEN];

	if (ulInDataLen != DES_BLOCKLEN)
		return 0xEE20;
	
	if (ulDesDecKeyLen != DES_KEYBYTES)
		return 0xEE20;

	memcpy(cp, pbInData, DES_BLOCKLEN);
	scrunch(cp,work);  // 8 bytes -> 2 long
	memcpy(dk, pbDesDecKey, ulDesDecKeyLen);
	desfunc(work,dk);
	unscrun(work,cp); // 2 long -> 8 bytes
	memcpy(pbOutData, cp, DES_BLOCKLEN);
//	des_enc(pbDesEncKey, pbInData, pbOutData);
	*ulOutDataLen = DES_BLOCKLEN;

	return 0;
}

/*********************   DES    *********************/

int myic_DESEncrypt(
		unsigned char *pDesKey,
		int            nDesKeyLen,
		unsigned char *pInData,
		int            nInDataLen,
		unsigned char *pOutData,
		int           *pOutDataLen)
{
	unsigned char DesKeyBuf[32];
	unsigned char DesEncKeyBuf[128];
	int EncKeyLen, KeyLen = 0;
	int retval = 0, loops, i;
	
	if(nInDataLen%8 != 0)
		return 0xEE20;
	
	if(nDesKeyLen != 8)
		return 0xEE20;
	KeyLen = nDesKeyLen;
	memcpy(DesKeyBuf, pDesKey, nDesKeyLen);

	
	retval = OPENCOMM_DesExpandEncKey(DesKeyBuf, KeyLen,
		DesEncKeyBuf, (unsigned long *)&EncKeyLen);
	if(retval != 0)
		return retval;

	loops = nInDataLen/8;
	for(i = 0; i < loops; i++)
	{
		retval = OPENCOMM_DesEncRaw(DesEncKeyBuf, EncKeyLen, pInData + i*8,
			8, pOutData + i*8, (unsigned long *)pOutDataLen);
		if(retval != 0)
			return retval;
	}
	*pOutDataLen = nInDataLen;
	return retval;
}


int myic_DESDecrypt(
		unsigned char *pDesKey,
		int            nDesKeyLen,
		unsigned char *pInData,
		int            nInDataLen,
		unsigned char *pOutData,
		int           *pOutDataLen)
{
	unsigned char DesKeyBuf[32];
	unsigned char DesDecKeyBuf[128];
	int DecKeyLen, KeyLen = 0;
	int retval = 0, loops, i;
	
	if(nInDataLen%8 != 0)
		return 0xEE20;
	
	if(nDesKeyLen != 8)
		return 0xEE20;
	KeyLen = nDesKeyLen;
	memcpy(DesKeyBuf, pDesKey, nDesKeyLen);

	retval = OPENCOMM_DesExpandDecKey(DesKeyBuf, KeyLen,
		DesDecKeyBuf, (unsigned long *)&DecKeyLen);
	if(retval != 0)
		return retval;
	
	loops = nInDataLen/8;
	for(i = 0; i < loops; i++)
	{
		retval = OPENCOMM_DesDecRaw(DesDecKeyBuf, DecKeyLen, pInData + i*8,
			8, pOutData + i*8, (unsigned long *)pOutDataLen);
		if(retval != 0)
			return retval;
	}
	*pOutDataLen = nInDataLen;
	return retval;
}


//对称明文数据打pading
void  CW_dataPadAdd(int tag, unsigned char *date, unsigned int dateLen, 
					unsigned char **padDate, unsigned int *padDateLen)
{
	int           i, padLen;
	unsigned char *pTmp   = NULL;
	
	pTmp = (unsigned char *)malloc(dateLen+24);
	if (pTmp == NULL)
	{
		*padDate = NULL;
		return ;
	}
	memset(pTmp, 0, dateLen+24);
	memcpy(pTmp, date, dateLen);
	
	if (tag == 0)
	{
		padLen = 8 - dateLen % 8;
		for (i=0; i<padLen; i++)
		{
			pTmp[dateLen+i] = (char)padLen;
		}
		*padDateLen = dateLen + padLen;
	}
	else
	{
		padLen = 16 - dateLen % 16;
		for (i=0; i<padLen; i++)
		{
			pTmp[dateLen+i] = (char)padLen;
		}		
	}
	
	*padDateLen = dateLen + padLen;	
	*padDate = pTmp;
}

#define  USER_PASSWORD_KEY "abcd1234"


//数据加密
int DesEnc(
		 unsigned char *pInData,
		 int            nInDataLen,
		 unsigned char *pOutData,
		 int           *pOutDataLen)
{
	int				rv;
	unsigned char	*padDate = NULL;
	unsigned int	padDateLen = 0;

	CW_dataPadAdd(0, pInData, (unsigned int )nInDataLen, &padDate, &padDateLen);

	rv = myic_DESEncrypt((unsigned char *)USER_PASSWORD_KEY, strlen(USER_PASSWORD_KEY),
		padDate, (int)padDateLen, pOutData, pOutDataLen);
	if (rv != 0)
	{
		if (padDate != NULL)
		{
			free(padDate);
		}
		return rv;	
	}

	if (padDate != NULL)
	{
		free(padDate);
	}
	return 0;
}


//数据加密
int DesEnc_raw(
	unsigned char *pInData,
	int            nInDataLen,
	unsigned char *pOutData,
	int           *pOutDataLen)
{
	int				rv;
	unsigned char	*padDate = NULL;
	unsigned int	padDateLen = 0;

	rv = myic_DESEncrypt((unsigned char *)USER_PASSWORD_KEY, strlen(USER_PASSWORD_KEY),
		pInData, (int)nInDataLen, pOutData, pOutDataLen);
	if (rv != 0)
	{
		return rv;	
	}
	return 0;
}

//解密分配内存错误
#define  ERR_MALLOC 20
//密码长度不是8的整数倍, 不合法
#define  ERR_FILECONT 20


//用户使用函数des解密
int DesDec(
		   unsigned char *pInData,
		   int            nInDataLen,
		   unsigned char *pOutData,
		   int           *pOutDataLen)
{
	int				rv;
	char			padChar;
	unsigned char 	*tmpPlain = NULL;
	
	tmpPlain =		(unsigned char *)malloc(nInDataLen+24);
	if (tmpPlain == NULL)
	{
		return ERR_MALLOC;
	}
	memset(tmpPlain, 0, nInDataLen+24);

	//解密
	rv = myic_DESDecrypt((unsigned char *)USER_PASSWORD_KEY, strlen(USER_PASSWORD_KEY),
		pInData, nInDataLen, tmpPlain, pOutDataLen);
	if (rv != 0)
	{
		if (tmpPlain != NULL) free(tmpPlain);
		return rv;
	}

	//去pading
	padChar = tmpPlain[*pOutDataLen - 1];
	if ( (int)padChar<=0 || (int)padChar>8) //异常处理
	{
		if (tmpPlain) free(tmpPlain);
		return ERR_FILECONT;
	}

	*pOutDataLen = *pOutDataLen - (int)padChar;	
	//memset(tmpPlain + *pOutDataLen, 0, (int)padChar);	
	memcpy(pOutData, tmpPlain, *pOutDataLen);
	if (tmpPlain) free(tmpPlain);	
	return 0;
}


//用户使用函数des解密
int DesDec_raw(
	unsigned char *pInData,
	int            nInDataLen,
	unsigned char *pOutData,
	int           *pOutDataLen)
{
	int				rv;
	//char			padChar;
	//unsigned char 	*tmpPlain = NULL;

	/*
	tmpPlain =		(unsigned char *)malloc(nInDataLen+24);
	if (tmpPlain == NULL)
	{
		return ERR_MALLOC;
	}
	memset(tmpPlain, 0, nInDataLen+24);
	*/

	//解密
	rv = myic_DESDecrypt((unsigned char *)USER_PASSWORD_KEY, strlen(USER_PASSWORD_KEY),
		pInData, nInDataLen, pOutData, pOutDataLen);
	if (rv != 0)
	{
		//if (tmpPlain != NULL) free(tmpPlain);
		return rv;
	}
	/*
	//去pading
	padChar = tmpPlain[*pOutDataLen - 1];
	if ( (int)padChar<=0 || (int)padChar>8) //异常处理
	{
		if (tmpPlain) free(tmpPlain);
		return ERR_FILECONT;
	}

	*pOutDataLen = *pOutDataLen - (int)padChar;	
	//memset(tmpPlain + *pOutDataLen, 0, (int)padChar);	
	memcpy(pOutData, tmpPlain, *pOutDataLen);
	if (tmpPlain) free(tmpPlain);	
	*/
	return 0;
}





mainclass.cpp

#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
using namespace std;

#include "CSocketProtocol.h"

#include "CSckFactoryImp1.h"
#include "CSocketFactoryImp2.h"
#include "CEncDesProtocol.h"

#include "CHwImp.h"
#include "CCiscoImp.h"


/*
class MyMainOP : public CSocketProtocol, public CEncDesProtocol
{
public:
protected:
private:
};
*/

class  MyMainOp
{
public:
	void setSp(CSocketProtocol *sp)
	{
		this->sp = sp;
	}
	void setEd(CEncDesProtocol *ed)
	{
		this->ed = ed;
	}

	int myOp(CSocketProtocol *sp, CEncDesProtocol *ed, unsigned char *in, int len, unsigned char *out, int *outlen)
	{
		unsigned char tmpbuf[4096];
		int tmpbuflen = 4096;

		int ret = 0;
		//发生的时候 把明文加密
		ret = ed->EncData(in, len,tmpbuf, &tmpbuflen );

		ret = sp->clientsocket_init();
		//发送密文 
		ret = sp->clientsocket_send(tmpbuf, tmpbuflen);

		//接受密文
		ret = sp->clientsocket_recv(tmpbuf, &tmpbuflen);

		//解密密文
		ret  = ed->DecData(tmpbuf, tmpbuflen, out, outlen);
		return ret;
	}

	int myOp( unsigned char *in, int len, unsigned char *out, int *outlen)
	{
		unsigned char tmpbuf[4096];
		int tmpbuflen = 4096;

		int ret = 0;
		//发生的时候 把明文加密
		ret = this->ed->EncData(in, len,tmpbuf, &tmpbuflen );

		ret = sp->clientsocket_init();
		//发送密文 
		ret = sp->clientsocket_send(tmpbuf, tmpbuflen);

		//接受密文
		ret = sp->clientsocket_recv(tmpbuf, &tmpbuflen);

		//解密密文
		ret  = ed->DecData(tmpbuf, tmpbuflen, out, outlen);
		return ret;
	}

private:
	CSocketProtocol *sp;
	CEncDesProtocol *ed;

};

void main()
{

	int ret = 0;
	unsigned char	buf[128];
	int				len  = 0;
	unsigned char  outbuf[4096] = {0};
	int				outlen = 0;


	CSocketProtocol  *sp = NULL;
	CEncDesProtocol *ed = NULL;

	strcpy((char *)buf, "aaaaaaaaaaaadddddddddddffffffff");
	len = 9;

	sp = new CSocketFactoryImp2;

	//ed = new CHwImp;
	ed = new CCiscoImp;

	MyMainOp *mo = new MyMainOp; //框架升级成类
	ret = mo->myOp(sp, ed, buf,  len, outbuf, &outlen);
	if (memcmp(buf, outbuf, 9) == 0)
	{
		printf("发送和接受内容一样\n");
	}
	else
	{
		printf("发送和接受内容不一样\n");
	}
	delete sp;
	delete ed;
	delete mo;
	system("pause");
}


//框架支持 把socket协议 和 加密协议 都集成
int MainOp(CSocketProtocol *sp, CEncDesProtocol *ed, unsigned char *in, int len, unsigned char *out, int *outlen)
{
	unsigned char tmpbuf[4096];
	int tmpbuflen = 4096;

	int ret = 0;
	//发生的时候 把明文加密
	ret = ed->EncData(in, len,tmpbuf, &tmpbuflen );

	ret = sp->clientsocket_init();
	//发送密文 
	ret = sp->clientsocket_send(tmpbuf, tmpbuflen);

	//接受密文
	ret = sp->clientsocket_recv(tmpbuf, &tmpbuflen);

	//解密密文
	ret  = ed->DecData(tmpbuf, tmpbuflen, out, outlen);
	return ret;

}

void main21()
{
	int ret = 0;
	unsigned char	buf[128];
	int				len  = 0;
	unsigned char  outbuf[4096] = {0};
	int				outlen = 0;


	CSocketProtocol  *sp = NULL;
	CEncDesProtocol *ed = NULL;

	strcpy((char *)buf, "aaaaaaaaaaaadddddddddddffffffff");
	len = 9;

	sp = new CSocketFactoryImp2;

	//ed = new CHwImp;
	ed = new CCiscoImp;


	ret = MainOp(sp, ed, buf,  len, outbuf, &outlen);
	if (memcmp(buf, outbuf, 9) == 0)
	{
		printf("发送和接受内容一样\n");
	}
	else
	{
		printf("发送和接受内容不一样\n");
	}

	delete sp;
	delete ed;
	system("pause");

}





//////////////////////////////////////////////////////////////////////////




//
int MainOp_完成了socket协议(CSocketProtocol *base, unsigned char *in, int len, unsigned char *out, int *outlen)
{

	//面向抽象类编程
	//实现了一套业务模型  一条机制  
	int		ret = 0;

	ret = base->clientsocket_init(); //发生多态
	if (ret != 0)
	{
		printf("func clientsocket_init() err:%d \n", ret);
		//return ret;
		goto End;
	}

	ret = base->clientsocket_send(in, len);
	if (ret != 0)
	{
		printf("func clientsocket_send() err:%d \n", ret);
		goto End;
	}

	ret = base->clientsocket_recv(out, outlen);
	if (ret != 0)
	{
		printf("func clientsocket_recv() err:%d \n", ret);
		goto End;
	}


End:
	ret = base->client_destroy();
	if (ret != 0)
	{
		printf("func client_destroy() err:%d \n", ret);
		return ret;
	}
	return ret;
}


void main11()
{

	unsigned char	buf[128];
	int				len  = 0;
	unsigned char  outbuf[4096] = {0};
	int				outlen = 0;


	strcpy((char *)buf, "aaaaaaaaaaaadddddddddddffffffff");
	len = 9;
	CSocketProtocol *base = new CSocketFactoryImp2; //new CSocketProtoclImp1();
	MainOp_完成了socket协议(base, buf, len, outbuf, &outlen);

	
	if (memcmp(buf, outbuf, 9) == 0)
	{
		printf("发送和接受内容一样\n");
	}
	else
	{
		printf("发送和接受内容不一样\n");
	}

	delete base; //
	
	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

第八章   函数指针语法基础

#define  _CRT_SECURE_NO_WARNINGS 
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

//函数指针 
//声明一个 函数类型 
//声明一个 函数指针类型
//定义一个 函数指针 , 用来指向一个函数的入口地址

//数组指针
//声明一个 数组类型
//声明一个 数组指针类型
//定义一个  数组指针变量, 用来指针一个数组....


void printfA1(char a[10][30] )
{
	int i = 0;
	for (i=0; i<10; i++)
	{
		printf("%s \n", a[i]);
	}
}
void printfA2(char a[][30] ) //char buf[30]
{
	int i = 0;
	for (i=0; i<10; i++)
	{
		printf("%s \n", a[i]);
	}
}

//int (*myArrayVar)[10]; //定义了一个变量 用来指向一个数组 
void printfA3(char (*a)[30] , int num)
{
	int i = 0;
	for (i=0; i<num; i++)
	{
		printf("%s \n", a[i]);
	}
}

void main11()
{
	int a[10]; //用一个类型定义一个数组 
	//数组类型
	{
		typedef int (MyArrayType)[10];

		MyArrayType array; //int a[10];
		array[0] = 1;
		printf("%d \n", array[0]);
	}

	//数组指针类型
	{
		typedef int (*MyPointArrayType)[10]; //

		MyPointArrayType  pointArray;
		pointArray = &a; //因为指向一个数组, 本质 向后跳一个数组大小 单元
		(*pointArray)[0] = 10;
		pointArray ++; //+1 xiang
		printf("a[0]: %d \n", a[0]);

		//int mybuf[10][30]; //mybuf====> 就是一个数组指针 mybuf+1 向后跳30个单元
		//mybuf + 1; (*(*(a+i))+j )
	}

	////定义一个  数组指针变量, 用来指针一个数组....
	{
	
		int (*myArrayVar)[10]; //定义了一个变量 用来指向一个数组 
		myArrayVar = &a;

		(*myArrayVar)[2] = 30;
		printf("a[2]: %d \n", a[2]);

		{
			int b = 10;
			int *p = &b;
		}
		
	}


	//二维数组做函数参数
	{
		char a[10][30] = {"aaaaa", "bbbbbb", "cccccccc"};
		printfA3(a, 3);

	}


	printf("hello...\n");
	system("pause");
	return ;
}

void main12()
{
	int a[10];

	//没有内存 哪来的指针啊 .....
	int (*myPArray)[10] = NULL; //定义了一个指针

	myPArray = &a;
	(*myPArray)[3] = 10;

	system("pause");

}

函数指针

#define  _CRT_SECURE_NO_WARNINGS 
#include <stdlib.h>
#include <string.h>
#include <stdio.h>


//函数指针 
//声明一个 函数类型 
//声明一个 函数指针类型
//定义一个 函数指针 , 用来指向一个函数的入口地址

int myadd(int a, int b)
{
	int c = 0;
	c = a + b;
	return c;
}

void main22()
{
	myadd(1, 2);// 函数名称代表函数的入口地址 就是一个函数指针 myadd 
				// 直接调用
	//声明一个 函数类型 
	{
		typedef int (MyFuncType)(int a, int b); //数据类型, 本质 :固定大小内存块的别名
		MyFuncType  *myFuncVar = NULL;
		myFuncVar = myadd;

		myFuncVar(3, 4); //间接调用

	}


	//声明一个 函数指针类型
	{
		typedef int (*MyPFuncType)(int a, int b); //类型  C编译器不会分配内存

		MyPFuncType  myPFunc = NULL;
		myPFunc = myadd;
		myPFunc = &myadd; //C的版本兼容性 问题 
		myPFunc(5, 6);
	}
	////定义一个 函数指针 , 用来指向一个函数的入口地址

	 int (*MyPFuncType)(int a, int b); //定义了个指针变量 // 分配内存

	 MyPFuncType = myadd;
	 MyPFuncType(10, 20);


	printf("hello...\n");
	system("pause");
	return ;
}

函数指针做函数参数思想剖析

#define  _CRT_SECURE_NO_WARNINGS 
#include <stdlib.h>
#include <string.h>
#include <stdio.h>



//=====> 函数指针做函数参数的思想精华:
// 调用者任务的人  和 实现任务的人  解耦合

int myadd(int a, int b)
{
	int c = 0;
	c = a +b;
	return c;
}

int myadd2(int a, int b)  //子任务 
{
	int c = 0;
	c = a +b;
	printf("func myadd2() do \n");
	return c;
}

int myadd3(int a, int b) //子任务 
{
	int c = 0;
	c = a +b;
	printf("func myadd3() do \n");
	return c;
}

int myadd4(int a, int b) //子任务 
{
	int c = 0;
	c = a +b;
	printf("func myadd4() do \n");
	return c;
}


//我的框架 10:19分  //
// int (*myFuncVar)(int a, int b) 
int myMianOp(  int (*myFuncVar)(int a, int b)   )
{
	myFuncVar(10, 20);  //间接的调用 myadd函数
	return 0;
}
void main()
{
	//函数指针变量 
	//int (*myFuncVar)(int a, int b) ; //定义一个指针变量  指向一个函数类型
	//myFuncVar = myadd;
	//myFuncVar(1, 2);

	myMianOp( myadd) ;	//调用者

	myMianOp( myadd2) ; //调用者

	myMianOp( myadd3) ; //调用者
	myMianOp( myadd4) ; //调用者

	//

	printf("hello...\n");
	system("pause");
	return ;
}

mysocketclientdll第一套API


#define  _CRT_SECURE_NO_WARNINGS 
#include <stdlib.h>
#include <string.h>
#include <stdio.h>


typedef struct _Sck_Handle
{
	char	version[16];
	char	ip[16];
	int		port;
	unsigned char *p;
	int			len;

	char		*p2 ;
}Sck_Handle;

//socket客户端环境初始化
__declspec(dllexport)  //把动态库的环境 给抛出, 让别人使用
int socketclient_init(void **handle)
{
	int			ret = 0;
	Sck_Handle	*tmpHandle = NULL;

	if (handle == NULL)
	{
		ret = -1;
		printf("func socketclient_init() err :%d  check handle == NULL err \n", ret);
		return ret;
	}

	tmpHandle = (Sck_Handle *)malloc(sizeof(Sck_Handle));
	if (tmpHandle == NULL)
	{
		ret = -2;
		printf("func socketclient_init() err :%d  malloc err \n", ret);
		return ret;
	}

	memset(tmpHandle, 0, sizeof(Sck_Handle));
	strcpy(tmpHandle->version, "1.0.0.1");
	strcpy(tmpHandle->ip, "192.168.12.12");
	tmpHandle->port = 8081;
	
	//间接赋值
	*handle = tmpHandle;
	return ret;
}

//socket报文发送
__declspec(dllexport)
int socketclient_send(void *handle, unsigned char *buf, int buflen)
{
	int			ret = 0;
	Sck_Handle	*tmpHandle = NULL;

	if (handle == NULL ||  buf==NULL || buflen <=0 )
	{
		ret = -2;
		printf("func socketclient_send() err :%d  (handle == NULL ||  buf==NULL || buflen <=0 ) \n", ret);
		return ret;
	}
	
	tmpHandle = (Sck_Handle *)handle;
	tmpHandle->len = buflen;
	tmpHandle->p = (unsigned char * )malloc(buflen);
	if (tmpHandle->p  == NULL)
	{
		ret = -2;
		printf("func socketclient_send() err :%d  malloc len:%d \n", ret, buflen);
		return ret;
	}
	memcpy(tmpHandle->p, buf, buflen); //数据的缓存到内存

	return ret;
}


//socket报文接受
__declspec(dllexport)
int socketclient_recv(void *handle, unsigned char *buf, int *buflen)
{
	int			ret = 0;
	Sck_Handle	*tmpHandle = NULL;

	if (handle == NULL ||  buf==NULL || buflen==NULL )
	{
		ret = -2;
		printf("func socketclient_recv() err :%d  (handle == NULL ||  buf==NULL || buflen==NULL ) \n", ret);
		return ret;
	}
	tmpHandle = (Sck_Handle *)handle;

	memcpy(buf, tmpHandle->p, tmpHandle->len);
	*buflen = tmpHandle->len; //间接赋值  告诉调用者 收到的数据的长度

	return ret;
}


//socket环境释放
__declspec(dllexport)
int socketclient_destory(void *handle)
{
	int			ret = 0;
	Sck_Handle	*tmpHandle = NULL;

	if (handle == NULL)
	{
		return -1;
	}

	tmpHandle = (Sck_Handle *)handle;
	if (tmpHandle->p != NULL)
	{
		free(tmpHandle->p); //释放结构体 成员域的 指针所指向的内存空间
	}
	free(tmpHandle); //释放结构体内存
	return 0;
}




mysocketclientdll第二套API

mysocketclient.h





//written by  wangbaoming1999@163.com
//
/*
下面定义了一套socket客户端发送报文接受报文的api接口
请写出这套接口api的调用方法
*/

/*
//这是一套动态库，实现了客户端和服务器端报文的发送。。
是客户端api函数
*/

#ifndef _INC_MYSOCKETCLIENT_H__
#define _INC_MYSOCKETCLIENT_H__

#ifdef  __cplusplus
extern "C" {
#endif

//1 数据类型的封装
//2 handle的概念:  底层库的内存资源,记录着函数运行的上下文信息..
//3 底层库提供的是一种机制, 而不是满足某一个人的策略 

int socketclient_init(void **handle);
int socketclient_send(void *handle, unsigned char *buf, int buflen);
int socketclient_recv(void *handle, unsigned char *buf, int *buflen);
int socketclient_destory(void *handle);




//////////////////////////////////////////////////////////////////////////

int socketclient_init2(void **handle /*out*/);
int socketclient_send2(void *handle/*in*/, unsigned char *buf, int buflen);
int socketclient_recv2(void *handle, unsigned char **buf /*out*/, int *buflen); //在底层库中分配内存

int socketclient_Free2(void *p); //在底层库分配的内存 ,需要 调用底层库的api函数进行释放 

int socketclient_destory2(void **handle /*in out*/); //释放完内存以后 ,再把实参置成null


#ifdef  __cplusplus
}
#endif

#endif  /* _INC_MYSOCKETCLIENT_H__ */




dm01_测试socket.c


#define  _CRT_SECURE_NO_WARNINGS 
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include "mysocketclient.h"



void main()
{
	unsigned char buf[1024];
	int buflen ;

	//unsigned char out[1024];
	//int outlen ;

	unsigned char *pout = NULL;
	int outlen ;

	void *handle  = NULL;
	int ret = 0;


	strcpy((char *)buf, "aaaaaaaaaffffffffdddddddd");
	buflen = 9;

	//客户端初始化 获取handle上下
	ret = socketclient_init2(&handle /*out*/); 
	if (ret != 0)
	{
		printf("func socketclient_init2() err:%d \n ", ret);
		goto End;
	}

	//客户端发报文
	ret = socketclient_send2(handle /*in*/, buf /*in*/,  buflen /*in*/);
	if (ret != 0)
	{
		printf("func socketclient_send2() err:%d \n ", ret);
		goto End;
	}

	//客户端收报文
	ret = socketclient_recv2(handle /*in*/, &pout /*in*/, &outlen/*in out*/);
	if (ret != 0)
	{
		printf("func socketclient_recv() err:%d \n ", ret);
		goto End;
	}

	//if (pout != NULL) free(pout);
	socketclient_Free2(pout); //在底层库分配的内存 ,需要 调用底层库的api函数进行释放 


End:
	//客户端释放资源
	ret = socketclient_destory2(&handle/*in*/); //把handle所指的内存释放 2 把handle重新赋值成NULL


	printf("hello...\n");
	system("pause");
	printf("hello...\n");
	system("pause");
	return ;
}

void main01()
{
	unsigned char buf[1024];
	int buflen ;

	unsigned char out[1024];
	int outlen ;

	void *handle  = NULL;
	int ret = 0;


	strcpy((char *)buf, "aaaaaaaaaffffffffdddddddd");
	buflen = 9;

	//客户端初始化 获取handle上下
	ret = socketclient_init(&handle /*out*/); 
	if (ret != 0)
	{
		printf("func socketclient_init() err:%d \n ", ret);
		goto End;
	}

	//客户端发报文
	ret = socketclient_send(handle /*in*/, buf /*in*/,  buflen /*in*/);
	if (ret != 0)
	{
		printf("func socketclient_send() err:%d \n ", ret);
		goto End;
	}

	//客户端收报文
	ret = socketclient_recv(handle /*in*/, out /*in*/, &outlen/*in out*/);
	if (ret != 0)
	{
		printf("func socketclient_recv() err:%d \n ", ret);
		goto End;
	}

End:
	//客户端释放资源
	ret = socketclient_destory(handle/*in*/);

	printf("hello...\n");
	system("pause");
	printf("hello...\n");
	system("pause");
	return ;
}




案例_动态库升级成框架_第一种方法

动态库升级成框架_第2种方法

_框架简化_回调函数测试案例

函数正向调用程序

第9章  函数模板的简单使用1.cpp


#include <iostream>
using namespace std;

// 1.cpp

// g++ -S 1.cpp  -o 1.s
template <typename T>
void myswap(T &a, T &b)
{
	T c = 0;
	c = a;
	a = b;
	b = c;
	cout << "hello ....我是模板函数 欢迎 calll 我" << endl;
}

int main()
{
	{

		int x = 10; 
		int y = 20;

		myswap<int>(x, y); //1 函数模板 显示类型 调用

		printf("x:%d y:%d \n", x, y);
	}


	{
		char a = 'a'; 
		char b = 'b';

		myswap<char>(a, b); //1 函数模板 显示类型 调用
		printf("a:%c b:%c \n", a, b);
	}
	return 0;
}


为什么会有函数模板和基本语法


#include <iostream>
using namespace std;


// 函数的业务逻辑 一样 ,即函数体的代码一样，只是传的形参参数类型不同
// 函数的参数类型 不一样
void myswap01(int &a, int &b)
{
	int c = 0;
	c = a;
	a = b;
	b = c;
}

void myswap02(char &a, char &b)
{
	char c = 0;
	c = a;
	a = b;
	b = c;
}


//让 类型参数化 ===, 方便程序员进行编码
// 泛型编程 
//template 告诉C++编译器 我要开始泛型编程了 .看到T, 不要随便报错
template <typename T>
void myswap(T &a, T &b)
{
	T c = 0;
	c = a;
	a = b;
	b = c;
	cout << "hello ....我是模板函数 欢迎 calll 我" << endl;
}


//函数模板的调用
// 显示类型 调用
// 自动类型 推导
void main()
{
	{
		
		int x = 10; 
		int y = 20;

		//myswap<int>(x, y); //1 函数模板 显示类型 调用

		//myswap(x, y);  //2 自动类型 推导
		printf("x:%d y:%d \n", x, y);
	}

	
	{

		char a = 'a'; 
		char b = 'b';

		//myswap<char>(a, b); //1 函数模板 显示类型 调用

		myswap(a, b);
		printf("a:%c b:%c \n", a, b);
	}
}

void main11()
{
	{
		int x = 10; 
		int y = 20;

		myswap01(x, y);
		printf("x:%d y:%d \n", x, y);

	}

	{
		char a = 'a'; 
		char b = 'b';

		myswap02(a, b);
		printf("a:%c b:%c \n", a, b);
	}
	

	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

_函数模板当函数参数强化


#include <iostream>
using namespace std;

// 函数模板 本质 : 类型参数化  
//方便.....


//让你对字符数组  int数组进行排序

template <typename T,typename T2 >
int mySort(T *array, T2 size)
{
	T2 i, j ;
	T tmp;
	if (array == NULL)
	{
		return -1;
	}

	//选择  
	for (i=0; i<size; i++)
	{
		for (j=i+1; j<size; j++)
		{
			if (array[i] < array[j])
			{
				tmp = array[i];
				array[i] = array[j];
				array[j] = tmp;
			}
		}
	}
	return 0;
}

template <typename T, typename T2>
int myPrint(T *array, T2 size)
{
	T2 i = 0;
	for (i=0; i<size; i++)
	{
		cout << array[i] << " ";
	}
	return 0;
}

void main()
{
	// int类型
// 	{
// 		int myarray[] = {11, 33,44, 33,22, 2, 3, 6, 9};
// 
// 		int size =  sizeof(myarray)/sizeof(*myarray);
// 		mySort<int, int> (myarray, size);
// 
// 		printf("排序之后\n");
// 		myPrint(myarray, size);
// 
// 	}

	//char 类型
	{
		char buf[] = "aff32ff2232fffffdssss";
		int len = strlen(buf);

		mySort<char, int>(buf, len);
		myPrint<char , int>(buf, len);

	}


	

	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

函数模板遇上函数重载


#include <iostream>
using namespace std;



//让 类型参数化 ===, 方便程序员进行编码
// 泛型编程 
//template 告诉C++编译器 我要开始泛型编程了 .看到T, 不要随便报错
template <typename T>
void myswap(T &a, T &b)
{
	T c = 0;
	c = a;
	a = b;
	b = c;
	cout << "hello ....我是模板函数 欢迎 calll 我" << endl;
}

void myswap(int a, char c)
{
	cout << "a:" << a << "c:" << c << endl;
	cout << "我是普通函数 欢迎来访" << endl;
}


void main()
{
	int		a = 10;
	char	c = 'z';

	myswap(a, c); // 普通函数的调用:  可以对形参进行隐式的类型转换 
	myswap(c, a); //

	myswap(a, a); // 函数模板函数的调用(本质:类型参数化): 将严格的按照类型进行匹配,不会进行自动类型转换

	
	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

函数模板和普通函数在一起调用规则研究


/*
函数模板不允许自动类型转化
普通函数能够进行自动类型转换
*/

/*
	1 函数模板可以像普通函数一样被重载
	2 C++编译器优先考虑普通函数
	3 如果函数模板可以产生一个更好的匹配，那么选择模板
	4 可以通过空模板实参列表的语法限定编译器只通过模板匹配
*/


#include "iostream"
using namespace std;


int Max(int a, int b)
{
	cout<<"int Max(int a, int b)"<<endl;
	return a > b ? a : b;
}

template<typename T>
T Max(T a, T b)
{
	cout<<"T Max(T a, T b)"<<endl;
	return a > b ? a : b;
}

template<typename T>
T Max(T a, T b, T c)
{
	cout<<"T Max(T a, T b, T c)"<<endl;
	return Max(Max(a, b), c);
}


void main()
{
	int a = 1;
	int b = 2;

	cout<<Max(a, b)<<endl; //当函数模板和普通函数都符合调用时,优先选择普通函数
	cout<<Max<>(a, b)<<endl; //若显示使用函数模板,则使用<> 类型列表

	cout<<Max(3.0, 4.0)<<endl; //如果 函数模板产生更好的匹配 使用函数模板

	cout<<Max(5.0, 6.0, 7.0)<<endl; //重载

	cout<<Max('a', 100)<<endl;  //调用普通函数 可以隐式类型转换 
	system("pause");
	return ;
}


模板机制剖析


#include <iostream>
using namespace std;

/*

函数模板机制结论
	编译器并不是把函数模板处理成能够处理任意类的函数
	编译器从函数模板通过具体类型产生不同的函数如myswap01_int ,myswap01_char
	编译器会对函数模板进行两次编译
	在声明的地方对模板代码本身进行编译；在调用的地方对参数替换后的代码进行编译。
*/

/*
// 函数的业务逻辑 一样 
// 函数的参数类型 不一样
void myswap01(int &a, int &b)
{
	int c = 0;
	c = a;
	a = b;
	b = c;
}

void myswap02(char &a, char &b)
{
	char c = 0;
	c = a;
	a = b;
	b = c;
}
*/


// 1.cpp

// g++ -S 1.cpp  -o 1.s
template <typename T>
void myswap(T &a, T &b)
{
	T c = 0;
	c = a;
	a = b;
	b = c;
	cout << "hello ....我是模板函数 欢迎 calll 我" << endl;
}

void main()
{
	{

		int x = 10; 
		int y = 20;

		myswap<int>(x, y); //1 函数模板 显示类型 调用

		printf("x:%d y:%d \n", x, y);
	}


	{
		char a = 'a'; 
		char b = 'b';

		myswap<char>(a, b); //1 函数模板 显示类型 调用
		printf("a:%c b:%c \n", a, b);
	}
	return 0;
}


类模板基本语法


#include <iostream>
using namespace std;

//A编程模板 类 
//模板类  类型参数化


//类模板的定义
//类模板的使用
//类模板 做函数参数

//模板类 
template <class T>//类模板中T为成员变量的类形，在用模板类时创建对象需指明如A<int>(a)创建对象
class A
{
public:
	A(T a)
	{
		this->a = a;
	}
public:
	void printA()
	{
		cout << "a: " << a << endl;
	}
protected:
	T a;
};


//从模板类 派生了 普通类
// 模板类派生时, 需要具体化模板类. C++编译器需要知道 父类的数据类型具体是什么样子的
//=====> 要知道父类所占的内存大小是多少 只有数据类型固定下来,才知道如何分配内存 
class B : public A<int>
{
public:
	B(int a=10, int b=20) : A<int>(a)
	{
		this->b = b;
	}
	void printB()
	{
		cout << "a:" << a << " b: " << b << endl;
	}

protected:
private:
	int b;
};


//从模板类 派生 模板类

template <typename T>
class C : public A<T>
{
public:
	C(T c, T a) : A<T>(a)
	{
		this->c = c;
	}
	void printC()
	{
		cout << "c:" << c <<endl;
	}
protected:
	T c;
};

void main()
{
	C<int> c1(1, 2);
	c1.printC();
	
	system("pause");
}

//
void main62()
{
	B  b1(1, 2);
	b1.printB();
	system("pause");
}

//类模板 做函数参数

//参数 ,C++编译器 要求具体的类 所以所 要 A<int> &a 
void UseA( A<int> &a )
{
	a.printA();
}

void main61()
{
	//模板类(本身就是类型化的)====具体的类=====>定义具体的变量

	A<int> a1(11), a2(20), a3(30); //模板类是抽象的  ====>需要进行 类型具体
	//a1.printA();

	UseA(a1);
	UseA(a2);
	UseA(a3);
	
	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

复数类_所有函数都写在类的内部


#include <iostream>
using namespace std;

template <typename T>
class Complex
{
	friend Complex MySub(Complex &c1, Complex &c2)
	{
		Complex tmp(c1.a - c2.a, c1.b - c2.b);
		return tmp;
	}

	friend ostream & operator<<(ostream &out, Complex &c3)
	{
		out <<  c3.a << " + " << c3.b <<  "i" << endl;
		return out;
	}
public:
	Complex(T a, T b)
	{
		this->a = a;
		this->b = b;
	}

	Complex operator+ (Complex &c2)
	{
		Complex tmp(a+c2.a, b+c2.b);
		return tmp;
	}

	void printCom()
	{
		cout << "a:" << a << " b: " << b << endl;
	}
private:
	T	a;
	T	b;
};
//运算符重载的正规写法 
// 重载 << >> 只能用友元函数  ,其他运算符重载 都要写成成员函数 , 不要滥用友元函数

/*
ostream & operator<<(ostream &out, Complex &c3)
{
	out <<  "a:" << c3.a << " b: " << c3.b << endl;
	return out;
}
*/


void main()
{
	//需要把模板类 进行具体化以后  才能定义对象  C++编译器要分配内存
	Complex<int>	c1(1, 2);
	Complex<int>	c2(3, 4);

	Complex<int> c3 = c1 + c2;
	//c3.printCom();
	cout << c3 << endl;

	//滥用友元函数
	{
		Complex<int> c4 = MySub(c1, c2);
		cout << c4 << endl;
	
	}

	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

_复数类_所有函数都写在类的外部(在一个cpp中)


#include <iostream>
using namespace std;

template <typename T>
class Complex ; //类的前置声明

template <typename T>
Complex<T> MySub (Complex<T> &c1, Complex<T> &c2);


template <typename T>
class Complex
{
	friend Complex<T> MySub<T> (Complex<T> &c1, Complex<T> &c2);

	friend ostream & operator<< <T> (ostream &out, Complex &c3);

public:
	Complex(T a, T b);
	void printCom();
	Complex operator+ (Complex &c2);	
	
private:
	T	a;
	T	b;
};

//构造函数的实现 写在了类的外部
template <typename T>
Complex<T>::Complex(T a, T b)
{
	this->a = a;
	this->b = b;
}

template <typename T>
void Complex<T>::printCom()
{
	cout << "a:" << a << " b: " << b << endl;
}

//本质是 : 模板是两次 编译生成的 第一次生成的函数头 和第二次生成的函数头 不一样
//成员函数 实现 +运算符重载
template <typename T>
Complex<T>  Complex<T>::operator+ (Complex<T> &c2)
{
	Complex tmp(a+c2.a, b+c2.b);
	return tmp;
}

//友元函数 实现 << 运算符重载

/*
1>dm08_复数类_所有函数都写在类的外部(在一个cpp中).obj : error LNK2019: 无法解析的外部符号 "
class std::basic_ostream<char,struct std::char_traits<char> > &
	__cdecl operator<<
	(class std::basic_ostream<char,struct std::char_traits<char> > &,class Complex<int> &)" 
	(??6@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV01@AAV?$Complex@H@@@Z)，
	该符号在函数 _main 中被引用
1>E:\01-work\21_CPlusPlus课程\day09\泛型编程课堂操练\Debug\泛型编程课堂操练.exe : fatal error LNK1120: 1 个无法解析的外部命令
*/

template <typename T>
ostream & operator<<(ostream &out, Complex<T> &c3)
{
	out <<  c3.a << " + " << c3.b <<  "i" << endl;
	return out;
}

//////////////////////////////////////////////////////////////////////////

//滥用 友元函数
template <typename T>
Complex<T> MySub(Complex<T> &c1, Complex<T> &c2)
{
	Complex<T> tmp(c1.a - c2.a, c1.b - c2.b);
	return tmp;
}


void main()
{
	//需要把模板类 进行具体化以后  才能定义对象  C++编译器要分配内存
	Complex<int>	c1(1, 2);
	Complex<int>	c2(3, 4);

	Complex<int> c3 = c1 + c2;
	//c3.printCom();
	cout << c3 << endl;

	//滥用友元函数
	{
		Complex<int> c4 = MySub<int>(c1, c2);
		cout << c4 << endl;

	}

	

	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

Complex类.h与.cpp分开写

Complex.h

#pragma  once

#include <iostream>
using namespace std;

template <typename T>
class Complex
{
	//friend Complex<T> MySub (Complex<T> &c1, Complex<T> &c2);
	friend ostream & operator<< <T> (ostream &out, Complex &c3);

public:
	Complex(T a, T b);
	void printCom();
	Complex operator+ (Complex &c2);	

private:
	T	a;
	T	b;
};


Complex.cpp


#include <iostream>
using namespace std;
#include "dm09_complex.h"


//构造函数的实现 写在了类的外部
template <typename T>
Complex<T>::Complex(T a, T b)
{
	this->a = a;
	this->b = b;
}

template <typename T>
void Complex<T>::printCom()
{
	cout << "a:" << a << " b: " << b << endl;
}


template <typename T>
Complex<T>  Complex<T>::operator+ (Complex<T> &c2)
{
	Complex tmp(a+c2.a, b+c2.b);
	return tmp;
}


template <typename T>
ostream & operator<<(ostream &out, Complex<T> &c3)
{
	out <<  c3.a << " + " << c3.b <<  "i" << endl;
	return out;
}

//////////////////////////////////////////////////////////////////////////

// 滥用 友元函数
// template <typename T>
// Complex<T> MySub(Complex<T> &c1, Complex<T> &c2)
//{
//	Complex<T> tmp(c1.a - c2.a, c1.b - c2.b);
//	return tmp;
//}

dm09_complex_test


#include <iostream>
using namespace std;
#include "dm09_complex.hpp"

void main()
{
	
	//需要把模板类 进行具体化以后  才能定义对象  C++编译器要分配内存
	Complex<int>	c1(1, 2);
	Complex<int>	c2(3, 4);

	Complex<int> c3 = c1 + c2;
	//c3.printCom();
	cout << c3 << endl;

	//滥用友元函数
	{
		//Complex<int> c4 = MySub<int>(c1, c2);
		//cout << c4 << endl;
	}

	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

dm09_复数类_所有函数都写在类的外部(h和cpp分开)


#include <iostream>
using namespace std;

template <typename T>
class Complex
{
	friend Complex<T> MySub<T> (Complex<T> &c1, Complex<T> &c2);
	friend ostream & operator<< <T> (ostream &out, Complex &c3);

public:
	Complex(T a, T b);
	void printCom();
	Complex operator+ (Complex &c2);	
	
private:
	T	a;
	T	b;
};

//构造函数的实现 写在了类的外部
template <typename T>
Complex<T>::Complex(T a, T b)
{
	this->a = a;
	this->b = b;
}

template <typename T>
void Complex<T>::printCom()
{
	cout << "a:" << a << " b: " << b << endl;
}

//本质是 : 模板是两次 编译生成的 第一次生成的函数头 和第二次生成的函数头 不一样
//成员函数 实现 +运算符重载
template <typename T>
Complex<T>  Complex<T>::operator+ (Complex<T> &c2)
{
	Complex tmp(a+c2.a, b+c2.b);
	return tmp;
}


template <typename T>
ostream & operator<<(ostream &out, Complex<T> &c3)
{
	out <<  c3.a << " + " << c3.b <<  "i" << endl;
	return out;
}

//////////////////////////////////////////////////////////////////////////

//滥用 友元函数
template <typename T>
Complex<T> MySub(Complex<T> &c1, Complex<T> &c2)
{
	Complex<T> tmp(c1.a - c2.a, c1.b - c2.b);
	return tmp;
}


void main()
{
	//需要把模板类 进行具体化以后  才能定义对象  C++编译器要分配内存
	Complex<int>	c1(1, 2);
	Complex<int>	c2(3, 4);

	Complex<int> c3 = c1 + c2;
	//c3.printCom();
	cout << c3 << endl;

	//滥用友元函数
	{
		Complex<int> c4 = MySub<int>(c1, c2);
		cout << c4 << endl;

	}

	

	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

类模板中的static关键字


/*

编译器并不是把函数模板处理成能够处理任意类的函数
	编译器从函数模板通过具体类型产生不同的函数
	编译器会对函数模板进行两次编译
	在声明的地方对模板代码本身进行编译；在调用的地方对参数替换后的代码进行编译。
    static T m_a;不同的类模板，将会产生多个static T m_a的静态成员
*/

#include <iostream>
using namespace std;

template <typename T>
class AA
{
public:
	static T m_a;
protected:
private:
};

template <typename T>
T AA<T>::m_a  = 0;


class AA1
{
public:
	static int m_a;
protected:
private:
};
 int AA1::m_a  = 0;


class AA2
{
public:
	static char m_a;
protected:
private:
};
char AA2::m_a  = 0;




void main()
{
	AA<int> a1, a2, a3;
	a1.m_a = 10;
	a2.m_a ++;
	a3.m_a ++;
	cout << AA<int>::m_a << endl;

	AA<char> b1, b2, b3;
	b1.m_a = 'a';
	b2.m_a ++;
	b2.m_a ++ ;

	cout << AA<char>::m_a << endl;

	//m_a 应该是 每一种类型的类 使用自己的m_a

	
	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

Myvector案例

MyVector.h

#include <iostream>
using namespace std;

template <typename T>
class MyVector
{

	friend ostream & operator<< <T>(ostream &out,  const MyVector &obj);
public:
	MyVector(int size = 0);  //构造函数
	MyVector(const MyVector &obj); // 拷贝构造函数
	~MyVector(); //析构函数

public:

	T& operator[] (int index);
	// a3 = a2 = a1;
	MyVector &operator=(const MyVector &obj);

	

public:
	int getLen()
	{
		return m_len;
	}

protected:
	T *m_space;
	int m_len;
};




MyVector.cpp


#include <iostream>
using namespace std;
#include "MyVector.h"

template <typename T>
ostream & operator<<(ostream &out,  const MyVector<T> &obj)
{
	for (int i=0; i<obj.m_len; i++)
	{
		out << obj.m_space[i] << " ";
		//out << t1;
	}
	out << endl;
	return out;
}


//MyVector<int> myv1(10);
template <typename T>
MyVector<T>::MyVector(int size)  //构造函数
{
	m_space = new T[size];
	m_len = size;
}


//MyVector<int> myv2  = myv1;
template <typename T>
MyVector<T>::MyVector(const MyVector &obj) // 拷贝构造函数
{
	//根据myv1的大小分配内存
	m_len = obj.m_len;
	m_space = new T[m_len];

	//copy数据
	for (int i=0; i<m_len; i++)
	{
		m_space[i] = obj.m_space[i];
	}

}

template <typename T>
MyVector<T>::~MyVector() //析构函数
{
	if (m_space != NULL)
	{
		delete [] m_space;
		m_space = NULL;
		m_len = 0;
	}
}

template <typename T>
T& MyVector<T>::operator[] (int index)
{
	return m_space[index];
}


// a3 = a2 = a1;
template <typename T>
MyVector<T> &  MyVector<T>::operator=(const MyVector<T> &obj)
{
	//先把a2的旧的内存释放掉

	if (m_space != NULL)
	{
		delete[] m_space;
		m_space = NULL;
		m_len = 0;
	}

	//根据a1分配内存 
	m_len = obj.m_len;
	m_space = new T[m_len];

	//copy数据
	for (int i=0; i<m_len; i++)
	{
		m_space[i] = obj[i];
	}
	return *this;  // a2 = a1; 返回给a2 的自身
}


MyVector_test.cpp


#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
using namespace std;

#include "MyVector.cpp"

//1  优化Teacher类, 属性变成 char *panme, 购置函数里面 分配内存
//2  优化Teacher类,析构函数 释放panme指向的内存空间
//3  优化Teacher类,避免浅拷贝 重载= 重写拷贝构造函数 
//4  优化Teacher类,在Teacher增加 << 
//5  在模板数组类中,存int char Teacher Teacher*(指针类型)

//=====>stl 容器的概念 


class Teacher
{
public:
	Teacher()
	{
		age = 33;
		strcpy(name, "");
	}

	Teacher(char *name, int age)
	{
		this->age = age;
		strcpy(this->name, name);
	}
	void printT()
	{
		cout << name << ", " << age << endl;
	}
private:
	int age;
	//char name[32];
	char *pName2;
};


void main()
{
	Teacher t1("t1", 31), t2("t2", 32), t3("t3", 33), t4("t4", 34);

	MyVector<Teacher> tArray(4);

	tArray[0] = t1;
	tArray[1] = t2;
	tArray[2] = t3;
	tArray[3] = t4;

	for (int i=0; i<4; i++)
	{
		Teacher tmp = tArray[i];
		tmp.printT();
	}
	cout << tArray;



	system("pause");
}
void main02()
{
	MyVector<char> myv1(10);
	myv1[0] = 'a';
	myv1[1] = 'b';
	myv1[2] = 'c';
	myv1[3] = 'd';

	cout << myv1;

	system("pause");
}

void main01()
{
	MyVector<int> myv1(10);

	for (int i=0; i<myv1.getLen(); i++)
	{
		myv1[i] = i+1;
		cout << myv1[i] << " ";
	}
	cout << endl;


	MyVector<int> myv2  = myv1;
	for (int i=0; i<myv2.getLen(); i++)
	{
		cout << myv2[i] << " ";
	}

	cout << myv2 << endl;
	
	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

类型转换


#include <iostream>
using namespace std;

/*
C风格的强制类型转换(Type Cast)很简单，不管什么类型的转换统统是：
	TYPE b = (TYPE)a   
	C++风格的类型转换提供了4种类型转换操作符来应对不同场合的应用。
	　　static_cast		静态类型转换。如int转换成char让C++编译在编译的时候进行 类型检查 使用static_cast, 编译器编译时,会做类型检查 若有错误 提示错误c语言中 隐式类型转换的地方 均可使用 static_cast<>() 进行类型转换
		reinterpreter_cast	重新解释类型 //若不同类型之间，进行强制类型转换，用reinterpret_cast<>() 进行重新解释
通过 reinterpret_cast<>() 和 static_cast<>()把C语言的强制类型转换 都覆盖了..
		dynamic_cast		命名上理解是动态类型转换。如子类和父类之间的多态类型转换。把父类转换成子类
		const_cast，		字面上理解就是去const属性。
		4种类型转换的格式：
			TYPE B = static_cast<TYPE> (a)  
*/

//const char *p 的const修饰 让p指向的内存空间 变成只读属性
void printBuf(const char *  p)
{
	//p[0] = 'Z';
	char *p1 = NULL;
	//程序员 要清楚的知道 变量:转换之前是什么类型 ,转换之后是什么类型
	//const char * ===> char * //把只读属性 去掉
	p1 = const_cast<char *>(p);

	p1[0] = 'Z' ;  //通过p1 去修改了内存空间
	cout << p << endl;
}

void main()
{
	char buf[] = "aaaaaaaaafffffddd";

	char *myp = "aaaaaaaaafffffddd";

	//程序员 要确保 p所指向的内存空间 确实能修改 ;如果不能修改会带来灾难性后果
	//printBuf (buf);

	printBuf (myp);

	system("pause");
}


class Tree {};

class Animal
{
public:
	virtual void cry() = 0;
};

class Dog : public Animal
{
public:
	virtual void cry()
	{
		cout << "汪汪" << endl;
	}
	void doHome()
	{
		cout << "看家" << endl;
	}
};

class Cat : public Animal
{
public:
	virtual void cry()
	{
		cout << "喵喵" << endl;
	}
	void doThing()
	{
		cout << "抓老鼠" << endl;
	}
};

void playObj(Animal *base)
{
	base->cry(); // 1有继承 2虚函数重写 3 父类指针 指向子类对象  ==>多态
	//能识别子类对象
	// dynamic_cast 运行时类型识别  RIIT
	
	Dog *pDog = dynamic_cast<Dog *>(base);
	if (pDog != NULL)
	{
		pDog->doHome(); //让够 做自己 特有的工作 
	}

	Cat *pCat = dynamic_cast<Cat *>(base);	//父类对象 ===> 子类对象 
											//向下转型  
											//把老子 转成 小子 
	if (pCat != NULL)
	{
		pCat->doThing();  //让够 做自己 特有的工作 
	}
}

void main02()
{
	Dog d1;
	Cat c1;

	Animal *pBase = NULL;

	pBase = &d1;

	pBase = static_cast<Animal *>(&d1); //让C++编译在编译的时候进行 类型检查 

	//强制类型转换 
	pBase = reinterpret_cast<Animal *>(&d1); 
	
	{
		Tree t1;
		//pBase = static_cast<Animal *>(&t1); // C++编译器会做类型检查
		pBase = reinterpret_cast<Animal *>(&t1);  //reinterpret_cast 重新解释 ....强制类转换的味道
	}
	//

	playObj(&d1);
	playObj(&c1);

	system("pause");
}

void main01()
{
	double dpi = 3.1415926;

	int num1 = (int)dpi; //C类型转换
	int num2 = static_cast<int>(dpi); //静态类型转换  编译的时c++编译器会做类型检查
	int num3 = dpi; //c语言中 隐式类型转换的地方 均可使用 static_cast<>() 进行类型转换

	//char* ===> int *
	char *p1 = "hello...itcast ";
	int *p2 = NULL;
	//p2 = static_cast<int*>(p1); // 使用static_cast, 编译器编译时,会做类型检查 若有错误 提示错误

	p2 = reinterpret_cast<int *>(p1); //若不同类型之间，进行强制类型转换，用reinterpret_cast<>() 进行重新解释

	cout << "p1:" << p1 << endl; //%s
	cout <<"p2" << p2 << endl; //%d

	//总结:通过 reinterpret_cast<>() 和 static_cast<>()把C语言的强制类型转换 都覆盖了..
	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

异常的基本语法


#include <iostream>
using namespace std;

//1 基本语法 
//2 发生异常之后,是跨函数 :
//3 接受异常以后 可以不处理 再抛出异常
//4 catch异常的时 按照类型进行catch，throw与catch对应，throw一个异常必须捕捉

//5 异常捕捉严格按照类型匹配

void main()
{
	try
	{
		throw 'Z';
	}
	catch (int e)
	{
		cout << "捕获int类型异常" << endl;
	}
	catch(...)
	{
		cout << " 未知 类型异常" << endl;
	}
	system("pause");
}


void divide(int x, int y)
{
	if (y == 0)
	{
		throw x; //抛出 int类型 异常
	}

	cout << "divide结果:" << x/y<< endl;
}

void myDivide(int x, int y)
{
	try
	{
		divide(x, y);
	}
	catch (...)
	{
		cout << "我接受了 divide的异常 但是我没有处理 我向上抛出" << endl;
		throw ;
	}
}


void main22()
{
	myDivide(100, 0);
	
	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

void main21()
{
	try
	{
		//divide(10, 2);
		//divide(100, 0);

		myDivide(100, 0);
	}
	catch (int e)
	{
		cout << e << "被零除" << endl;
	}
	catch ( ... )  //
	{
		cout <<  "其他未知类型异常 "<< endl;
	}
	
	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

栈解旋unwinding


#include <iostream>
using namespace std;

class Test3
{
public:
	Test3(int a=0, int b=0)
	{
		this->a = a;
		this->b = b;
		cout << "构造函数do \n";
	}
	~Test3()
	{
		cout << "析构函数do \n";
	}
private:
	int a;
	int b;
};

void myDivide() throw (int, char, char *)
{
	Test3 t1(1, 2), t2(3, 4);
	cout << "myDivide ...要发生异常\n" ;
	//throw Test3;
	throw 1;
}


//只能是 抛出所列出类型
void myDivide1() throw (int, char, char *)
{
	Test3 t1(1, 2), t2(3, 4);
	cout << "myDivide ...要发生异常\n" ;
	//throw Test3;
	throw 1;
}

//不写,可以抛出任何类型
void myDivide2() 
{
	Test3 t1(1, 2), t2(3, 4);
	cout << "myDivide ...要发生异常\n" ;
	//throw Test3;
	throw 1;
}
// 不抛出异常
void myDivide3() throw ()
{
	Test3 t1(1, 2), t2(3, 4);
	cout << "myDivide ...要发生异常\n" ;
	//throw Test3;
	throw 1;
}


void main()
{
	try
	{
		myDivide();
	}
	catch (int a)
	{
		cout << "int类型 异常\n" ;
	}

	catch (...)
	{
		cout << " 未知 异常\n" ;
	}
	

	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

异常类型_异常变量的生命周期


#include <iostream>
using namespace std;

/*
接收元素的类型一定要和抛出的元素类型相同，如果抛出引用，则接收时用引用，如果抛出的是地址，接收时用指针

//如果接收异常的时候使用的是一个元素，则会拷贝抛出的那个对象，执行拷贝构造函数，在析构的时候当出了catch(BadProcessType e){}括号后会先析构拷贝的对象，然后再析构throw 抛出的对象，执行两次析构函数

//如果接收异常的时候使用的是一个引用，则不会产生拷贝对象，直接使用那个throw 抛出的对象

注意，如果在接收异常时用了一个元素去接收，就不能再用catch的引用去接收，这会产生冲突。

//如果catch接收时用的是一个指针去接收throw e,此时还可以同时写一个catch &e 引用，或者可以同时写一个catch e元素去接收，如果是指针类型，必须要抛出一个地址但是这样抛出有问题throw &(BadProcessType())，这是一个栈变量，必需使用throw new BadProcesstype;这时候接收的指针是抛出的这个堆对象，必须在catch{delete e}释放

所以建议抛出引用
*/
//传统的错误处理机制
//throw int类型异常
void my_strcpy1(char *to, char *from)
{
	if (from == NULL)
	{
		throw 1;
	}
	if (to == NULL)
	{
		throw 2;
	}

	//copy是的 场景检查
	if (*from == 'a')
	{
		throw 3; //copy时出错
	}
	while (*from != '\0')
	{
		*to = *from;
		to ++;
		from ++;
	}
	*to = '\0';
}

//传统的错误处理机制
//throw char*类型异常
void my_strcpy2(char *to, char *from)
{
	if (from == NULL)
	{
		throw "源buf出错";
	}
	if (to == NULL)
	{
		throw "目的buf出错";
	}

	//copy是的 场景检查
	if (*from == 'a')
	{
		throw "copy过程出错"; //copy时出错
	}
	while (*from != '\0')
	{
		*to = *from;
		to ++;
		from ++;
	}
	*to = '\0';
}


class BadSrcType {};
class BadDestType {};
class BadProcessType
{
public:
	BadProcessType()
	{
		cout << "BadProcessType构造函数do \n";
	}


	BadProcessType(const BadProcessType &obj)
	{
		cout << "BadProcessType copy构造函数do \n";
	}

	~BadProcessType()
	{
		cout << "BadProcessType析构函数do \n";
	}

};


//传统的错误处理机制
//throw 类对象 类型异常
void my_strcpy3(char *to, char *from)
{
	if (from == NULL)
	{
		throw BadSrcType();
	}
	if (to == NULL)
	{
		throw BadDestType();
	}

	//copy是的 场景检查
	if (*from == 'a')
	{
		printf("开始 BadProcessType类型异常 \n");
		throw BadProcessType(); //会不会产生一个匿名对象?
	}

	if (*from == 'b')
	{
		throw &(BadProcessType()); //会不会产生一个匿名对象?
	}

	if (*from == 'c')
	{
		throw new BadProcessType; //会不会产生一个匿名对象?
	}
	while (*from != '\0')
	{
		*to = *from;
		to ++;
		from ++;
	}
	*to = '\0';
}

void main()
{
	int ret = 0;
	char buf1[] = "cbbcdefg";
	char buf2[1024] = {0};

	try
	{
		//my_strcpy1(buf2, buf1);
		//my_strcpy2(buf2, buf1);
		my_strcpy3(buf2, buf1);
	}
	catch (int e) //e可以写 也可以不写
	{
		cout << e << " int类型异常" << endl;
	}
	catch(char *e)
	{
		cout << e << " char* 类型异常" << endl;
	}

	//---
	catch(BadSrcType e)
	{
		cout << " BadSrcType 类型异常" << endl;
	}
	catch(BadDestType e)
	{
		cout << " BadDestType 类型异常" << endl;
	}
	//结论1: 如果 接受异常的时候 使用一个异常变量,则copy构造异常变量.  
	/*
	catch( BadProcessType e) //是把匿名对象copy给e 还是e还是那个匿名对象，拷贝了e
	{
		cout << " BadProcessType 类型异常" << endl;
	}
	*/
	//结论2: 使用引用的话 会使用throw时候的那个对象，使用了抛出的那个对 
	//catch( BadProcessType &e) //是把匿名对象copy给e 还是e还是那个匿名对象
	//{
	//	cout << " BadProcessType 类型异常" << endl;
	//}

	//结论3: 指针可以和引用/元素写在一块 但是引用/元素不能写在一块
	catch( BadProcessType *e) //是把匿名对象copy给e 还是e还是那个匿名对象
	{
		cout << " BadProcessType 类型异常" << endl;
		delete e;
	}
	
	//结论4: 类对象时, 使用引用比较合适 

	// --
	catch (...)
	{
		cout << "未知 类型异常" << endl;
	}

	cout<<"hello..."<<endl;
	system("pause");
	return ;
}


//传统的错误处理机制
int my_strcpy(char *to, char *from)
{
	if (from == NULL)
	{
		return 1;
	}
	if (to == NULL)
	{
		return 2;
	}
		
	//copy是的 场景检查
	if (*from == 'a')
	{
		return 3; //copy时出错
	}
	while (*from != '\0')
	{
		*to = *from;
		to ++;
		from ++;
	}
	*to = '\0';

	return 0;
}


void main41()
{
	int ret = 0;
	char buf1[] = "zbcdefg";
	char buf2[1024] = {0};

 	ret = my_strcpy(buf2, buf1);
	if (ret != 0)
	{
		switch(ret)
		{
		case 1:
			printf("源buf出错!\n");
			break;
		case 2:
			printf("目的buf出错!\n");
			break;
		case 3:
			printf("copy过程出错!\n");
			break;
		default:
			printf("未知错误!\n");
			break;
		}
	}
	printf("buf2:%s \n", buf2);
	
	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

异常的层次结构


#include <iostream>
using namespace std;

class MyArray//数组类
{
public:
	MyArray(int len);
	~MyArray();
public:
	int & operator[](int index);//定义类方法
	int getLen();//定义类方法

	class eSize//内部类
	{
	public:
		eSize(int size)//初始化大小
		{
			m_size = size;
		}
		virtual void printErr()
		{
			cout << "size:" << m_size << " ";
		}
	protected:
		int m_size;
	};
	class eNegative : public eSize//内部类
	{
	public:
		eNegative(int size) : eSize(size)
		{
			;
		}
		virtual void printErr()
		{
			cout << "eNegative 类型 size:" << m_size << " ";
		}
	};
	class eZero : public eSize//内部类
	{
	public:
		eZero(int size) : eSize(size)
		{
			;
		}
		virtual void printErr()
		{
			cout << "eZero 类型 size:" << m_size << " ";
		}
	};
	class eTooBig : public eSize//内部类继承内部的类
	{
	public:
		eTooBig(int size) : eSize(size)
		{
			;
		}
		virtual void printErr()//内部类的实现
		{
			cout << "eTooBig 类型 size:" << m_size << " ";
		}
	};
	class eTooSmall : public eSize//内部类继承内部的类
	{
	public:
		eTooSmall(int size) : eSize(size)
		{
			;
		}
		virtual void printErr()
		{
			cout << "eTooSmall 类型 size:" << m_size << " ";
		}
	};

private:
	int *m_space;//空闇大小
	int m_len;//数组长度
};


MyArray::MyArray(int len)//初始化方法的实现
{
	if (len  < 0)
	{
		throw eNegative(len);//抛出不同的内部类，因为这个类是创建的公有的，外部可以访问
	}
	else if (len == 0)
	{
		throw eZero(len);
	}
	else if (len > 1000)
	{
		throw eTooBig(len);
	}
	else if (len < 3)
	{
		throw eTooSmall(len);
	}
	m_len = len;
	m_space = new int[len];
}

MyArray::~MyArray()//析构
{
	if (m_space != NULL)
	{
		delete [] m_space;
		m_space = NULL;
		m_len = 0;
	}
}

int & MyArray::operator[](int index)//重载
{
	return m_space[index];
}

int MyArray::getLen()
{
	return m_len;
}

void main()
{

	try
	{
		MyArray a(-5);
		for (int i=0; i<a.getLen(); i++)
		{
			a[i] = i+1;
			printf("%d ", a[i]);
		}
	}
	catch(MyArray::eSize &e)//捕捉类部类中父类的异常
	{
		//cout <<  "len的大小: " << e.eSize();
		e.printErr();
	}
	catch (...)
	{
	}


	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

// 不推荐，因为需要捕捉许多子类
void main51()
{
	
	try
	{
		MyArray a(-5);
		for (int i=0; i<a.getLen(); i++)
		{
			a[i] = i+1;
			printf("%d ", a[i]);
		}
	}
	catch(MyArray::eNegative e)
	{
		cout << "eNegative 类型异常" << endl;
	}
	catch(MyArray::eZero e)
	{
		cout << "eZero 类型异常" << endl;
	}
	catch(MyArray::eTooBig e)
	{
		cout << "eTooBig 类型异常" << endl;
	}
	catch(MyArray::eTooSmall e)
	{
		cout << "eTooSmall 类型异常" << endl;
	}
	
	catch (...)
	{
	}
	

	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

标准异常


// out_of_range
#include "iostream"
using namespace std;
#include <stdexcept> //使用了标准异常库
#include "string"

// out_of_range
class Teacher
{
public:
	Teacher(int age)
	{
		if (age > 100)
		{
			string  s = "年龄太大";
			throw out_of_range(s);
		}
		this->age = age;
	}
protected:
private:
	int age;
};

void main61()
{
	try
	{
		Teacher t1(102);
	}
	catch (out_of_range e)
	{

		cout << e.what() << endl;
	}

	exception e;
	system("pause");
}

class MyException : public exception
{
public:
	MyException(const char *p)
	{
		this->m_p = p;
	}

	virtual const char *  what()
	{
		cout << "MyException: 类型" << m_p << endl;
		return m_p;
	}
protected:
private:
	const char *m_p;
};

void testMyExcept()
{
	throw MyException("函数异常");
}
void main()
{

	try
	{
		testMyExcept();
	}
	catch (MyException & e)
	{
		e.what();
	}
	catch (...)
	{
		cout << "未知 类型 " << endl;
	}
	
	system("pause");
}

标准输入test


#include <iostream>
using namespace std;
#include "string"

/*
标准输入流对象cin
	cin.get() //一次只能读取一个字符
	cin.get(一个参数) //读一个字符
	cin.get(三个参数) //可以读字符串
	cin.getline()
	cin.ignore()
	cin.peek()
	cin.putback()
*/


void main71()
{
	char	mybuf[1024];
	int		myInt;
	long	myLong;

	cin >> myInt;

	cin >> myLong;

	cin >> mybuf; // 遇见空格停止接受 数据 

	cout << "myInt:" << myInt << "myLong" << myLong << "mybuf:" << mybuf << endl;

	system("pause");
}

//get()
void main72()
{
	char ch;
	while ( (ch=cin.get() )!= EOF )
	{
		cout << ch << endl;
	}
	system("pause");
}

void main73()
{
	char a, b, c;

	cout << "cin.get(a) 如果缓冲区没有数据,则程序阻塞 \n";
	cin.get(a);
	cin.get(b);
	cin.get(c);

	cout << a << b << c << "因为缓冲区有数据,程序不会阻塞\n";

	cin.get(a).get(b).get(c);

	cout << a << b << c;

	system("pause");
}

//getline函数可以接受 空格
void main74()
{
	char buf1[256];
	char buf2[256];

	cout << "请输入一个字符串 含有多个空格 aa bb cc dd\n";

	cin >> buf1;

	cin.getline(buf2, 256);

	cout << "buf1:" << buf1 << "buf2:" << buf2 << endl; 
	system("pause");
}

void main75()
{
	char buf1[256];
	char buf2[256];

	cout << "请输入一个字符串 含有多个空格aa  bbccdd\n";

	cin >> buf1;
	cin.ignore(20);
	int myint = cin.peek();
	cout << "myint:" << myint << endl; 

	cin.getline(buf2, 256);

	cout << "buf1:" << buf1 << "\nbuf2:" << buf2 << endl; 
	system("pause");
}

//案例:输入的整数和字符串分开处理
int main78() 
{
	cout << "Please, enter a number or a word: ";
	char c = std::cin.get();

	if ( (c >= '0') && (c <= '9') ) //输入的整数和字符串 分开处理
	{
		int n; //整数不可能 中间有空格 使用cin >>n
		cin.putback (c);
		cin >> n;
		cout << "You entered a number: " << n << '\n';
	}
	else
	{
		string str;
		cin.putback (c);
		//cin.getline(str);
		getline (cin, str); // //字符串 中间可能有空格 使用 cin.getline();
		cout << "You entered a word: " << str << '\n';
	}
	system("pause");
	return 0;
}


标准输出


#include <iostream>
using namespace std;
#include <iomanip>

/*

标准输出流对象cout
	cout.flush()
	cout.put()
	cout.write()
	cout.width()
	cout.fill()
	cout.setf(标记)
	*/

/*
manipulator(操作符、控制符)
flush
endl
oct
dec
hex
setbase
setw
setfill
setprecision
…
*/

void main81()
{
	cout << "hello" << endl;
	cout.put('h').put('e').put('l');
	char *p = "hello itcast";

	cout.write(p, strlen(p)) << endl;
	cout.write(p, strlen(p) - 4) << endl;
	cout.write(p, strlen(p) + 4) << endl;
	system("pause");
	return ;
}

void main82()
{
	//使用类成员函数
	cout << "<start>";
	cout.width(30);
	cout.fill('*');
	cout.setf(ios::showbase); //#include <iomanip>
	//cout.setf(ios::internal); //设置
	cout << hex << 123 << "<End>\n";

	cout << endl << endl;
	//

	//使用控制符
	cout << "<Start>" 
		<< setw(30) 
		<< setfill('*') 
		<< setiosflags(ios::showbase) //基数
		<< setiosflags(ios::internal)
		<< hex
		<< 123
		<< "<End>\n"
		<< endl;



	system("pause");
}



int main()
{
	int a;
	cout<<"input a:";
	cin>>a;
	cout<<"dec:"<<dec<<a<<endl; //以十进制形式输出整数
	cout<<"hex:"<<hex<<a<<endl; //以十六进制形式输出整数a
	cout<<"oct:"<<setbase(8)<<a<<endl; //以八进制形式输出整数a
	char *pt="China"; //pt指向字符串"China"
	cout<<setw(10)<<pt<<endl; //指定域宽为,输出字符串
	cout<<setfill('*')<<setw(10)<<pt<<endl; //指定域宽,输出字符串,空白处以'*'填充
	double pi=22.0/7.0; //计算pi值
	//按指数形式输出,8位小数
	cout<<setiosflags(ios::scientific)<<setprecision(8);
	cout<<"pi="<<pi<<endl; //输出pi值
	cout<<"pi="<<setprecision(4)<<pi<<endl; //改为位小数
	cout<<"pi="<<setiosflags(ios::fixed)<<pi<<endl; //改为小数形式输出
	system("pause");
	return 0;
}


int main22( )
{
	double a=123.456,b=3.14159,c=-3214.67;
	cout<<setiosflags(ios::fixed)<<setiosflags(ios::right)<<setprecision(2);
	cout<<setw(10)<<a<<endl;
	cout<<setw(10)<<b<<endl;
	cout<<setw(10)<<c<<endl;
	system("pause");
	return 0;
}


文件的读写


#include <iostream>
using namespace std;
#include "fstream"


void main91()
{
	char* fname = "c:/2aaaaaaafffaaaafff.txt";
	ofstream fout(fname, ios::app); //建一个 输出流对象 和文件关联;  
	if (!fout)
	{
		cout << "打开文件失败" << endl;
		return ;
	}
	fout << "hello....111" << endl;
	fout << "hello....222" << endl;
	fout << "hello....333" << endl;
	fout.close();

	/*
	//读文件
	ifstream fin(fname); //建立一个输入流对象 和文件关联
	char ch;

	while (fin.get(ch))
	{
		cout <<ch ;
	}
	fin.close();
	*/

	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

class Teacher
{
public:
	Teacher()
	{
		age = 33;
		strcpy(name, "");
	}
	Teacher(int _age, char *_name)
	{
		age = _age;
		strcpy(name, _name);
	}
	void printT()
	{
		cout << "age:" << age << "name:" << name <<endl;
	}
protected:
private:
	int	 age;
	char name[32];
};
void main()
{
	char* fname = "c:/11a.dat";
	ofstream fout(fname, ios::binary); //建一个 输出流对象 和文件关联;  
	if (!fout)
	{
		cout << "打开文件失败" << endl;
		return ;
	}
	Teacher t1(31, "t31");
	Teacher t2(32, "t32");
	fout.write((char *)&t1, sizeof(Teacher));
	fout.write((char *)&t2, sizeof(Teacher));
	fout.close();


	//
	ifstream fin(fname); //建立一个输入流对象 和文件关联
	Teacher tmp;

	fin.read( (char*)&tmp,sizeof(Teacher) );
	tmp.printT();

	fin.read( (char*)&tmp,sizeof(Teacher) );
	tmp.printT();
	
	fin.close();

	
	system("pause");
}

第11章stl实战

demo_01_vector基本操作

#include <iostream>
#include <vector>
using namespace std;


//遍历容器
void vector_print01(vector<string> &vec)
{
	//用是数组的方式
	for (int i = 0; i < (int)vec.size(); ++i)
	{
		//输出元素
		//string -> char* 
		//	----- data()
		//  ------c_str()
			 
		cout << vec[i].c_str() << "\t";
	}
	cout << endl;

	//用迭代器方式遍历
	cout << "用迭代器方式遍历" << endl;
	for (vector<string>::iterator it = vec.begin(); it != vec.end(); ++it)
	{
		//打印元素
		cout << (*it).data() << "\t";
	}
	cout << endl;

	//用迭代器方式遍历()逆向

	//指向最后一个元素
	vector<string>::reverse_iterator rit = vec.rbegin();
	while (rit != vec.rend())
	{
		//打印元素
		cout << (*rit).data() << "\t";
		rit++;
	}
	cout << endl;
}

//在容器末尾添加元素
void vector_append(vector<string> &vec)
{
	//添加元素
	vec.push_back("凤姐");
	vec.push_back("芙蓉");
	vec.push_back("如花");
	vec.push_back("石榴姐");
}

////在容器末尾删除元素
void vector_del_back(vector<string> &vec)
{
	//删除
	vec.pop_back();
	//删除
	vec.pop_back();
}

//元素的访问
void vector_modify(vector<string> &vec)
{
	//通过下标[]
	vec[1] = "苍老师";
	//使用at方法
	vec.at(2) = "刘亦菲";
	//front()修改第一元素
	vec.front() = "佟丽娅";
	//back()修改最后一个
	vec.back() = "王菲";

}

void main01()
{
	//默认构造,创建空对象
	vector<string> vecstr;
	//验证是否是空对象
	if (vecstr.empty())
	{
		cout << "这里边没有美女" << endl;
	}
	else
	{
		cout << "这里边有美女" << endl;
	}

	//添加
	vector_append(vecstr);
	vector_print(vecstr);

	////删除
	//vector_del_back(vecstr);
	//vector_print(vecstr);

	//验证resize
	//vecstr.resize(2);
	//vector_print(vecstr);

	//修改
	vector_modify(vecstr);
	vector_print(vecstr);

	//指针解引用
	int  a = 10;
	int *p = &a;
	cout << *p << endl;
}

deque_02容器基本操作

#include <iostream>
#include <deque>
using namespace std;

void main()
{
	//构造空对象
	deque<string> dq;

	//添加元素
	dq.push_back("王宝强");
	dq.push_back("王宝强 -1");
	dq.push_back("王宝强 - 2");
	dq.push_back("王宝强 - 3");

	//插入元素
	dq.insert(dq.begin() + 2, "王保明");

	//遍历容器
	//用迭代器的方式
	cout << "用迭代器的方式" << endl;
	for (deque<string>::iterator it = dq.begin(); it != dq.end(); ++it)
	{
		cout << (*it).data() << "\t";
	}
	cout << endl;

	//用数组的方式
	cout << "用数组的方式" << endl;
	for (int i = 0; i < dq.size(); ++i)
	{
		cout << dq[i].data() << "\t";
	}
	cout << endl;
}

list_3插入删除赋值

#include <iostream>
#include <list>
using namespace std;


//遍历list容器
void list_print(list<string> &ls)
{
	for (list<string>::iterator it = ls.begin(); it != ls.end(); ++it)
	{
		//输出信息
		cout << (*it).data() << "\t";
	}
	cout << endl;
}

//插入元素
void list_insert(list<string> &ls)
{
	
	//在第三个位置插入元素
	list<string>::iterator it = ls.begin();

	//不能进行算术操作
	//it = it + 3;

	it++;
	it++;
	it++;

	ls.insert(it, "霆锋");

}

void main()
{
	//构造一个对象
	list<string> ls(10, "王菲");
	list_print(ls);
	if (ls.empty())
	{
		cout << "我是空容器" << endl;
	}
	else
	{
		cout << "王菲在里边" << endl;
	}

	list_insert(ls);
	list_print(ls);

	//赋值
	list<string> ls1;
	list<string>::iterator it = ls.begin();
	it++;
	it++;
	it++;
	it++;
	ls1.assign(ls.begin(), it);
	list_print(ls1);

	//练习删除
	//可以参照vector

	//ls1.remove("王菲");
	//list_print(ls1);

	ls1.reverse();
	list_print(ls1);
}

list_4容器基本操作01

#include <iostream>
#include <list>
using namespace std;


//遍历list容器
void list_print(list<string> &ls)
{
	for (list<string>::iterator it = ls.begin(); it != ls.end(); ++it)
	{
		//输出信息
		cout << (*it).data() << "\t";
	}
	cout << endl;
}

//往头部尾部添加元素
void list_append(list<string> &ls)
{
	//往尾部添加元素
	ls.push_back("谢霆锋");
	//在头部添加ys
	ls.push_front("窦唯");

	//往尾部删除元素
	ls.pop_back();
	//在头部删除ys
	ls.pop_front();

}

void main()
{
	//构造一个对象
	list<string> ls(10, "王菲");
	list_print(ls);
	if (ls.empty())
	{
		cout << "我是空容器" << endl;
	}
	else
	{
		cout << "王菲在里边" << endl;
	}

	list_append(ls);
	list_print(ls);
}

queue_5基本操作

#include <iostream>
#include <queue>
using namespace std;

typedef struct _student
{
	int id;
	int age;
	string name;
}Student;

//全局变量
Student stu[10];

void main()
{
	//构造空对象
	queue<Student*> que;

	//往队列中放元素
	for (int i = 0; i < sizeof(stu) / sizeof(Student); ++i)
	{
		//初始化元素
		stu[i].id = i;
		stu[i].age = i + 20;
		stu[i].name = "陈冠希";
		//放元素
		que.push(&stu[i]);
	}

	//循环把冠希扔出去
	while (!que.empty())
	{
		//队头元素id
		cout << "队头元素id" << endl;
		cout << que.front()->id << "\t";
		//队尾元素id
		cout << "队尾元素id" << endl;
		cout << endl<< que.back()->id << "\t";
		que.pop();
	}

	//判断队列里是否有冠希
	cout << "冠希的个数:" << que.size() << endl;
}

set_6容器基本操作

#include <iostream>
#include <set>
using namespace std;

void main()
{
	//构造空对象
	set<int> st;

	//插入元素
	st.insert(1);
	st.insert(5);
	st.insert(3);
	st.insert(2);

	//遍历set容器
	for (set<int>::iterator it = st.begin(); it != st.end(); ++it)
	{
		cout << *it << "\t";
	}
	cout << endl;
}

stack_7基本操作

#include <iostream>
#include <stack>
using namespace std;

void main()
{
	//构造空对象
	stack<string> stk;


	//添加元素
	stk.push("橘梨纱");
	stk.push("橘梨纱 - 1");
	stk.push("橘梨纱 - 2");
	stk.push("橘梨纱 - 3");

	//弹出元素
	//循环删除
	while (!stk.empty())
	{
		//打印栈顶元素
		string name = stk.top();
		cout << name.data() << "\t";
		//弹出栈顶元素
		stk.pop();
	}

	//判断stack是否为空
	if (stk.size() == 0)
	{
		cout << "栈为空" << endl;
	}
}

vector_带参数构造_赋值_代码

#include <iostream>
#include <vector>
using namespace std;

//遍历容器
void vector_print(vector<string> &vec)
{

	//用迭代器方式遍历
	cout << "用迭代器方式遍历" << endl;
	for (vector<string>::iterator it = vec.begin(); it != vec.end(); ++it)
	{
		//打印元素
		cout << (*it).data() << "\t";
	}
	cout << endl;

	//用迭代器方式遍历()逆向

}

void main()
{
	//构造
	//添加元素
	vector<string> vec;
	vec.push_back("凤姐");
	vec.push_back("芙蓉");
	vec.push_back("如花");
	vec.push_back("石榴姐");

	//带参数的构造函数
	vector<string> vecstr(vec.begin(), vec.begin()+3);
	cout << "-----------------";
	vector_print(vecstr);

	//拷贝构造
	vector<string> vec2(vecstr);
	cout << "-----VEC2--------";
	vector_print(vec2);


	//练习内容
	//vector<string> vec1(n);
	//vector<string> vec1(n, t);


	//赋值
	vec2.assign(10, "谢霆锋");
	vector_print(vec2);
	//练习assign(beg,end)

	vector<string> vec3;
	vec3 = vec2;
	cout << "vec3 的内容:" << endl;
	vector_print(vec3);

	//交换
	vec3.swap(vec);
	cout << "vec3 的内容:" << endl;
	vector_print(vec3);
	cout << "vec 的内容:" << endl;
	vector_print(vec);
}

vector_元素的插入和删除

#include <iostream>
#include <vector>

using namespace std;

//遍历容器
void vector_print(vector<string> &vec)
{

	//用迭代器方式遍历
	cout << "用迭代器方式遍历" << endl;
	int a;
	for (vector<string>::iterator it = vec.begin(); it != vec.end(); ++it)
	{
		//打印元素
		cout << (*it).data() << "\t";
	}
	cout << endl;

	//用迭代器方式遍历()逆向

}

void main()
{
	//构造
	//添加元素
	vector<string> vec;
	vec.push_back("凤姐");
	vec.push_back("芙蓉");
	vec.push_back("凤姐");
	vec.push_back("如花");
	vec.push_back("凤姐");
	vec.push_back("石榴姐");
	vec.push_back("凤姐");
	vector_print(vec);
	
	////元素的插入
	////插入一个
	//vec.insert(vec.begin() + 1, "干露露");
	//vector_print(vec);
	////练习剩下的连个
	////1 插入n个
	////2. 插入一个区间

	////元素的删除
	//vector<string>::iterator it = vec.erase(vec.begin());
	//cout << "凤姐的下一个美女:" << (*it).data() << endl;
	//vector_print(vec);

	//vec.clear();
	//if (vec.empty())
	//{
	//	cout << "---------------------------=================" << endl;
	//}

	//删除重复元素
	vector<string>::iterator it1 = vec.begin();
	while (it1 != vec.end())
	{
		if ((*it1) == "凤姐")
		{
			//删除当前元素,取到下一个元素的位置
			it1 = vec.erase(it1);
		}
		else
		{
			it1++;
		}
	}
	cout << "新的 美女阵容:" << endl;
	vector_print(vec);
}

第12章stl实战2

demo01-vector基本操作

#include <iostream>
#include <vector>
using namespace std;


//遍历容器vector
void vector_print(vector<int> vec)
{
	if (vec.empty())
	{
		cout << "this a empty vector!" << endl;
		return;
	}

	//用数组方式遍历
	cout << "用数组方式遍历" << endl;
	for (int i = 0; i < (int)vec.size(); ++i)
	{
		cout << vec[i] << "\t";
	}
	cout << endl;

	//用迭代器方式遍历（正向）
	cout << "用迭代器方式遍历（正向）" << endl;
	for (vector<int>::iterator it = vec.begin(); it != vec.end(); ++it)
	{
		cout << *it << "\t";
	}
	cout << endl;

	//用迭代器方式遍历（逆向）
	cout << "用迭代器方式遍历（逆向）" << endl;
	vector<int>::reverse_iterator rit = vec.rbegin();
	while (rit != vec.rend())
	{
		cout << *rit << "\t";
		rit++;
	}
	cout << endl;
}

//在末尾添加元素
void vector_append(vector<int> &vec, int beg, int end)
{
	for (int i = beg; i <= end; i++)
	{
		vec.push_back(i);
	}
}

//删除元素
void vector_del(vector<int> &vec)
{
	//在末尾弹出一个元素
	//vec.pop_back();

	//移除容器的所有数据
	//vec.clear();

	//删除[beg,end)区间的数据，返回下一个数据的位置。
	//vec.erase(vec.begin(), vec.begin()+2);

	//删除pos位置的数据，返回下一个数据的位置。
	//vec.erase(vec.begin());
	vector<int>::iterator it = vec.begin();
	while (it != vec.end())
	{
		if (*it == 3)
		{
			//删除当前位置元素，然会下一个元素的迭代器
			it = vec.erase(it);
		}
		else
		{
			it++;
		}
	}
}

//修改容器元素
void vector_modify(vector<int> &vec)
{
 	//[]
	vec[1] = 3;
	//at
	vec.at(2) = 3;
	//front()
	vec.front() = 3;
	//back()
	vec.back() = 3;

/*
	vector<int> vec_1;
	vector_append(vec_1, 1, 10);
	//区间赋值
	//vec.assign(vec_1.begin(), vec_1.end()-5);

	//将容器 c 重新设置为存储 n 个值为 t 的元素。
	//vec.assign(5, 110);

	//删除容器 c1 的所有元素， 然后将 c2 的元素复制给 c1。 
	// c1 和c2的类型（包括容器类型和元素类型）必须相同
	//vec = vec_1;

	//交换内容：调用完该函数后，c1 中存放的是 c2 原来的元素，c2不变。
	//c1 和 c2 的类型必须相同。
	//该函数的执行速度通常要比将 c2 复制到 c1 的操作快
	vec.swap(vec_1);
	cout << "vec_1:" << endl;
	vector_print(vec_1);
*/
}

//构造函数
vector<int> vector_init()
{
	//默认构造
	vector<int> vecInt;
	if (vecInt.empty())
	{
		cout << "this is a empty vector =====!" << endl;
	}
	vector_append(vecInt, 1, 10);
	vector_print(vecInt);


	////构造函数将[beg, end)区间中的元素拷贝给本身。注意该区间是左闭右开的区间。
	//vector<int> v(vecInt.begin() + 3, vecInt.end() - 3);
	//vector_print(v);

	////创建有n个初始化元素的容器v  
	//vector<int> v1(10);
	//vector_print(v1);
	////构造函数将n个elem拷贝给本身。
	//vector<int> v2(10, 10);
	//vector_print(v2);
	////拷贝构造函数
	//vector<int> v3(vecInt);
	//vector_print(v3);

	return vecInt;
}

//元素插入
void vector_insert(vector<int> &vec)
{
	vector<int> vec_new;
	vector_append(vec_new, 20, 25);
	vector_print(vec_new);

	//在pos位置插入一个elem元素的拷贝，返回新数据的位置。
	//vec.insert(vec.begin()+2, 1024);

	//在pos位置插入n个elem数据，无返回值。
	//vec.insert(vec.begin(), 2, 2048);

	//在pos位置插入[beg,end)区间的数据，无返回值
	vec.insert(vec.begin(), vec_new.begin(), vec_new.end() - 1);

}
void main01()
{
	vector<int> vec = vector_init();

	vector_modify(vec);
	vector_print(vec);

	//vector_insert(vec);
	//vector_print(vec);

	vector_del(vec);
	vector_print(vec);

	////resize
	//vecInt.resize(5);
	//vector_print(vecInt);

	//vecInt.resize(4, 555);
	//vector_print(vecInt);

	////指针当中的解引用
	//int a = 10;
	//int *p = &a;
	//cout << *p << endl;

}

demo02_list基本操作

#include <iostream>
#include <list>
using namespace std;

//容器遍历
void list_print(list<int> ls)
{
	cout << "开始遍历" << endl;
	for (list<int>::iterator it = ls.begin(); it != ls.end(); ++it)
	{
		cout << *it << "\t";
	}
	cout << endl;
}

//在末尾添加元素
void list_append(list<int> &ls, int beg, int end)
{
	for (int i = beg; i <= end; ++i)
	{
		ls.push_back(i);
	}
}

//在头部添加元素
void list_append_h(list<int> &ls, int beg, int end)
{
	for (int i = beg; i <= end; ++i)
	{
		ls.push_front(i);
	}
}


void main02()
{
	//默认构造
	list<int> ls;
	list_append(ls, 1, 10);
	list_print(ls);
	//ls.pop_back();
	//list_print(ls);

	//list_append_h(ls, 20, 25);
	//list_print(ls);
	//ls.pop_front();
	//list_print(ls);

	//ls.front() = 111;
	//ls.back() = 999;
	//list_print(ls);

	//区间
	list<int> ls_1(++ls.begin(), --ls.end());
	list_print(ls_1);

	list<int> ls_2(ls_1);
	cout << "this is ls_2:" << endl;
	list_print(ls_2);

	//赋值
	//ls.assign(ls_2.begin(), ls_2.end());
	//list_print(ls);
	ls.swap(ls_2);
	list_print(ls);
	list_print(ls_2);

	//插入
	ls.insert(ls.begin(), ls_2.begin(), ls_2.end());
	list_print(ls);

	//删除
	//ls.remove(3);
	//list_print(ls);
	list<int>::iterator it = ls.begin();
	while (it != ls.end())
	{
		if (*it == 3)
		{
			it = ls.erase(it);
		}
		else
		{
			it++;
		}
	}
	list_print(ls);

	ls.reverse();
	list_print(ls);
}

demo03_deque基本操作

#include <iostream>
#include <deque>
using namespace std;


//遍历容器deque
void deque_print(deque<int> deq)
{
	if (deq.empty())
	{
		cout << "this a empty deque!" << endl;
		return;
	}

	//用数组方式遍历
	cout << "用数组方式遍历" << endl;
	for (int i = 0; i < (int)deq.size(); ++i)
	{
		cout << deq[i] << "\t";
	}
	cout << endl;

	//用迭代器方式遍历（正向）
	cout << "用迭代器方式遍历（正向）" << endl;
	for (deque<int>::iterator it = deq.begin(); it != deq.end(); ++it)
	{
		cout << *it << "\t";
	}
	cout << endl;

	//用迭代器方式遍历（逆向）
	cout << "用迭代器方式遍历（逆向）" << endl;
	deque<int>::reverse_iterator rit = deq.rbegin();
	while (rit != deq.rend())
	{
		cout << *rit << "\t";
		rit++;
	}
	cout << endl;
}

//在末尾添加元素
void deque_append(deque<int> &deq, int beg, int end)
{
	for (int i = beg; i <= end; i++)
	{
		deq.push_back(i);
	}
}

//删除元素
void deque_del(deque<int> &deq)
{
	//在末尾弹出一个元素
	deq.pop_back();

	//移除容器的所有数据
	//deq.clear();

	//删除[beg,end)区间的数据，返回下一个数据的位置。
	deq.erase(deq.begin(), deq.begin()+2);

	//删除pos位置的数据，返回下一个数据的位置。
	deq.erase(deq.begin());
	deque<int>::iterator it = deq.begin();
	while (it != deq.end())
	{
		if (*it == 3)
		{
			//删除当前位置元素，然会下一个元素的迭代器
			it = deq.erase(it);
		}
		else
		{
			it++;
		}
	}
}

//修改容器元素
void deque_modify(deque<int> &deq)
{
	//[]
	deq[1] = 3;
	//at
	deq.at(2) = 3;
	//front()
	deq.front() = 3;
	//back()
	deq.back() = 3;

	
	deque<int> deq_1;
	deque_append(deq_1, 1, 10);
	//区间赋值
	deq.assign(deq_1.begin(), deq_1.end()-5);

	//将容器 c 重新设置为存储 n 个值为 t 的元素。
	deq.assign(5, 110);

	//删除容器 c1 的所有元素， 然后将 c2 的元素复制给 c1。
	// c1 和c2的类型（包括容器类型和元素类型）必须相同
	deq = deq_1;

	//交换内容：调用完该函数后，c1 中存放的是 c2 原来的元素，c2不变。
	//c1 和 c2 的类型必须相同。
	//该函数的执行速度通常要比将 c2 复制到 c1 的操作快
	deq.swap(deq_1);
	cout << "deq_1:" << endl;
	deque_print(deq_1);

}

//构造函数
deque<int> deque_init()
{
	//默认构造
	deque<int> deqInt;
	if (deqInt.empty())
	{
		cout << "this is a empty deque =====!" << endl;
	}
	deque_append(deqInt, 1, 10);
	deque_print(deqInt);


	//构造函数将[beg, end)区间中的元素拷贝给本身。注意该区间是左闭右开的区间。
	deque<int> v(deqInt.begin() + 3, deqInt.end() - 3);
	deque_print(v);

	//创建有n个初始化元素的容器v  
	deque<int> v1(10);
	deque_print(v1);
	//构造函数将n个elem拷贝给本身。
	deque<int> v2(10, 10);
	deque_print(v2);
	//拷贝构造函数
	deque<int> v3(deqInt);
	deque_print(v3);

	return deqInt;
}

//元素插入
void deque_insert(deque<int> &deq)
{
	deque<int> deq_new;
	deque_append(deq_new, 20, 25);
	deque_print(deq_new);

	//在pos位置插入一个elem元素的拷贝，返回新数据的位置。
	deq.insert(deq.begin()+2, 1024);

	//在pos位置插入n个elem数据，无返回值。
	deq.insert(deq.begin(), 2, 2048);

	//在pos位置插入[beg,end)区间的数据，无返回值
	deq.insert(deq.begin(), deq_new.begin(), deq_new.end() - 1);

}
void main03()
{
	deque<int> deq = deque_init();

	deque_modify(deq);
	deque_print(deq);

	deque_insert(deq);
	deque_print(deq);

	deque_del(deq);
	deque_print(deq);

	//resize
	deq.resize(5);
	deque_print(deq);

	deq.resize(4, 555);
	deque_print(deq);

	deq.clear();
	cout << "deque size = " << deq.size() << endl;
}

demo04_stack基本操作

#include <iostream>
#include <stack>
using namespace std;

//压栈函数
void stack_push(stack<int> &_stack, int beg, int end)
{
	for (int i = beg; i <= end; i++)
	{
		//压栈
		_stack.push(i);
	}
}

//出栈函数
void stack_pop(stack<int> &_stack)
{
	for (int i = 0; i < (int)_stack.size(); ++i)
	{
		cout << _stack.top() << "\t";
		_stack.pop();
		i--;
	}
	cout << endl << "stack size = " << _stack.size() << endl;
}

void main04()
{
	//默认构造
	stack<int> stack_1;
	if (stack_1.empty())
	{
		cout << "this stack is empyt!" << endl;
	}

	stack_push(stack_1, 1, 10);
	cout << "stack size = " << stack_1.size() << endl;

	stack_pop(stack_1);

}

demo05-queue基本操作

#include <iostream>
#include <queue>
using namespace std;

typedef struct _student
{
	int id;
	string name;
	int age;
}Student;

//创建一个学生数组10
Student stu[10];

//进队列函数
void queue_push(queue<Student*> &que)
{
	for (int i = 0; i < sizeof(stu) / sizeof(stu[0]); ++i)
	{
		stu[i].id = i;
		stu[i].name = "Student";
		stu[i].age = i + 20;
		que.push(&stu[i]);
	}
	cout << "queue size = " << que.size()<< endl;
}

//出队列函数
void queue_pop(queue<Student*> &que)
{
	while (!que.empty())
	{
		cout << que.front()->id << "\t";
		que.pop();
	}
	cout << "queue size = " << que.size() << endl;
}

void main05()
{
	//默认构造
	queue<Student*> que;

	queue_push(que);
	queue_pop(que);
}

demo06_set和multset基本操作

#include <iostream>
#include <set>
#include <functional>
#include <string>
using namespace std;

//定义学生类
class Student
{
public:
	Student(int arg_id, int arg_age, string arg_name)
	{
		id = arg_id;
		age = arg_age;
		name = arg_name;
	}

	int get_id() const 
	{
		return id;
	}

private:
	int id;
	int age;
	string name;
};

//定义函数对象
struct FuncStudent
{
	bool operator()(const Student& stu1, const Student& stu2)
	{
		return stu1.get_id() < stu2.get_id();
	}
};



//set的遍历(less)
void set_print(set<int> st)
{
	cout << "set开始遍历 - less：" << endl;
	for (set<int>::iterator it = st.begin(); it != st.end(); ++it)
	{
		cout << *it << "\t";
	}
	cout << endl;
}

//set的遍历(greater)
void set_print(set<int, greater<int> > st)
{
	cout << "set开始遍历 - less：" << endl;
	for (set<int, greater<int> >::iterator it = st.begin(); it != st.end(); ++it)
	{
		cout << *it << "\t";
	}
	cout << endl;
}

//set的遍历(自定义排序)
void set_print(set<Student, FuncStudent> st)
{
	cout << "set开始遍历 - 自定义：" << endl;
	for (set<Student, FuncStudent>::iterator it = st.begin(); it != st.end(); ++it)
	{
		cout << it->get_id() << "\t";
	}
	cout << endl;
}



//multset的遍历
void multset_print(multiset<int> st)
{
	cout << "multset开始遍历：" << endl;
	for (multiset<int>::iterator it = st.begin(); it != st.end(); ++it)
	{
		cout << *it << "\t";
	}
	cout << endl;
}

//set插入元素(less)
void set_insert(set<int> &st, int *array, int size)
{
	int size1 = sizeof(array);
	for (int i = 0; i < size; ++i)
	{
		st.insert(array[i]);
	}
}

//set插入元素(greater)
void set_insert(set<int, greater<int> > &st, int *array, int size)
{
	int size1 = sizeof(array);
	for (int i = 0; i < size; ++i)
	{
		st.insert(array[i]);
	}
}

//multset插入元素
void multset_insert(multiset<int> &st, int* array, int size)
{
	for (int i = 0; i < size; ++i)
	{
		st.insert(array[i]);
	}
}

//set 的查找
void set_find(set<int> &st)
{
	//find用法
	set<int>::iterator it = st.find(25);
	cout << "find *it = " << *it << endl;

	//lower_bound
	it = st.lower_bound(12); //>=elem
	cout << "lower_bound = " << *it << endl;

	//upper_bound
	it = st.upper_bound(12); //>elem
	cout << "upper_bound = " << *it << endl;

	//equal_range T1>= T2 >
	pair<set<int>::iterator, set<int>::iterator> _pair = st.equal_range(12);
	cout << "T1 = " << *_pair.first << endl;
	cout << "T2 =" << *_pair.second << endl;

}

void main06()
{
	//默认构造
	set<int> st;
	int array[] = { 2, 25, 12, 21, 26, 1 };
	set_insert(st, array, sizeof(array) / sizeof(int));
	set_print(st);
	//拷贝构造
	set<int> st1(st);
	//=
	set<int> st2;
	st2 = st1;
	int array1[] = {0, 10, 100, 1000};
	set_insert(st2, array, sizeof(array1) / sizeof(int));

	//multset默认构造
	multiset<int> mult;
	int array2[] = { 2, 25, 12, 2, 26, 1 };
	multset_insert(mult, array2, sizeof(array2) / sizeof(int));
	multset_insert(mult, array2, sizeof(array2) / sizeof(int));

	cout << "multi size = " << mult.count(2) << endl;
	//set_print(st2);
	//multset_print(mult);

	////交换
	//st.swap(st2);
	//set_print(st);
	//set_print(st2);

	//greater
	//构造
	set<int, greater<int> > gst;
	int array_g[] = { 2, 25, 12, 21, 26, 1 };
	set_insert(gst, array_g, sizeof(array_g) / sizeof(int));
	set_print(gst);

	//学生类型的元素的set集合
	set<Student, FuncStudent> stuSt;
	for (int i = 10; i > 0; --i)
	{
		Student stu(i, i + 20, "Student");
		stuSt.insert(stu);
	}
	set_print(stuSt);

	set_find(st);

}

demo07-map和multimap的基本操作

#include <iostream>
#include <map>
#include <functional>
using namespace std;



//遍历map容器
void map_print(map<int, string> mp)
{
	for (map<int, string>::iterator it = mp.begin(); it != mp.end(); ++it)
	{
		cout << "key = " << it->first << "		value = " << it->second.data() << endl;
	}
	cout << "print over!" <<endl;
}

//遍历map容器(greater)
void map_print(map<int, string, greater<int> > mp)
{
	cout << "排序遍历" << endl;
	for (map<int, string, greater<int> >::iterator it = mp.begin(); it != mp.end(); ++it)
	{
		cout << "key = " << it->first << "		value = " << it->second.data() << endl;
	}
	cout << "print over!" << endl;
}


//插入数据函数
void map_insert(map<int, string> &mp)
{
	//通过pair的方式插入对象
	mp.insert(pair<int, string>(3, "小张"));
	mp.insert(pair<int, string>(0, "小张-1"));
	mp.insert(pair<int, string>(5, "小张-2"));
	mp.insert(pair<int, string>(7, "小张-3"));
	//key已存在的，继续插入相同的key，插入失败
	pair<map<int, string>::iterator, bool> pr = mp.insert(pair<int, string>(7, "我是校长 -- 111"));
	if (pr.second == false)
	{
		cout << "insert element fail ===== " << endl;
	}
	else
	{
		cout << "insert element ok! ===== " << endl;
	}





	//通过value_type的方式插入对象
	//mp.insert(map<int, string>::value_type(1, "小李"));
	//mp.insert(map<int, string>::value_type(23, "红红-1"));
	//mp.insert(map<int, string>::value_type(24, "红红-2"));
	//mp.insert(map<int, string>::value_type(32, "红红-3"));
	//mp.insert(map<int, string>::value_type(52, "红红-4"));
	////key已存在的，继续插入相同的key，插入失败
	//pair<map<int, string>::iterator, bool> pr = mp.insert(map<int, string>::value_type(252, "我是大红红====="));

	//if (pr.second == false)
	//{
	//	cout << "insert element fail ===== " << endl;
	//}
	//else
	//{
	//	cout << "insert element ok! ===== " << endl;
	//}


	//三、通过数组的方式插入值
	//mp[333] = "333";
	//mp[222] = "222";
	//mp[111] = "111";
	//mp[444] = "444";
	////key已存在的，继续插入相同的key，覆盖原value值
	//mp[333] = "我是333";


}

//插入数据函数(greater)
void map_insert(map<int, string, greater<int> > &mp)
{
	//通过pair的方式插入对象
	mp.insert(pair<int, string>(3, "小张"));
	mp.insert(pair<int, string>(0, "小张-1"));
	mp.insert(pair<int, string>(5, "小张-2"));
	mp.insert(pair<int, string>(7, "小张-3"));
}

void main07()
{
	//默认构造
	map<int, string> mp;

	map_insert(mp);
	map_print(mp);

	map<int, string, greater<int> > mp_g;
	map_insert(mp_g);
	map_print(mp_g);

	//查找
	map<int, string>::iterator it = mp.find(11);
	if (it != mp.end())
	{
		cout << "find element = " << it->second.data() << endl;
	}
	else
	{
		cout << "find fail ----------------" << endl;
	}
	cout << "cout = " << mp.count(252);


	it = mp.begin();
	cout << "begin value = " << it->second.data() << endl;
	it = mp.erase(it);
	cout << "begin value = " << it->second.data() << endl;
	map_print(mp);
}

demo08-multimap案例

//公司有销售部（sale）（员工2名）、技术研发部（development）（1人）、财务部（Financial）（2人）
//人员信息有：姓名，年龄，电话、工资等组成
//通过 multimap进行 信息的插入、保存、显示

#include <iostream>
#include <map>
using namespace std;

//员工信息
typedef struct _prsion
{
	string name;
	int age;
	string tel;
	int salary;
}Persion;


//人员信息插入
void person_info_insert(multimap<string, Persion> &mp)
{
	//销售部（sale）
	Persion per1, per2;
	per1.age = 20;
	per1.name = "李磊";
	per1.salary = 3000;
	per1.tel = "1234567";
	per2.age = 20;
	per2.name = "李磊-1";
	per2.salary = 3000;
	per2.tel = "1234567";
	mp.insert(pair<string, Persion>("sale", per1));
	mp.insert(pair<string, Persion>("sale", per2));


	//技术研发部（development）
	Persion per3, per4;
	per3.age = 20;
	per3.name = "红红";
	per3.salary = 3000;
	per3.tel = "1234567";
	per4.age = 20;
	per4.name = "大红红";
	per4.salary = 3000;
	per4.tel = "1234567";
	mp.insert(multimap<string, Persion>::value_type("development", per3));
	mp.insert(multimap<string, Persion>::value_type("development", per4));


	//财务部（Financial）
	Persion per5, per6;
	per5.age = 20;
	per5.name = "韩梅梅";
	per5.salary = 3000;
	per5.tel = "1234567";
	per6.age = 20;
	per6.name = "韩梅梅-1";
	per6.salary = 3000;
	per6.tel = "1234567";
	mp.insert(pair<string, Persion>("Financial", per5));
	mp.insert(pair<string, Persion>("Financial", per6));
}


//遍历所有元素
void persion_print(multimap<string, Persion> &mp)
{
	for (multimap<string, Persion>::iterator it = mp.begin(); it != mp.end(); ++it)
	{
		cout << "persion's name is  = " << it->second.name.data() << endl;
	}
	cout << endl;
}

//按部门打印员工信息
void persion_info_print_bumen(multimap<string, Persion> &mp, string bumen)
{
	cout << "print bumen - " << bumen.data() << endl;

	for (multimap<string, Persion>::iterator it = mp.begin(); it != mp.end(); ++it)
	{
		if (it->first == bumen)
		{
			cout << "persion's name is  = " << it->second.name.data() << endl;
		}
	}
	cout << endl;
}

void main08()
{
	multimap<string, Persion> mp;
	person_info_insert(mp);
	persion_print(mp);

	persion_info_print_bumen(mp, "sale");
	persion_info_print_bumen(mp, "development");
	persion_info_print_bumen(mp, "Financial");
}


demo9-算法函数

#include <iostream>
#include <algorithm>
#include <numeric>
#include <functional>
#include <vector>
#include <list>
using namespace std;

//------------------------查找算法函数---------------------------------------------
//查找相邻的重复元素,返回两个元素总第一个元素的迭代器
void main_adjacent_find()
{
	vector<string> vecStr;
	vecStr.push_back("郭靖");
	vecStr.push_back("黄蓉1");
	vecStr.push_back("黄蓉");
	vecStr.push_back("欧阳锋");

	vector<string>::iterator it = adjacent_find(vecStr.begin(), vecStr.end());
	if (it != vecStr.end())
	{
		cout << "重复元素:" << (*it).data() << endl;
	}
	else
	{
		cout << "没有找到重复元素" << endl;
	}
}

//二分法查找
//在有序序列中查找value,找到返回true
//无序序列中不可使用
void main_binary_search()
{
	vector<string> vecStr;
	vecStr.push_back("郭靖");
	vecStr.push_back("黄蓉");
	vecStr.push_back("杨康");

	bool bl = binary_search(vecStr.begin(), vecStr.end(), "黄蓉");
	if (bl)
	{
		cout << "binary_search find ok" << endl;
	}
	else
	{
		cout << "binary_search find fail" << endl;
	}
}

//将输入的数与标记范围内的数比较,返回相等的个数
void main_count()
{
	vector<string> vecStr;
	vecStr.push_back("a郭靖");
	vecStr.push_back("b黄蓉");
	vecStr.push_back("c杨康");
	vecStr.push_back("d郭靖");
	vecStr.push_back("e黄蓉");
	vecStr.push_back("f杨康");
	int nCount = count(vecStr.begin(), vecStr.end(), "郭靖");
	cout << "count find number:" << nCount << endl;
}

bool find_hero(string name)
{
	if (name < "f杨康")
	{
		return true;
	}
	return false;
}
//在查找范围内自定义查找规则,返回符合条件的个数
void main_count_if()
{
	vector<string> vecStr;
	vecStr.push_back("a郭靖");
	vecStr.push_back("b黄蓉");
	vecStr.push_back("c杨康");
	vecStr.push_back("d郭靖");
	vecStr.push_back("e黄蓉");
	vecStr.push_back("f杨康");
	int nCount = count_if(vecStr.begin(), vecStr.end(), find_hero);
	cout << "大英雄的个数" << nCount << endl;
}

//查找指定元素
void main_find()
{
	vector<string> vecStr;
	vecStr.push_back("a郭靖");
	vecStr.push_back("b黄蓉");
	vecStr.push_back("c杨康");
	vecStr.push_back("d郭靖");
	vecStr.push_back("e黄蓉");
	vecStr.push_back("f杨康");
	vector<string>::iterator it = find(vecStr.begin(), vecStr.end(), "a郭靖");
	if (it != vecStr.end())
	{
		cout << "find 函数,找到指定人物:" << (*it).data() << endl;
	}
	else
	{
		cout << "find 函数,没找到指定人物: *+*" << endl;
	}
}

bool find_huaidan(string name)
{
	if (name > "e黄蓉")
	{
		return true;
	}
	return false;
}

//查找指定条件元素
void main_find_if()
{
	vector<string> vecStr;
	vecStr.push_back("a郭靖");
	vecStr.push_back("b黄蓉");
	vecStr.push_back("c杨康");
	vecStr.push_back("d郭靖");
	vecStr.push_back("e黄蓉");
	vecStr.push_back("f杨康");
	vector<string>::iterator it = find_if(vecStr.begin(), vecStr.end(), find_huaidan);
	if (it != vecStr.end())
	{
		cout << "find 函数,找到大坏蛋:" << (*it).data() << endl;
	}
	else
	{
		cout << "find 函数,没找到大坏蛋: *+*" << endl;
	}
}

//-------------------------排序算法函数----------------------------

//遍历list容器
void list_print(list<string> &ls)
{
	for (list<string>::iterator it = ls.begin(); it != ls.end(); ++it)
	{
		cout << (*it).c_str() << "\t";
	}
	cout << endl;
}

//遍历vector容器
void vector_print(vector<string> &vec)
{
	for (vector<string>::iterator it = vec.begin(); it != vec.end(); ++it)
	{
		cout << (*it).data() << "\t";
	}
	cout << endl;
}

//合并两个有序序列,存到另一个序列
void main_merge()
{
	list<string> listStr1;
	list<string> listStr2;
	list<string> listStr3;

	//在listStr1中添加元素
	listStr1.push_back("1杨幂");
	listStr1.push_back("2刘亦菲");
	listStr1.push_back("3范冰冰");
	listStr1.push_back("4刘诗诗");

	//在listStr2中添加元素
	listStr2.push_back("1凤姐");
	listStr2.push_back("2芙蓉姐姐");
	listStr2.push_back("3如花妹妹");

	//设置listStr3大小
	listStr3.resize(listStr1.size() + listStr2.size());
	
	//合并
	merge(listStr1.begin(), listStr1.end(), listStr2.begin(), listStr2.end(), listStr3.begin());
	cout << "新的明星组合:" << endl;
	list_print(listStr3);
}

//对指定范围内的元素随机调整次序
void main_random_shuffle()
{
	vector<string> vecStr;
	//添加元素
	vecStr.push_back("a郭靖");
	vecStr.push_back("b黄蓉");
	vecStr.push_back("c杨康");
	vecStr.push_back("d郭靖");
	vecStr.push_back("e黄蓉");
	vecStr.push_back("f杨康");

	//随机调整次序
	random_shuffle(vecStr.begin(), vecStr.end());

	//遍历容器
	cout << "按照新的次序打印容器内元素:" << endl;
	vector_print(vecStr);
}

bool compare_func(string &str1, string &str2)
{
	if (str1 > str2)
	{
		return true;
	}
	return false;
}

//对指定范围内元素进行排序
void main_sort()
{
	//简单数据类型
	vector<int> vecInt;
	vecInt.push_back(3);
	vecInt.push_back(13);
	vecInt.push_back(30);
	vecInt.push_back(2);
	sort(vecInt.begin(), vecInt.end(), less<int>());
	cout << "默认排序结果:" << endl;
	for (vector<int>::iterator it = vecInt.begin(); it != vecInt.end(); ++it)
	{
		cout << *it << "\t";
	}
	cout << endl;


	vector<string> vecStr;

	//在vecStr中添加元素
	vecStr.push_back("杨幂");
	vecStr.push_back("刘亦菲");
	vecStr.push_back("范冰冰");
	vecStr.push_back("刘诗诗");

	sort(vecStr.begin(), vecStr.end());
	cout << "明星排名:" << endl;
	vector_print(vecStr);

	sort(vecStr.begin(), vecStr.end(), compare_func);
	cout << "新的明星排名:" << endl;
	vector_print(vecStr);
}

//反转指定范围内元素
void main_reverse()
{
	vector<string> vecStr;
	vecStr.push_back("a郭靖");
	vecStr.push_back("b黄蓉");
	vecStr.push_back("c杨康");
	vecStr.push_back("d郭靖");
	vecStr.push_back("e黄蓉");
	vecStr.push_back("f杨康");

	//反转容器内元素顺序
	reverse(vecStr.begin(), vecStr.end());
	cout << "反转容器内大侠们的位置:" << endl;
	vector_print(vecStr);
}

//---------------常用的拷贝和替换算法--------------------

//容器内元素拷贝到另一个容器
void main_copy()
{
	vector<string> vecStr;

	//在vecStr中添加元素
	vecStr.push_back("杨幂");
	vecStr.push_back("刘亦菲");
	vecStr.push_back("范冰冰");
	vecStr.push_back("刘诗诗");

	//构造容器vecStr2
	vector<string> vecStr2(vecStr.size());
	//容器内容拷贝
	copy(vecStr.begin(), vecStr.end(), vecStr2.begin());
	//打印容器vecStr2
	cout << "容器vecStr2 中的元素为:" << endl;
	vector_print(vecStr2);
}

//容器内指定范围内指定值的替换
void main_replace()
{
	vector<string> vecstr;
	//在vecstr中添加元素
	vecstr.push_back("凤姐");
	vecstr.push_back("芙蓉姐姐");
	vecstr.push_back("如花妹妹");

	//替换
	replace(vecstr.begin(), vecstr.end(), "凤姐", "范爷");
	//打印容器元素
	cout << "替换之后的美女阵容:" << endl;
	vector_print(vecstr);
}

bool replace_func(string name)
{
	if (name > "范爷")
	{
		return true;
	}
	return false;
}

//将指定范围内操作结果为true的元素,替换为新值
void main_replace_if()
{
	vector<string> vecstr;
	//在vecstr中添加元素
	vecstr.push_back("范爷");
	vecstr.push_back("芙蓉姐姐");
	vecstr.push_back("如花妹妹");

	//替换符合条件的元素
	replace_if(vecstr.begin(), vecstr.end(), replace_func, "佟丽娅");
	//打印容器元素
	cout << "新的美女阵容:" << endl;
	vector_print(vecstr);
}

//交换连个容器内元素
void main_swap()
{
	vector<string> vecstr;
	//在vecstr中添加元素
	vecstr.push_back("刘亦菲");
	vecstr.push_back("刘诗诗");
	vecstr.push_back("佟丽娅");
	vecstr.push_back("王菲");

	vector<string> vecstr1;
	//在vecstr1中添加元素
	vecstr1.push_back("谢霆锋");
	vecstr1.push_back("陈冠希");
	vecstr1.push_back("吴彦祖");

	//交换
	swap(vecstr, vecstr1);

	//打印连个交换后的容器内容
	cout << "原来的美女阵容:" << endl;
	vector_print(vecstr);
	cout << "原来的帅哥阵容" << endl;
	vector_print(vecstr1);
}

//--------------算术和生成算法函数----------------
void main_accumulate()
{
	vector<int> vecInt;
	vecInt.push_back(1);
	vecInt.push_back(10);
	vecInt.push_back(100);

	//求和
	int nCount = accumulate(vecInt.begin(), vecInt.end(), 0);
	//打印结果
	cout << "容器元素求和:" << nCount << endl;
}

void main_fill()
{
	vector<string> vecstr;
	//在vecstr中添加元素
	vecstr.push_back("凤姐");
	vecstr.push_back("芙蓉姐姐");
	vecstr.push_back("如花妹妹");
	vecstr.push_back("苍老师");
	vecstr.push_back("橘梨纱");


	//给指定范围元素赋值
	fill(vecstr.begin(), vecstr.begin()+3, "松岛枫");
	//打印新元素
	cout << "剔除伪美女之后的养眼阵容:" << endl;
	vector_print(vecstr);
}

//----------------常用的集合算法函数------------------
void main_set_union()
{
	vector<string> vecstr;
	//在vecstr中添加元素
	vecstr.push_back("1苍老师");
	vecstr.push_back("3橘梨纱");
	vecstr.push_back("5刘诗诗");
	vecstr.push_back("7佟丽娅");

	vector<string> vecstr1;
	//在vecstr1中添加元素
	vecstr1.push_back("2吴彦祖");
	vecstr1.push_back("4谢霆锋");
	vecstr1.push_back("6周杰伦");

	//求并集
	vector<string> vecstr3(vecstr.size() + vecstr1.size());
	set_union(vecstr.begin(), vecstr.end(), vecstr1.begin(), vecstr1.end(), vecstr3.begin());
	//打印并集
	cout << "明星大杂烩:" << endl;
	vector_print(vecstr3);
}
//-----------------自己练习set_intersection, set_different函数------------

//-----------------常用的遍历函数--------------------

//遍历函数
void show_func(const string &str)
{
	if (str > "2吴彦祖")
	{
		cout << str.data() << "\t";
	}
	else
	{
		cout << "呵呵..." << "\t";
	}
}
//用指定函数依次对指定范围内所有元素进行迭代访问
void main_for_each()
{
	vector<string> vecstr;
	//在vecstr中添加元素
	vecstr.push_back("1苍老师");
	vecstr.push_back("3王菲");
	vecstr.push_back("5刘诗诗");
	vecstr.push_back("7佟丽娅");
	vecstr.push_back("2吴彦祖");
	vecstr.push_back("4谢霆锋");
	vecstr.push_back("6周杰伦");

	//遍历
	cout << "用 for_each 遍历容器:" << endl;
	for_each(vecstr.begin(), vecstr.end(), show_func);
	cout << endl;
}

//遍历并修改容器元素函数
string& transform_func(string& str)
{
	//if (str > "2吴彦祖")
	{
		str = str + "AA";
	}
	cout << str.data() << "\t";
	return str;
}

//遍历容器,并对容器元素进行修改
void main_transform()
{
	vector<string> vecstr;
	//在vecstr中添加元素
	vecstr.push_back("1苍老师");
	vecstr.push_back("3王菲");
	vecstr.push_back("5刘诗诗");
	vecstr.push_back("7佟丽娅");
	vecstr.push_back("2吴彦祖");
	vecstr.push_back("4谢霆锋");
	vecstr.push_back("6周杰伦");
	
	vector<string> vecstr1(10);
	//遍历并修改元素
	cout << "遍历并修改元素内容" << endl;
	transform(vecstr.begin(), vecstr.end(), vecstr1.begin(), transform_func);
	cout << endl;

	vector_print(vecstr);
	cout << endl;  
	vector_print(vecstr1);
}

void main()
{
	//查找相邻的重复元素,返回两个元素总第一个元素的迭代器
	main_adjacent_find();
	//二分法查找
	main_binary_search();
	//将输入的数与标记范围内的数比较,返回相等的个数
	main_count();
	//在查找范围内自定义查找规则,返回符合条件的个数
	main_count_if();
	//在范围内查找指定值
	main_find();
	//在范围内根据条件进行查找
	main_find_if();

	//有序容器合并
	main_merge();

	//容器元素排序
	main_sort();

	//对指定范围内元素随机调整次序
	main_random_shuffle();

	//反转指定范围内的元素
	main_reverse();

	//容器间元素拷贝
	main_copy();

	//容器内元素替换
	main_replace();

	//容器内符合条件的元素的替换
	main_replace_if();

	//交换两个容器内元素
	main_swap();

	//容器元素求和
	main_accumulate();

	//将输入值赋给指定范围元素
	main_fill();

	//容器并集
	main_set_union();

	//自定义遍历
	main_for_each();

	//遍历并对元素进行修改
	main_transform();
}

第13章数据结构day01

dm01_线性表顺序存储设计与实现框架测试.c

#define  _CRT_SECURE_NO_WARNINGS 
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include "seqlist.h"

typedef struct _Teacher
{
	char name[32];
	int age ;
}Teacher;

void main()
{
	int			ret = 0, i = 0;
	SeqList *	list;

	Teacher t1, t2, t3;
	t1.age = 31;
	t2.age = 32;
	t3.age = 33;

	list = SeqList_Create(10);

	//思考1: 如何实现 链表的api(链表的算法) 和 具体的数据分离
	//思考2: 链表库(业务逻辑)  测试程序的业务逻辑  结点的生命周期 归谁管?

	ret = SeqList_Insert(list, (SeqListNode *)&t1, 0);  //头插法
	ret = SeqList_Insert(list, (SeqListNode *)&t2, 0);  //头插法
	ret = SeqList_Insert(list, (SeqListNode *)&t3, 0);  //头插法

	//遍历链表
	for (i=0; i<SeqList_Length(list); i++ )
	{
		Teacher *tmp = (Teacher *)SeqList_Get(list, i); //获取链表结点
		if (tmp == NULL)
		{
			printf("func SeqList_Get() err:%d \n ", ret);
			return ;
		}
		printf("age:%d \n", tmp->age);
	}

	//销毁链表
	while (SeqList_Length(list) > 0)
	{
		Teacher *tmp  =  (Teacher *)SeqList_Delete(list, 0);//
		if (tmp == NULL)
		{
			printf("func SeqList_Get() err:%d \n ", ret);
			return ;
		}
		printf("age:%d \n", tmp->age);
	}

	SeqList_Destroy(list);

	system("pause");

	return ;
}

seqlist.c.

#define  _CRT_SECURE_NO_WARNINGS 
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include "seqlist.h"


//用数组来模拟线性表
typedef struct _tag_SeqList
{
	int		capacity;
	int		length;
	//int *node[100];
	int		**node;  //int node[capacity] //
					//int *node[capacity];

	//int *node; //   int node[i]===> *(node+i)
}TSeqList;


//链表 创建
SeqList* SeqList_Create(int capacity) //O(1)
{
	int			ret;
	TSeqList	*tmp = NULL;
	tmp = (TSeqList *)malloc(sizeof(TSeqList));
	if (tmp == NULL)
	{
		ret =1;
		printf("func SeqList_Create() err :%d \n", ret);
		return NULL;
	}
	memset(tmp, 0, sizeof(TSeqList));
	tmp->capacity = capacity;
	tmp->length = 0;
	tmp->node = (int **)malloc(sizeof(void *) * capacity);
	if (tmp->node == NULL)
	{
		ret = 2;
		printf("func SeqList_Create() malloc err :%d \n", ret);
		return NULL;
	}
	memset(tmp->node, 0, sizeof(void *) * capacity);

	return tmp;
}

//链表 创建
int SeqList_Create2(int capacity, SeqList**handle)
{
	int			ret = 0;
	TSeqList	*tmp = NULL;
	tmp = (TSeqList *)malloc(sizeof(TSeqList));
	if (tmp == NULL)
	{
		ret =1;
		printf("func SeqList_Create2() err :%d \n", ret);
		return ret;
	}
	memset(tmp, 0, sizeof(TSeqList));
	tmp->capacity = capacity;
	tmp->length = 0;
	tmp->node = (int **)malloc(sizeof(void *) * capacity);
	if (tmp->node == NULL)
	{
		ret = 2;
		printf("func SeqList_Create2() malloc err :%d \n", ret);
		return ret;
	}

	*handle = tmp;
	return ret;
}

//链表 销毁
void SeqList_Destroy(SeqList* list)  //O(1)
{
	TSeqList	*tmp = NULL;
	if (list == NULL)
	{
		return ;
	}

	tmp = (TSeqList *)list;

	if (tmp->node != NULL)
	{
		free(tmp->node);
	}
	free(tmp);
	return ;
}

////链表 清空
void SeqList_Clear(SeqList* list) //O(1)
{
	TSeqList	*tmp = NULL;
	if (list == NULL)
	{
		return ;
	}

	tmp = (TSeqList *)list;
	tmp->length = 0;
	memset(tmp->node, 0, (tmp->capacity * sizeof(void *)) );

	return ;
}

//链表 长度
int SeqList_Length(SeqList* list) //O(1)
{
	TSeqList	*tmp = NULL;
	if (list == NULL)
	{
		return -1;
	}
	tmp = (TSeqList *)list;

	return tmp->length;
}


//链表 容量 
int SeqList_Capacity(SeqList* list) //O(1)
{
	TSeqList	*tmp = NULL;
	if (list == NULL)
	{
		return -1;
	}
	tmp = (TSeqList *)list;
	return tmp->capacity;
}

//链表 在某一个位置 插入元素
int SeqList_Insert(SeqList* list, SeqListNode* node, int pos)  //O(n)
{
	TSeqList	*tList = NULL;
	int i = 0;
	if (list == NULL ||  node==NULL)
	{
		return -1;
	}
	tList = (TSeqList *)list;
	//如果满了 
	if (tList->length >= tList->capacity)
	{
		return -2;
	}

	//pos位置的容错处理
	if (pos > tList->length )
	{
		pos = tList->length;
	}

	for (i=tList->length; i>pos; i--)  //n
	{
		tList->node[i] = tList->node[i-1];
	}

	tList->node[i] = (int* )node; //ok
	tList->length ++;

	return 0;
}

//获取某一个位置的链表结点
SeqListNode* SeqList_Get(SeqList* list, int pos)  //O(1)
{
	TSeqList	*tList = NULL;
	SeqListNode *tmp = NULL;

	tList = (TSeqList *)list;

	if (list == NULL || pos<0 || pos >=tList->length )
	{
		return NULL;
	}
	tmp = tList->node[pos];

	return tmp;
}

//删除某一个位置的结点
SeqListNode* SeqList_Delete(SeqList* list, int pos)  ////O(n)
{
	int			i = 0;
	TSeqList	*tList = NULL;
	SeqListNode *tmp = NULL; 

	tList = (TSeqList *)list;
	if (list == NULL || pos <0 || pos >= tList->length)
	{
		return NULL;
	}
	tmp = tList->node[pos];

	// pos = 3
	for (i=pos+1; i<tList->length; i++)
	{
		tList->node[i-1] = tList->node[i];

	}
	tList->length --;
	return tmp;
}



seqlist.cpp

#ifndef  __MY_SEQLIST_H__ 
#define __MY_SEQLIST_H__

typedef void SeqList;
typedef void SeqListNode;

//链表 创建
SeqList* SeqList_Create(int capacity);

//链表 销毁
void SeqList_Destroy(SeqList* list);

////链表 清空
void SeqList_Clear(SeqList* list);

//链表 长度
int SeqList_Length(SeqList* list);


//链表 容量 
int SeqList_Capacity(SeqList* list);

//链表 在某一个位置 插入元素
int SeqList_Insert(SeqList* list, SeqListNode* node, int pos);

//获取某一个位置的链表结点
SeqListNode* SeqList_Get(SeqList* list, int pos);

//删除某一个位置的结点
SeqListNode* SeqList_Delete(SeqList* list, int pos);


#endif  //__MY_SEQLIST_H__





第14章数据结构day02

双向链表

dlinklistmain01.c

#include <stdio.h>
#include <stdlib.h>
#include "DLinkList.h"

struct Value
{
	DLinkListNode node;
	int v;
};

int main()
{
	int i = 0;
	DLinkList* list = DLinkList_Create();
	struct Value* pv = NULL;
	struct Value v1, v2, v3, v4, v5;

	v1.v = 1;	v2.v = 2;	v3.v = 3;	v4.v = 4;
	v5.v = 5;

	DLinkList_Insert(list, (DLinkListNode*)&v1, DLinkList_Length(list));
	DLinkList_Insert(list, (DLinkListNode*)&v2, DLinkList_Length(list));
	DLinkList_Insert(list, (DLinkListNode*)&v3, DLinkList_Length(list));
	DLinkList_Insert(list, (DLinkListNode*)&v4, DLinkList_Length(list));
	DLinkList_Insert(list, (DLinkListNode*)&v5, DLinkList_Length(list));

	for(i=0; i<DLinkList_Length(list); i++)
	{
		pv = (struct Value*)DLinkList_Get(list, i);

		printf("%d\n", pv->v);
	}

	printf("\n");

	DLinkList_Delete(list, DLinkList_Length(list)-1);
	DLinkList_Delete(list, 0);
	//DLinkList_Delete(list, 3);
	

	for(i=0; i<DLinkList_Length(list); i++)
	{
		pv = (struct Value*)DLinkList_Next(list);

		printf("%d\n", pv->v);
	}

	printf("\n");

	DLinkList_Reset(list);
	DLinkList_Next(list);

	pv = (struct Value*)DLinkList_Current(list);

	printf("%d\n", pv->v);

	DLinkList_DeleteNode(list, (DLinkListNode*)pv);

	pv = (struct Value*)DLinkList_Current(list);

	printf("%d\n", pv->v);

	DLinkList_Pre(list);

	pv = (struct Value*)DLinkList_Current(list);

	printf("%d\n", pv->v);

	printf("Length: %d\n", DLinkList_Length(list));

	DLinkList_Destroy(list);
	system("pause");
	return 0;
}


dlinklist.h

#ifndef _MY_DLINKLIST_H_
#define _MY_DLINKLIST_H_

typedef void DLinkList;
/*
typedef struct _tag_DLinkListNode DLinkListNode;
struct _tag_DLinkListNode
{
	DLinkListNode* next;
	DLinkListNode* pre;
};
*/

typedef struct _tag_DLinkListNode
{
	struct _tag_DLinkListNode* next;
	struct _tag_DLinkListNode * pre;
}DLinkListNode;

DLinkList* DLinkList_Create();

void DLinkList_Destroy(DLinkList* list);

void DLinkList_Clear(DLinkList* list);

int DLinkList_Length(DLinkList* list);

int DLinkList_Insert(DLinkList* list, DLinkListNode* node, int pos);

DLinkListNode* DLinkList_Get(DLinkList* list, int pos);

DLinkListNode* DLinkList_Delete(DLinkList* list, int pos);

//-- add
DLinkListNode* DLinkList_DeleteNode(DLinkList* list, DLinkListNode* node);

DLinkListNode* DLinkList_Reset(DLinkList* list);

DLinkListNode* DLinkList_Current(DLinkList* list);

DLinkListNode* DLinkList_Next(DLinkList* list);

DLinkListNode* DLinkList_Pre(DLinkList* list);

#endif


dlinklist.c

#include <stdio.h>
#include <malloc.h>
#include "DLinkList.h"

typedef struct _tag_DLinkList
{
	DLinkListNode header;
	DLinkListNode* slider;
	int length;
} TDLinkList;

DLinkList* DLinkList_Create() 
{
	TDLinkList* ret = (TDLinkList*)malloc(sizeof(TDLinkList));

	if( ret != NULL )
	{
		ret->length = 0;
		ret->header.next = NULL;
		ret->header.pre = NULL;
		ret->slider = NULL;
	}

	return ret;
}

void DLinkList_Destroy(DLinkList* list) 
{
	if (list != NULL)
	{
		free(list);
	}
}

void DLinkList_Clear(DLinkList* list) 
{
	TDLinkList* sList = (TDLinkList*)list;

	if( sList != NULL )
	{
		sList->length = 0;
		sList->header.next = NULL;
		sList->header.pre = NULL;
		sList->slider = NULL;
	}
}

int DLinkList_Length(DLinkList* list) 
{
	TDLinkList* sList = (TDLinkList*)list;
	int ret = -1;

	if( sList != NULL )
	{
		ret = sList->length;
	}

	return ret;
}

//大家一定要注意：教科书不会告诉你 项目上如何用；哪些点是项目的重点
int DLinkList_Insert(DLinkList* list, DLinkListNode* node, int pos) 
{ 
	int ret = 0, i = 0;
	TDLinkList* sList = (TDLinkList*)list;
	
	if (list==NULL || node==NULL || pos<0)
	{
		return -1;
	}
	
	{
		DLinkListNode* current = (DLinkListNode*)sList;
		DLinkListNode* next = NULL; //需要增加next指针

		for(i=0; (i<pos) && (current->next != NULL); i++)
		{
			current = current->next;
		}

		next = current->next;

		//步骤1-2
		current->next = node;
		node->next = next;

		//步骤3-4 
		if( next != NULL ) //当链表插入第一个元素，需要特殊处理
		{
			next->pre = node;
		}
		node->pre = current;

		if( sList->length == 0 )
		{
			sList->slider = node; //当链表插入第一个元素处理游标
		}

		//若在0位置插入，需要特殊处理 新来结点next前pre指向null
		if( current == (DLinkListNode*)sList )
		{
			node->pre = NULL;
		}

		sList->length++;
	}

	return ret;
}

DLinkListNode* DLinkList_Get(DLinkList* list, int pos) 
{
	TDLinkList* sList = (TDLinkList*)list;
	DLinkListNode* ret = NULL;
	int i = 0;

	if( (sList != NULL) && (0 <= pos) && (pos < sList->length) )
	{
		DLinkListNode* current = (DLinkListNode*)sList;

		for(i=0; i<pos; i++)
		{
			current = current->next;
		}

		ret = current->next;
	}

	return ret;
}

//插入第一个节点
//删除的是最后一个结点，该是如何处理
DLinkListNode* DLinkList_Delete(DLinkList* list, int pos) 
{
	TDLinkList* sList = (TDLinkList*)list;
	DLinkListNode* ret = NULL;
	int i = 0;
	if (sList == NULL || pos <0 )
	{
		return NULL;
	}
	//if( (sList != NULL) && (0 <= pos) && (pos < sList->length) )
	{
		DLinkListNode* current = (DLinkListNode*)sList;
		DLinkListNode* next = NULL; //需要增加next指针

		for(i=0; i<pos; i++)
		{
			current = current->next;
		}

		ret = current->next;
		next = ret->next;

		//步骤1
		current->next = next;

		//步骤2 
		if( next != NULL )//需要特殊处理
		{
			next->pre = current;

			if( current == (DLinkListNode*)sList ) //若第0个位置，需要特殊处理
			{
				next->pre = NULL;
			}
		}

		if( sList->slider == ret )
		{
			sList->slider = next;
		}

		sList->length--;
	}

	return ret;
}

DLinkListNode* DLinkList_DeleteNode(DLinkList* list, DLinkListNode* node)
{
	TDLinkList* sList = (TDLinkList*)list;
	DLinkListNode* ret = NULL;
	int i = 0;

	if( sList != NULL )
	{
		DLinkListNode* current = (DLinkListNode*)sList;

		for(i=0; i<sList->length; i++)
		{
			if( current->next == node )
			{
				ret = current->next;
				break;
			}

			current = current->next;
		}

		if( ret != NULL )
		{
			DLinkList_Delete(sList, i);
		}
	}

	return ret;
}

DLinkListNode* DLinkList_Reset(DLinkList* list)
{
	TDLinkList* sList = (TDLinkList*)list;
	DLinkListNode* ret = NULL;

	if( sList != NULL )
	{
		sList->slider = sList->header.next;
		ret = sList->slider;
	}

	return ret;
}

DLinkListNode* DLinkList_Current(DLinkList* list)
{
	TDLinkList* sList = (TDLinkList*)list;
	DLinkListNode* ret = NULL;

	if( sList != NULL )
	{
		ret = sList->slider;
	}

	return ret;
}

DLinkListNode* DLinkList_Next(DLinkList* list)
{
	TDLinkList* sList = (TDLinkList*)list;
	DLinkListNode* ret = NULL;

	if( (sList != NULL) && (sList->slider != NULL) )
	{
		ret = sList->slider;
		sList->slider = ret->next;
	}

	return ret;
}

DLinkListNode* DLinkList_Pre(DLinkList* list)
{
	TDLinkList* sList = (TDLinkList*)list;
	DLinkListNode* ret = NULL;

	if( (sList != NULL) && (sList->slider != NULL) )
	{
		ret = sList->slider;
		sList->slider = ret->pre;
	}

	return ret;
}




循环链表

circlelist.h



#ifndef _CIRCLELIST_H_
#define _CIRCLELIST_H_

typedef void CircleList;
/*
typedef struct _tag_CircleListNode CircleListNode;
struct _tag_CircleListNode
{
	CircleListNode* next;
};
*/
typedef struct _tag_CircleListNode
{
	struct _tag_CircleListNode * next;
}CircleListNode;

CircleList* CircleList_Create();

void List_Destroy(CircleList* list);

void CircleList_Clear(CircleList* list);

int CircleList_Length(CircleList* list);

int CircleList_Insert(CircleList* list, CircleListNode* node, int pos);

CircleListNode* CircleList_Get(CircleList* list, int pos);

CircleListNode* CircleList_Delete(CircleList* list, int pos);

//add

//根据结点的值 进行数据的删除
CircleListNode* CircleList_DeleteNode(CircleList* list, CircleListNode* node);

CircleListNode* CircleList_Reset(CircleList* list);

CircleListNode* CircleList_Current(CircleList* list);

//游标指向2号位置 
//把2号位置返回出来,同时让游标下移到3号位置
CircleListNode* CircleList_Next(CircleList* list);

#endif

circlelist.c

#include <stdio.h>
#include <malloc.h>
#include "CircleList.h"

typedef struct _tag_CircleList
{
	CircleListNode header;
	CircleListNode* slider;
	int length;
} TCircleList;

CircleList* CircleList_Create() // O(1)
{
	TCircleList* ret = (TCircleList*)malloc(sizeof(TCircleList));
	if (ret == NULL)
	{
		return NULL;
	}
	
	ret->length = 0;
	ret->header.next = NULL;
	ret->slider = NULL;
	return ret;
}

void CircleList_Destroy(CircleList* list) // O(1)
{
	if (list == NULL)
	{
		return ;
	}
	free(list);
}

void CircleList_Clear(CircleList* list) // O(1)
{
	TCircleList* sList = (TCircleList*)list;
	if (sList == NULL)
	{
		return ;
	}
	sList->length = 0;
	sList->header.next = NULL;
	sList->slider = NULL;
}

int CircleList_Length(CircleList* list) // O(1)
{
	TCircleList* sList = (TCircleList*)list;
	int ret = -1;
	if (list == NULL)
	{
		return ret;
	}
	ret = sList->length;
	return ret;
}

int CircleList_Insert(CircleList* list, CircleListNode* node, int pos) // O(n)
{ 
	int ret = 0, i=0;
	TCircleList* sList = (TCircleList*)list;

	if (list == NULL || node== NULL || pos<0)
	{
		return -1;
	}
	//if( ret )
	{
		CircleListNode* current = (CircleListNode*)sList;

		for(i=0; (i<pos) && (current->next != NULL); i++)
		{
			current = current->next;
		}

		//current->next 0号节点的地址
		node->next = current->next; //1
		current->next = node; //2

		//若第一次插入节点
		if( sList->length == 0 )
		{
			sList->slider = node;
		}

		sList->length++;

		//若头插法 current仍然指向头部
		//（原因是：跳0步，没有跳走）
		if( current == (CircleListNode*)sList )
		{
			//获取最后一个元素
			CircleListNode* last = CircleList_Get(sList, sList->length - 1); 
			last->next = current->next; //3
		}
	}

	return ret;
}

CircleListNode* CircleList_Get(CircleList* list, int pos) // O(n)
{
	TCircleList* sList = (TCircleList*)list;
	CircleListNode* ret = NULL;
	int i = 0;

	if (list==NULL || pos<0)
	{
		return NULL;
	}
	//if( (sList != NULL) && (pos >= 0) && (sList->length > 0) )
	{
		CircleListNode* current = (CircleListNode*)sList;

		for(i=0; i<pos; i++)
		{
			current = current->next;
		}

		ret = current->next;
	}

	return ret;
}

CircleListNode* CircleList_Delete(CircleList* list, int pos) // O(n)
{
	TCircleList* sList = (TCircleList*)list;
	CircleListNode* ret = NULL;
	int i = 0;

	if( (sList != NULL) && (pos >= 0) && (sList->length > 0) )
	{
		CircleListNode* current = (CircleListNode*)sList;
		CircleListNode* last = NULL;

		for(i=0; i<pos; i++)
		{
			current = current->next;
		}

		//若删除第一个元素（头结点）
		if( current == (CircleListNode*)sList )
		{
			last = (CircleListNode*)CircleList_Get(sList, sList->length - 1);
		}

		//求要删除的元素
		ret = current->next;
		current->next = ret->next;

		sList->length--;

		//判断链表是否为空
		if( last != NULL )
		{
			sList->header.next = ret->next;
			last->next = ret->next;
		}

		//若删除的元素为游标所指的元素
		if( sList->slider == ret )
		{
			sList->slider = ret->next;
		}

		//若删除元素后，链表长度为0
		if( sList->length == 0 )
		{
			sList->header.next = NULL;
			sList->slider = NULL;
		}
	}

	return ret;
}

CircleListNode* CircleList_DeleteNode(CircleList* list, CircleListNode* node) // O(n)
{
	TCircleList* sList = (TCircleList*)list;
	CircleListNode* ret = NULL;
	int i = 0;

	if( sList != NULL )
	{
		CircleListNode* current = (CircleListNode*)sList;
		
		//查找node在循环链表中的位置i
		for(i=0; i<sList->length; i++)
		{
			if( current->next == node )
			{
				ret = current->next;
				break;
			}

			current = current->next;
		}
		
		//如果ret找到，根据i去删除	
		if( ret != NULL )
		{ 
			CircleList_Delete(sList, i); //根据结点的值 求出结点的位置 ,根据位置删除元素
		}
	}

	return ret;
}

CircleListNode* CircleList_Reset(CircleList* list) // O(1)
{
	TCircleList* sList = (TCircleList*)list;
	CircleListNode* ret = NULL;

	if( sList != NULL )
	{
		sList->slider = sList->header.next;
		ret = sList->slider;
	}

	return ret;
}

CircleListNode* CircleList_Current(CircleList* list) // O(1)
{
	TCircleList* sList = (TCircleList*)list;
	CircleListNode* ret = NULL;

	if( sList != NULL )
	{
		ret = sList->slider;
	}

	return ret;
}

//把当前位置返回，并且游标下移
//把当前游标所指的位置的元素返回出去
//游标下移
CircleListNode* CircleList_Next(CircleList* list) // O(1)
{
	TCircleList* sList = (TCircleList*)list;
	CircleListNode* ret = NULL;

	if( (sList != NULL) && (sList->slider != NULL) )
	{
		ret = sList->slider;
		sList->slider = ret->next;
	}

	return ret;
}



maincirclelist01_基本功能测试01.c

#include <stdio.h>
#include <stdlib.h>
#include "CircleList.h"


struct Value
{
	CircleListNode circlenode;
	int v;
};

int main11()
{
	CircleList* list = CircleList_Create();

	struct Value v1;
	struct Value v2;
	struct Value v3;
	struct Value v4;
	struct Value v5;
	struct Value v6;
	struct Value v7;
	struct Value v8;

	int i = 0;

	v1.v = 1;
	v2.v = 2;
	v3.v = 3;
	v4.v = 4;
	v5.v = 5;
	v6.v = 6;
	v7.v = 7;
	v8.v = 8;

	CircleList_Insert(list, (CircleListNode*)&v1, 0);
	CircleList_Insert(list, (CircleListNode*)&v2, 0);
	CircleList_Insert(list, (CircleListNode*)&v3, 0);
	CircleList_Insert(list, (CircleListNode*)&v4, 0);

	for(i=0; i<2*CircleList_Length(list); i++) //怎么样证明是循环链表
	{
		struct Value* pv = (struct Value*)CircleList_Get(list, i);

		printf("%d\n", pv->v);
	}

	while( CircleList_Length(list) > 0 )
	{
		CircleList_Delete(list, 0);
	}

	printf("\n");

	CircleList_Destroy(list);

	system("pause");

	return 0;
}


maincirclelist02_约瑟夫问题求解.c

#include <stdio.h>
#include <stdlib.h>
#include "CircleList.h"

struct Value
{
	CircleListNode header;
	int v;
};

void  main()
{
	int i = 0;
	CircleList* list = CircleList_Create();

	struct Value v1, v2, v3, v4, v5, v6, v7, v8;

	v1.v = 1;	v2.v = 2;	v3.v = 3;	v4.v = 4;	
	v5.v = 5;	v6.v = 6;	v7.v = 7;	v8.v = 8;

	CircleList_Insert(list, (CircleListNode*)&v1, CircleList_Length(list));
	CircleList_Insert(list, (CircleListNode*)&v2, CircleList_Length(list));
	CircleList_Insert(list, (CircleListNode*)&v3, CircleList_Length(list));
	CircleList_Insert(list, (CircleListNode*)&v4, CircleList_Length(list));
	CircleList_Insert(list, (CircleListNode*)&v5, CircleList_Length(list));
	CircleList_Insert(list, (CircleListNode*)&v6, CircleList_Length(list));
	CircleList_Insert(list, (CircleListNode*)&v7, CircleList_Length(list));
	CircleList_Insert(list, (CircleListNode*)&v8, CircleList_Length(list));
	

	for(i=0; i<CircleList_Length(list); i++)
	{
		//获取游标所指元素,然后游标下移
		struct Value* pv = (struct Value*)CircleList_Next(list);
		printf("%d ", pv->v);
	}

	printf("\n");

	//重置游标
	CircleList_Reset(list);

	while( CircleList_Length(list) > 0 )
	{
		struct Value* pv = NULL;
		for(i=1; i<3; i++)
		{
			CircleList_Next(list);
		}
		pv = (struct Value*)CircleList_Current(list);
		printf("%d ", pv->v);
		CircleList_DeleteNode(list, (CircleListNode*)pv); //根据结点的值,进行结点元素的删除
	}

	CircleList_Destroy(list);

	system("pause");
	return ;
}


栈案例

demo01_就近匹配.c

#include "stdio.h"
#include "stdlib.h"
#include "linkstack.h"

int isLeft(char c)
{
	int ret = 0;

	switch(c)
	{
	case '<':
	case '(':
	case '[':
	case '{':
	case '\'':
	case '\"':
		ret = 1;
		break;
	default:
		ret = 0;
		break;
	}

	return ret;
}

int isRight(char c)
{
	int ret = 0;

	switch(c)
	{
	case '>':
	case ')':
	case ']':
	case '}':
	case '\'':
	case '\"':
		ret = 1;
		break;
	default:
		ret = 0;
		break;
	}

	return ret;
}

int match(char left, char right)
{
	int ret = 0;

	switch(left)
	{
	case '<':
		ret = (right == '>');
		break;
	case '(':
		ret = (right == ')');
		break;
	case '[':
		ret = (right == ']');
		break;
	case '{':
		ret = (right == '}');
		break;
	case '\'':
		ret = (right == '\'');
		break;
	case '\"':
		ret = (right == '\"');
		break;
	default:
		ret = 0;
		break;
	}

	return ret;
}

int scanner(const char* code)
{
	LinkStack* stack = LinkStack_Create();
	int ret = 0;
	int i = 0;

	while( code[i] != '\0' )
	{
		if( isLeft(code[i]) )
		{
			LinkStack_Push(stack, (void*)(code + i)); //&code[i]
		}

		if( isRight(code[i]) )
		{
			char* c = (char*)LinkStack_Pop(stack);

			if( (c == NULL) || !match(*c, code[i]) )
			{
				printf("%c does not match!\n", code[i]);
				ret = 0;
				break;
			}
		}

		i++;
	}

	if( (LinkStack_Size(stack) == 0) && (code[i] == '\0') )
	{
		printf("Succeed!\n");
		ret = 1;
	}
	else
	{
		printf("Invalid code!\n");
		ret = 0;
	}

	LinkStack_Destroy(stack); 

	return ret;
}

void main()
{
	const char* code = "#include <stdio.h> int main() { int a[4][4]; int (*p)[4]; p = a[0]; return 0; ";

	scanner(code);
	system("pause");
	return ;
}


demo02_中缀转后缀.c

#include "stdio.h"
#include "stdlib.h"
#include "string.h"
#include "linkstack.h"

int isNumber(char c)
{
	return ('0' <= c) && (c <= '9');
}

int isOperator(char c)
{
	return (c == '+') || (c == '-') || (c == '*') || (c == '/');
}

int isLeft(char c)
{
	return (c == '(');
}

int isRight(char c)
{
	return (c == ')');
}

int priority(char c)
{
	int ret = 0;

	if( (c == '+') || (c == '-') )
	{
		ret = 1;
	}

	if( (c == '*') || (c == '/') )
	{
		ret = 2;
	}

	return ret;
}

void output(char c)
{
	if( c != '\0' )
	{
		printf("%c", c);
	}
}

//  
void transform(const char* exp)
{
	int i = 0;
	LinkStack* stack = LinkStack_Create();

	while( exp[i] != '\0' )
	{
		if( isNumber(exp[i]) )
		{
			output(exp[i]);
		}
		else if( isOperator(exp[i]) )
		{
			while( priority(exp[i]) <= priority((char)(int)LinkStack_Top(stack)) )
			{
				output((char)(int)LinkStack_Pop(stack));
			}

			LinkStack_Push(stack, (void*)(int)exp[i]);
		} 
		else if( isLeft(exp[i]) )
		{
			LinkStack_Push(stack, (void*)(int)exp[i]);
		} 
		else if( isRight(exp[i]) )
		{
			//char c = '\0';
			while( !isLeft( (char)(int)LinkStack_Top(stack) ) )
			{
				output((char)(int)LinkStack_Pop(stack));
			}

			LinkStack_Pop(stack);
		}
		else
		{
			printf("Invalid expression!");
			break;
		}

		i++;
	}

	while( (LinkStack_Size(stack) > 0) && (exp[i] == '\0') )
	{
		output((char)(int)LinkStack_Pop(stack));
	}

	LinkStack_Destroy(stack);
}

int main()
{
	transform("8+(3-1)*5");

	printf("\n");
	system("pause");
	return 0;
}


demo03_后缀计算.c

#include <stdio.h>
#include "LinkStack.h"

int isNumber3(char c)
{
	return ('0' <= c) && (c <= '9');
}

int isOperator3(char c)
{
	return (c == '+') || (c == '-') || (c == '*') || (c == '/');
}

int value(char c)
{
	return (c - '0');
}

int express(int left, int right, char op)
{
	int ret = 0;

	switch(op)
	{
	case '+':
		ret = left + right;
		break;
	case '-':
		ret = left - right;
		break;
	case '*':
		ret = left * right;
		break;
	case '/':
		ret = left / right;
		break;
	default:
		break;
	}

	return ret;
}

int compute(const char* exp)
{
	LinkStack* stack = LinkStack_Create();
	int ret = 0;
	int i = 0;

	while( exp[i] != '\0' )
	{
		if( isNumber3(exp[i]) )
		{
			LinkStack_Push(stack, (void*)value(exp[i]));
		}
		else if( isOperator3(exp[i]) )
		{
			int right = (int)LinkStack_Pop(stack);
			int left = (int)LinkStack_Pop(stack);
			int result = express(left, right, exp[i]);

			LinkStack_Push(stack, (void*)result);
		}
		else
		{
			printf("Invalid expression!");
			break;
		}

		i++;
	}

	if( (LinkStack_Size(stack) == 1) && (exp[i] == '\0') )
	{
		ret = (int)LinkStack_Pop(stack);
	} 
	else 
	{
		printf("Invalid expression!");
	}

	LinkStack_Destroy(stack);

	return ret;
}

int main()
{
	printf("8 + (3 - 1) * 5  = %d\n", compute("831-5*+"));
	system("pause");
	return 0;
}


linklist.h

#ifndef _MYLINKLIST_H_
#define _MYLINKLIST_H_

typedef void LinkList;
/*
typedef struct _tag_LinkListNode LinkListNode;
struct _tag_LinkListNode
{
	LinkListNode* next;
};
*/

typedef struct _tag_LinkListNode
{
	struct _tag_LinkListNode* next;
}LinkListNode;

LinkList* LinkList_Create();

void LinkList_Destroy(LinkList* list);

void LinkList_Clear(LinkList* list);

int LinkList_Length(LinkList* list);

int LinkList_Insert(LinkList* list, LinkListNode* node, int pos);

LinkListNode* LinkList_Get(LinkList* list, int pos);

LinkListNode* LinkList_Delete(LinkList* list, int pos);

#endif


linklist.c

#include "stdio.h"
#include "stdlib.h"
#include "string.h"
#include "linklist.h"

typedef struct _tag_LinkList
{
	LinkListNode header;
	int length;
}TLinkList;

LinkList* LinkList_Create() //O(1)
{
	TLinkList *ret = (TLinkList *)malloc(sizeof(TLinkList));
	if (ret == NULL)
	{
		return ret;
	}
	ret->header.next = NULL;
	ret->length = 0;
	return ret;
}

void LinkList_Destroy(LinkList* list) //O(1)
{
	if (list != NULL)
	{
		free(list);
	}
	return ;
}

void LinkList_Clear(LinkList* list) //O(1)
{
	TLinkList *tlist = list;
	if (tlist == NULL)
	{
		return;
	}
	tlist->header.next = NULL;
	tlist->length = 0;
	return ;
}

int LinkList_Length(LinkList* list) //O(1)
{
	TLinkList *tlist = list;
	if (tlist == NULL)
	{
		return -1;
	}
	return tlist->length;
}

int LinkList_Insert(LinkList* list, LinkListNode* node, int pos)  //O(n)
{
	LinkListNode *current = NULL;
	int i = 0;
	TLinkList *tlist = list;
	if (list==NULL || node==NULL || pos<0)
	{
		return -1;
	}
	current = (LinkListNode *)tlist;
	for (i=0; (i<pos)&&(current->next!=NULL); i++)
	{
		current = current->next;
	}
	node->next = current->next;
	current->next = node;
	tlist->length++;
	return 0;
}

LinkListNode* LinkList_Get(LinkList* list, int pos)  //O(n)
{
	LinkListNode *current = NULL;
	LinkListNode *ret = NULL;
	int i = 0;
	TLinkList *tlist = list;
	if (list==NULL || pos<0)
	{
		return NULL;
	}
	
	current = (LinkListNode *)tlist;
	for (i=0; i<pos; i++)
	{
		current = current->next;
	}
	ret = current->next;

	return ret;
}

LinkListNode* LinkList_Delete(LinkList* list, int pos)  //O(n)
{
	int i = 0;
	LinkListNode *ret = NULL;
	LinkListNode *current = NULL;
	TLinkList *tlist = list;
	if (list == NULL || pos<0)
	{
		return NULL;
	}
	current = (LinkListNode *)tlist;
	for (i=0; i<pos; i++)
	{
		current = current->next;
	}
	//做了一个缓存 把位置元素缓存下来
	ret = current->next;

	//执行删除操作
	current->next = ret->next;
	tlist->length --;

	return ret;
}

linkstack.h

#ifndef _MY_LINKSTACK_H_
#define _MY_LINKSTACK_H_

typedef void LinkStack;

LinkStack* LinkStack_Create();

void LinkStack_Destroy(LinkStack* stack);

void LinkStack_Clear(LinkStack* stack);

int LinkStack_Push(LinkStack* stack, void* item);

void* LinkStack_Pop(LinkStack* stack);

void* LinkStack_Top(LinkStack* stack);

int LinkStack_Size(LinkStack* stack);

#endif //_MY_LINKSTACK_H_


linkstack.c

#include "stdlib.h"
#include "stdio.h"
#include "string.h"
#include "linkstack.h"
#include "linklist.h"

typedef struct _tag_LinkStackNode
{
	LinkListNode node;
	void *item;
}TLinkStackNode;

LinkStack* LinkStack_Create()
{

	return LinkList_Create();
}

void LinkStack_Destroy(LinkStack* stack)
{
	LinkStack_Clear(stack);
	LinkList_Destroy(stack);
	return ;
}


void LinkStack_Clear(LinkStack* stack)
{
	while (LinkStack_Size(stack) > 0)
	{
		LinkStack_Pop(stack);
	}
	return ;
}

int LinkStack_Push(LinkStack* stack, void* item)
{
	int ret = 0;
	TLinkStackNode *node = (TLinkStackNode *)malloc(sizeof(TLinkStackNode));
	if (node == NULL || item == NULL)
	{
		return -1;
	}
	node->item = item;
	ret = LinkList_Insert(stack, (LinkListNode*)node, 0);
	if (ret != 0)
	{
		free(node);
	}
	return ret;
}


void* LinkStack_Pop(LinkStack* stack)
{
	void *ret = NULL;
	TLinkStackNode *node = NULL;
	if (stack == NULL)
	{
		return NULL;
	}
	node = (TLinkStackNode *)LinkList_Delete(stack, 0);
	if (node == NULL)
	{
		return NULL;
	}
	ret = node->item;

	//注意 释放内存不要忘记
	if (node != NULL) 
	{
		free(node);
	}

	return ret;
}

void* LinkStack_Top(LinkStack* stack)
{
	void *ret = NULL;
	TLinkStackNode *node = NULL;
	if (stack == NULL)
	{
		return NULL;
	}
	node = (TLinkStackNode *)LinkList_Get(stack, 0);
	if (node == NULL)
	{
		return NULL;
	}
	ret = node->item;
	return ret;
}

int LinkStack_Size(LinkStack* stack)
{
	return LinkList_Length(stack);
}




栈的链式存储实现

dm01_栈链式存储_设计实现_框架

#define  _CRT_SECURE_NO_WARNINGS 
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include "linkstack.h"

void main()
{
	LinkStack *stack = NULL;
	int  a[5], i = 0;

	for (i=0; i<5; i++)
	{
		a[i] = i+1;
	}

	stack = LinkStack_Create();

	//向栈中 添加 元素 
	for (i=0; i<5; i++)
	{
		LinkStack_Push(stack, &a[i]); //抛砖: 栈的结点a[i]==>转换成(适配成) 链表结点 ===>插入到链表库
	}

	//栈的属性
	printf("len:%d \n", LinkStack_Size(stack));
	printf("top:%d \n",  *( (int *)LinkStack_Top(stack) )  );

	/*
	//元素 出栈
	while (LinkStack_Size(stack) > 0 )
	{
		int tmp = 0;
		tmp = *( (int *)LinkStack_Pop(stack) );
		printf("%d ", tmp);
	}
	*/

	LinkStack_Destroy(stack);

	printf("hello...\n");
	system("pause");
	return ;
}

linklist.h

#ifndef _MYLINKLIST_H_
#define _MYLINKLIST_H_

typedef void LinkList;
/*
typedef struct _tag_LinkListNode LinkListNode;
struct _tag_LinkListNode
{
	LinkListNode* next;
};
*/

typedef struct _tag_LinkListNode
{
	struct _tag_LinkListNode* next;
}LinkListNode;

LinkList* LinkList_Create();

void LinkList_Destroy(LinkList* list);

void LinkList_Clear(LinkList* list);

int LinkList_Length(LinkList* list);

int LinkList_Insert(LinkList* list, LinkListNode* node, int pos);

LinkListNode* LinkList_Get(LinkList* list, int pos);

LinkListNode* LinkList_Delete(LinkList* list, int pos);

#endif


linklist.c


#define  _CRT_SECURE_NO_WARNINGS 
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include "linklist.h"

typedef struct _tag_LinkList
{
	LinkListNode header;
	int		length;
}TLinkList;
//
LinkList* LinkList_Create()  //O(1)
{
	TLinkList *tmp = NULL;

	tmp = (TLinkList *)malloc(sizeof(TLinkList));
	if (tmp == NULL)
	{
		printf("func LinkList_Create() err \n");
		return NULL;
	}
	memset(tmp, 0, sizeof(TLinkList));
	tmp->length = 0;
	tmp->header.next = NULL; //
	return tmp;
}

void LinkList_Destroy(LinkList* list)  //O(1)
{
	if (list == NULL)
	{
		return ;
	}
	free(list);
	return ;
}

void LinkList_Clear(LinkList* list)   //O(1)
{
	TLinkList *tList = NULL;
	tList = (TLinkList *)list;
	if (tList == NULL)
	{
		return ;
	}
	tList->header.next = NULL;
	tList->length = 0;

	return ;
}

int LinkList_Length(LinkList* list)  //O(1)
{
	TLinkList *tList = NULL;
	tList = (TLinkList *)list;
	if (tList == NULL)
	{
		return -1;
	}
	return tList->length;
}

int LinkList_Insert(LinkList* list, LinkListNode* node, int pos)  //O(n)
{
	int				i = 0;
	LinkListNode	*current = NULL;
	TLinkList		*tList = NULL;

	tList = (TLinkList *)list;
	
	if (list==NULL || node==NULL || pos<0)
	{
		return -1;
	}

	current = &(tList->header);
	for (i=0; i<pos; i++)
	{
		current = current->next;
	}
	//新结点 连接 后继链表
	node->next = current->next;

	//前面的链表 连接 新结点
	current->next = node;

	tList->length ++;
	return 0;
}

LinkListNode* LinkList_Get(LinkList* list, int pos)  //O(n)
{
	int				i = 0;
	LinkListNode	*current = NULL;
	TLinkList		*tList = NULL;

	tList = (TLinkList *)list;

	if (list==NULL || pos<0)
	{
		return NULL;
	}

	current = &(tList->header); //赋值指针变量初始化
	for (i=0; i<pos; i++)
	{
		current = current->next;
	}
	return current->next;
}

LinkListNode* LinkList_Delete(LinkList* list, int pos) //O(n)
{
	int				i = 0;
	LinkListNode	*current = NULL;
	LinkListNode	*ret = NULL;
	TLinkList		*tList = NULL;

	tList = (TLinkList *)list;
	if (list==NULL || pos<0)
	{
		return NULL;
	}

	current = &(tList->header);
	for (i=0; i<pos; i++)
	{
		current = current->next;
	}
	ret = current->next; //缓存要删除的结点

	current->next = ret->next;

	tList->length --;

	return ret;
}



linkstack.h

#ifndef _MY_LINKSTACK_H_
#define _MY_LINKSTACK_H_

typedef void LinkStack;

LinkStack* LinkStack_Create();

void LinkStack_Destroy(LinkStack* stack);

void LinkStack_Clear(LinkStack* stack);

int LinkStack_Push(LinkStack* stack, void* item);

void* LinkStack_Pop(LinkStack* stack);

void* LinkStack_Top(LinkStack* stack);

int LinkStack_Size(LinkStack* stack);

#endif //_MY_LINKSTACK_H_


linkstack.c

#define  _CRT_SECURE_NO_WARNINGS 
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include "linkstack.h"
#include "linklist.h"


typedef struct _tag_LinkStack
{
	LinkListNode node;
	void* item;
}TLinkStack;

//创建一个栈 相当于 创建一个线性表
LinkStack* LinkStack_Create()
{
	return LinkList_Create();
}

void LinkStack_Destroy(LinkStack* stack)
{
	LinkStack_Clear(stack);  //释放栈的 结点 
	LinkList_Destroy(stack);  //释放句柄
}

void LinkStack_Clear(LinkStack* stack)
{
	while (LinkList_Length(stack) > 0)
	{
		LinkStack_Pop(stack);
	}
	return ;
}

//向栈中添加元素 相等向 线性表中 添加结点
int LinkStack_Push(LinkStack* stack, void* item)
{
	int			ret = 0;
	TLinkStack *tmp = NULL;

	 //// void* item 栈结点  ===>链表结点
	tmp = (TLinkStack *)malloc(sizeof(TLinkStack));
	tmp->item = item;

	ret = LinkList_Insert(stack, (LinkListNode *)tmp, 0);
	if (ret != 0)
	{
		printf("func LinkList_Insert() err:%d \n", ret);
		free(tmp);
		return ret;
	}
	return ret;
}

//从栈中 弹出 元素   相当于 从线性表中 删除0号位置元素
void* LinkStack_Pop(LinkStack* stack)
{
	TLinkStack *tmp = NULL;

	void *item = NULL;

	tmp = (TLinkStack*) LinkList_Delete(stack, 0);
	if (tmp == NULL)
	{
		printf("func LinkList_Delete() err \n");
		return NULL;
	}
	//把链表节点 ====>转换成  栈结点
	item = tmp->item;

	free(tmp);

	return item;
}

//获取栈顶元素 相等于 从线性表的0号位置元素
void* LinkStack_Top(LinkStack* stack)
{
	TLinkStack *tmp = NULL;
	void *item = NULL;

	tmp = (TLinkStack *)LinkList_Get(stack, 0);
	if (tmp == NULL)
	{
		printf("func LinkStack_Top() err \n");
	}
	item = tmp->item;
	return item;
}

int LinkStack_Size(LinkStack* stack)
{
	return LinkList_Length(stack);
}

栈的顺序存储实现

dm01_栈顺序存储_设计与实现_框架.c

#define  _CRT_SECURE_NO_WARNINGS 
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include "seqstack.h"


void main()
{
	int i = 0; 
	SeqStack *stack = NULL;

	int  a[10];
	for (i=0; i<10; i++)
	{
		a[i] = i+1;
	}

	stack = SeqStack_Create(20);
	
	//入栈
	for (i=0; i<3; i++)
	{
		SeqStack_Push(stack, &a[i]);
	}

	//栈的属性
	printf("len:%d \n", SeqStack_Size(stack));
	printf("capacity:%d \n", SeqStack_Capacity(stack));

	printf("top:%d \n", *((int *)SeqStack_Top(stack) )   )  ;


	//元素出栈

	while (SeqStack_Size(stack) > 0)
	{
		printf("%d ",   *( (int *)SeqStack_Pop(stack) ) );
	}

	SeqStack_Destroy(stack);

	printf("hello...\n");
	system("pause");
	return ;
}

seqlist.h

#ifndef  __MY_SEQLIST_H__ 
#define __MY_SEQLIST_H__

typedef void SeqList;
typedef void SeqListNode;

//链表 创建
SeqList* SeqList_Create(int capacity);

//链表 销毁
void SeqList_Destroy(SeqList* list);

////链表 清空
void SeqList_Clear(SeqList* list);

//链表 长度
int SeqList_Length(SeqList* list);


//链表 容量 
int SeqList_Capacity(SeqList* list);

//链表 在某一个位置 插入元素
int SeqList_Insert(SeqList* list, SeqListNode* node, int pos);

//获取某一个位置的链表结点
SeqListNode* SeqList_Get(SeqList* list, int pos);

//删除某一个位置的结点
SeqListNode* SeqList_Delete(SeqList* list, int pos);


#endif  //__MY_SEQLIST_H__





seqlist.c

#define  _CRT_SECURE_NO_WARNINGS 
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include "seqlist.h"


//用数组来模拟线性表
typedef struct _tag_SeqList
{
	int		capacity;
	int		length;
	//int *node[100];
	int		**node;  //int node[capacity] //
					//int *node[capacity];

	//int *node; //   int node[i]===> *(node+i)
}TSeqList;


//链表 创建
SeqList* SeqList_Create(int capacity) //O(1)
{
	int			ret;
	TSeqList	*tmp = NULL;
	tmp = (TSeqList *)malloc(sizeof(TSeqList));
	if (tmp == NULL)
	{
		ret =1;
		printf("func SeqList_Create() err :%d \n", ret);
		return NULL;
	}
	memset(tmp, 0, sizeof(TSeqList));
	tmp->capacity = capacity;
	tmp->length = 0;
	tmp->node = (int **)malloc(sizeof(void *) * capacity);
	if (tmp->node == NULL)
	{
		ret = 2;
		printf("func SeqList_Create() malloc err :%d \n", ret);
		return NULL;
	}
	memset(tmp->node, 0, sizeof(void *) * capacity);

	return tmp;
}

//链表 创建
int SeqList_Create2(int capacity, SeqList**handle)
{
	int			ret = 0;
	TSeqList	*tmp = NULL;
	tmp = (TSeqList *)malloc(sizeof(TSeqList));
	if (tmp == NULL)
	{
		ret =1;
		printf("func SeqList_Create2() err :%d \n", ret);
		return ret;
	}
	memset(tmp, 0, sizeof(TSeqList));
	tmp->capacity = capacity;
	tmp->length = 0;
	tmp->node = (int **)malloc(sizeof(void *) * capacity);
	if (tmp->node == NULL)
	{
		ret = 2;
		printf("func SeqList_Create2() malloc err :%d \n", ret);
		return ret;
	}

	*handle = tmp;
	return ret;
}

//链表 销毁
void SeqList_Destroy(SeqList* list)  //O(1)
{
	TSeqList	*tmp = NULL;
	if (list == NULL)
	{
		return ;
	}

	tmp = (TSeqList *)list;

	if (tmp->node != NULL)
	{
		free(tmp->node);
	}
	free(tmp);
	return ;
}

////链表 清空
void SeqList_Clear(SeqList* list) //O(1)
{
	TSeqList	*tmp = NULL;
	if (list == NULL)
	{
		return ;
	}

	tmp = (TSeqList *)list;
	tmp->length = 0;
	memset(tmp->node, 0, (tmp->capacity * sizeof(void *)) );

	return ;
}

//链表 长度
int SeqList_Length(SeqList* list) //O(1)
{
	TSeqList	*tmp = NULL;
	if (list == NULL)
	{
		return -1;
	}
	tmp = (TSeqList *)list;

	return tmp->length;
}


//链表 容量 
int SeqList_Capacity(SeqList* list) //O(1)
{
	TSeqList	*tmp = NULL;
	if (list == NULL)
	{
		return -1;
	}
	tmp = (TSeqList *)list;
	return tmp->capacity;
}

//链表 在某一个位置 插入元素
int SeqList_Insert(SeqList* list, SeqListNode* node, int pos)  //O(n)
{
	TSeqList	*tList = NULL;
	int i = 0;
	if (list == NULL ||  node==NULL)
	{
		return -1;
	}
	tList = (TSeqList *)list;
	//如果满了 
	if (tList->length >= tList->capacity)
	{
		return -2;
	}

	//pos位置的容错处理
	if (pos > tList->length )
	{
		pos = tList->length;
	}

	for (i=tList->length; i>pos; i--)  //n
	{
		tList->node[i] = tList->node[i-1];
	}

	tList->node[i] = (int* )node; //ok
	tList->length ++;

	return 0;
}

//获取某一个位置的链表结点
SeqListNode* SeqList_Get(SeqList* list, int pos)  //O(1)
{
	TSeqList	*tList = NULL;
	SeqListNode *tmp = NULL;

	tList = (TSeqList *)list;

	if (list == NULL || pos<0 || pos >=tList->length )
	{
		return NULL;
	}
	tmp = tList->node[pos];

	return tmp;
}

//删除某一个位置的结点
SeqListNode* SeqList_Delete(SeqList* list, int pos)  ////O(n)
{
	int			i = 0;
	TSeqList	*tList = NULL;
	SeqListNode *tmp = NULL; 

	tList = (TSeqList *)list;
	if (list == NULL || pos <0 || pos >= tList->length)
	{
		return NULL;
	}
	tmp = tList->node[pos];

	// pos = 3
	for (i=pos+1; i<tList->length; i++)
	{
		tList->node[i-1] = tList->node[i];

	}
	tList->length --;
	return tmp;
}



seqstack.h

// seqstack.h

#ifndef _MY_SEQSTACK_H_
#define _MY_SEQSTACK_H_

typedef void SeqStack;

SeqStack* SeqStack_Create(int capacity);

void SeqStack_Destroy(SeqStack* stack);

void SeqStack_Clear(SeqStack* stack);

int SeqStack_Push(SeqStack* stack, void* item);

void* SeqStack_Pop(SeqStack* stack);

void* SeqStack_Top(SeqStack* stack);

int SeqStack_Size(SeqStack* stack);

int SeqStack_Capacity(SeqStack* stack);

#endif //_MY_SEQSTACK_H_


seqstack.c


#define  _CRT_SECURE_NO_WARNINGS 
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include "seqstack.h"
#include "seqlist.h"  //顺序存储 链表


//创建栈 相当于 创建一个线性表
SeqStack* SeqStack_Create(int capacity)
{
	return SeqList_Create(capacity);
}

//销毁栈 相当于销毁链表
void SeqStack_Destroy(SeqStack* stack)
{
	SeqList_Destroy(stack);
}

//清空栈 相当于 清空线性表
void SeqStack_Clear(SeqStack* stack)
{
	SeqList_Clear(stack);
}

//栈插入元素 相当于 在线性表(数组)的尾部添加元素
int SeqStack_Push(SeqStack* stack, void* item)
{
	return SeqList_Insert(stack, item, SeqList_Length(stack)); //相当 尾插法
}

//栈 弹出元素  相当于 从线性表的尾部 删除元素
void* SeqStack_Pop(SeqStack* stack)
{
	return  SeqList_Delete(stack, SeqList_Length(stack)-1 );
}

//栈 获取栈顶元素 相当于 求链表的尾部元素
//获取栈顶元素 相当于 从链表的尾部拿元素;  尾部元素的下标=长度-1
void* SeqStack_Top(SeqStack* stack)
{
	return SeqList_Get(stack, SeqList_Length(stack) - 1);
}

//求栈的大小 相当于 链表的长度
int SeqStack_Size(SeqStack* stack)
{
	return SeqList_Length(stack);
}

//求栈的容量  相当于  求链表的容量
int SeqStack_Capacity(SeqStack* stack)
{
	return SeqList_Capacity(stack);
}


第15章数据结构day03

linkqueue

linklist.h

#ifndef _MYLINKLIST_H_
#define _MYLINKLIST_H_

typedef void LinkList;
/*
typedef struct _tag_LinkListNode LinkListNode;
struct _tag_LinkListNode
{
	LinkListNode* next;
};
*/

typedef struct _tag_LinkListNode
{
	struct _tag_LinkListNode* next;
}LinkListNode;

LinkList* LinkList_Create();

void LinkList_Destroy(LinkList* list);

void LinkList_Clear(LinkList* list);

int LinkList_Length(LinkList* list);

int LinkList_Insert(LinkList* list, LinkListNode* node, int pos);

LinkListNode* LinkList_Get(LinkList* list, int pos);

LinkListNode* LinkList_Delete(LinkList* list, int pos);

#endif


linklist.c


#define  _CRT_SECURE_NO_WARNINGS 
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include "linklist.h"

typedef struct _tag_LinkList
{
	LinkListNode header;
	int		length;
}TLinkList;
//
LinkList* LinkList_Create()  //O(1)
{
	TLinkList *tmp = NULL;

	tmp = (TLinkList *)malloc(sizeof(TLinkList));
	if (tmp == NULL)
	{
		printf("func LinkList_Create() err \n");
		return NULL;
	}
	memset(tmp, 0, sizeof(TLinkList));
	tmp->length = 0;
	tmp->header.next = NULL; //
	return tmp;
}

void LinkList_Destroy(LinkList* list)  //O(1)
{
	if (list == NULL)
	{
		return ;
	}
	free(list);
	return ;
}

void LinkList_Clear(LinkList* list)   //O(1)
{
	TLinkList *tList = NULL;
	tList = (TLinkList *)list;
	if (tList == NULL)
	{
		return ;
	}
	tList->header.next = NULL;
	tList->length = 0;

	return ;
}

int LinkList_Length(LinkList* list)  //O(1)
{
	TLinkList *tList = NULL;
	tList = (TLinkList *)list;
	if (tList == NULL)
	{
		return -1;
	}
	return tList->length;
}

int LinkList_Insert(LinkList* list, LinkListNode* node, int pos)  //O(n)
{
	int				i = 0;
	LinkListNode	*current = NULL;
	TLinkList		*tList = NULL;

	tList = (TLinkList *)list;
	
	if (list==NULL || node==NULL || pos<0)
	{
		return -1;
	}

	current = &(tList->header);
	for (i=0; i<pos; i++)
	{
		current = current->next;
	}
	//新结点 连接 后继链表
	node->next = current->next;

	//前面的链表 连接 新结点
	current->next = node;

	tList->length ++;
	return 0;
}

LinkListNode* LinkList_Get(LinkList* list, int pos)  //O(n)
{
	int				i = 0;
	LinkListNode	*current = NULL;
	TLinkList		*tList = NULL;

	tList = (TLinkList *)list;

	if (list==NULL || pos<0)
	{
		return NULL;
	}

	current = &(tList->header); //赋值指针变量初始化
	for (i=0; i<pos; i++)
	{
		current = current->next;
	}
	return current->next;
}

LinkListNode* LinkList_Delete(LinkList* list, int pos) //O(n)
{
	int				i = 0;
	LinkListNode	*current = NULL;
	LinkListNode	*ret = NULL;
	TLinkList		*tList = NULL;

	tList = (TLinkList *)list;
	if (list==NULL || pos<0)
	{
		return NULL;
	}

	current = &(tList->header);
	for (i=0; i<pos; i++)
	{
		current = current->next;
	}
	ret = current->next; //缓存要删除的结点

	current->next = ret->next;

	tList->length --;

	return ret;
}



linkqueue.h

#ifndef _MY_LINKQUEUE_H_
#define _MY_LINKQUEUE_H_

typedef void LinkQueue;

LinkQueue* LinkQueue_Create();

void LinkQueue_Destroy(LinkQueue* queue);

void LinkQueue_Clear(LinkQueue* queue);

int LinkQueue_Append(LinkQueue* queue, void* item);

void* LinkQueue_Retrieve(LinkQueue* queue);

void* LinkQueue_Header(LinkQueue* queue);

int LinkQueue_Length(LinkQueue* queue);

#endif //_MY_LINKQUEUE_H_


linkqueue.c

#define  _CRT_SECURE_NO_WARNINGS 
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include "linkqueue.h"
#include "linklist.h"

typedef struct _tag_LinkQuequNode
{
	LinkListNode node;
	void *item;
}TLinkQuequNode;


//创建一个队列 相等于 创建线性表
LinkQueue* LinkQueue_Create()
{
	return LinkList_Create();
}

//销毁队列 相等于 销毁链表
void LinkQueue_Destroy(LinkQueue* queue)
{
	LinkQueue_Clear(queue);
	LinkList_Destroy(queue);
}

void LinkQueue_Clear(LinkQueue* queue)
{
	while (LinkList_Length(queue) > 0)
	{
		LinkQueue_Retrieve(queue); //在这个函数中,元素出队列,然后释放 内存 都有了
	}
}



//向队列尾部添加元素 相当于 在链表的尾部元素添加
int LinkQueue_Append(LinkQueue* queue, void* item)
{
	int				ret = 0;
	TLinkQuequNode *tmp = NULL;

	tmp = malloc(sizeof(TLinkQuequNode));
	if (tmp == NULL)
	{
		return -1;
	}
	tmp->item = item; //队列的item 转换成 链表的结点 


	ret = LinkList_Insert(queue, (LinkListNode*)tmp, LinkList_Length(queue));
	if (ret != 0)
	{
		printf("func LinkList_Insert() err:%d \n", ret);
		free(tmp);
		return ret;
	}
	return ret;
}

//删除队头 元素
void* LinkQueue_Retrieve(LinkQueue* queue)
{
	TLinkQuequNode *tmp = NULL; 
	void			*item = NULL;
	tmp =(TLinkQuequNode *) LinkList_Delete(queue, 0);
	if (tmp == NULL)
	{
		return NULL;
	}
	item = tmp->item;
	free(tmp); //不要忘记 出队列时,结点释放

	return item;
}

void* LinkQueue_Header(LinkQueue* queue)
{
	TLinkQuequNode *tmp = NULL; 
	tmp = (TLinkQuequNode *)LinkList_Get(queue, 0);
	if (tmp ==NULL)
	{
		return NULL;
	}
	
	return tmp->item;
}

int LinkQueue_Length(LinkQueue* queue)
{
	return LinkList_Length(queue);
}

队列链式存储_设计与实现_测试框架.c

#define  _CRT_SECURE_NO_WARNINGS 
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include "linkqueue.h"

void main()
{
	int		a[10], i = 0;
	LinkQueue  *queue = NULL;

	for (i=0; i<10; i++)
	{
		a[i] = i+1;
	}

	queue = LinkQueue_Create();

	//向队列中 添加元素
	for (i=0; i<10; i++)
	{
		LinkQueue_Append(queue, &a[i]);
	}

	//获取队列的属性
	printf("len:%d \n", LinkQueue_Length(queue));
	printf("header:%d \n",   *( (int *)LinkQueue_Header(queue)));

	//出队列
	while( LinkQueue_Length(queue) > 0 )
	{
		int tmp;
		tmp = *( (int *)LinkQueue_Retrieve(queue) );
	
		printf("%d ", tmp);
	}

	//销毁队列
	LinkQueue_Destroy(queue);
	
	system("pause");
	return ;
}

seqqueue

seqlist.h

#ifndef  __MY_SEQLIST_H__ 
#define __MY_SEQLIST_H__

typedef void SeqList;
typedef void SeqListNode;

//链表 创建
SeqList* SeqList_Create(int capacity);

//链表 销毁
void SeqList_Destroy(SeqList* list);

////链表 清空
void SeqList_Clear(SeqList* list);

//链表 长度
int SeqList_Length(SeqList* list);


//链表 容量 
int SeqList_Capacity(SeqList* list);

//链表 在某一个位置 插入元素
int SeqList_Insert(SeqList* list, SeqListNode* node, int pos);

//获取某一个位置的链表结点
SeqListNode* SeqList_Get(SeqList* list, int pos);

//删除某一个位置的结点
SeqListNode* SeqList_Delete(SeqList* list, int pos);


#endif  //__MY_SEQLIST_H__





seqlist.c

#define  _CRT_SECURE_NO_WARNINGS 
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include "seqlist.h"


//用数组来模拟线性表
typedef struct _tag_SeqList
{
	int		capacity;
	int		length;
	//int *node[100];
	int		**node;  //int node[capacity] //
					//int *node[capacity];

	//int *node; //   int node[i]===> *(node+i)
}TSeqList;


//链表 创建
SeqList* SeqList_Create(int capacity) //O(1)
{
	int			ret;
	TSeqList	*tmp = NULL;
	tmp = (TSeqList *)malloc(sizeof(TSeqList));
	if (tmp == NULL)
	{
		ret =1;
		printf("func SeqList_Create() err :%d \n", ret);
		return NULL;
	}
	memset(tmp, 0, sizeof(TSeqList));
	tmp->capacity = capacity;
	tmp->length = 0;
	tmp->node = (int **)malloc(sizeof(void *) * capacity);
	if (tmp->node == NULL)
	{
		ret = 2;
		printf("func SeqList_Create() malloc err :%d \n", ret);
		return NULL;
	}
	memset(tmp->node, 0, sizeof(void *) * capacity);

	return tmp;
}

//链表 创建
int SeqList_Create2(int capacity, SeqList**handle)
{
	int			ret = 0;
	TSeqList	*tmp = NULL;
	tmp = (TSeqList *)malloc(sizeof(TSeqList));
	if (tmp == NULL)
	{
		ret =1;
		printf("func SeqList_Create2() err :%d \n", ret);
		return ret;
	}
	memset(tmp, 0, sizeof(TSeqList));
	tmp->capacity = capacity;
	tmp->length = 0;
	tmp->node = (int **)malloc(sizeof(void *) * capacity);
	if (tmp->node == NULL)
	{
		ret = 2;
		printf("func SeqList_Create2() malloc err :%d \n", ret);
		return ret;
	}

	*handle = tmp;
	return ret;
}

//链表 销毁
void SeqList_Destroy(SeqList* list)  //O(1)
{
	TSeqList	*tmp = NULL;
	if (list == NULL)
	{
		return ;
	}

	tmp = (TSeqList *)list;

	if (tmp->node != NULL)
	{
		free(tmp->node);
	}
	free(tmp);
	return ;
}

////链表 清空
void SeqList_Clear(SeqList* list) //O(1)
{
	TSeqList	*tmp = NULL;
	if (list == NULL)
	{
		return ;
	}

	tmp = (TSeqList *)list;
	tmp->length = 0;
	memset(tmp->node, 0, (tmp->capacity * sizeof(void *)) );

	return ;
}

//链表 长度
int SeqList_Length(SeqList* list) //O(1)
{
	TSeqList	*tmp = NULL;
	if (list == NULL)
	{
		return -1;
	}
	tmp = (TSeqList *)list;

	return tmp->length;
}


//链表 容量 
int SeqList_Capacity(SeqList* list) //O(1)
{
	TSeqList	*tmp = NULL;
	if (list == NULL)
	{
		return -1;
	}
	tmp = (TSeqList *)list;
	return tmp->capacity;
}

//链表 在某一个位置 插入元素
int SeqList_Insert(SeqList* list, SeqListNode* node, int pos)  //O(n)
{
	TSeqList	*tList = NULL;
	int i = 0;
	if (list == NULL ||  node==NULL)
	{
		return -1;
	}
	tList = (TSeqList *)list;
	//如果满了 
	if (tList->length >= tList->capacity)
	{
		return -2;
	}

	//pos位置的容错处理
	if (pos > tList->length )
	{
		pos = tList->length;
	}

	for (i=tList->length; i>pos; i--)  //n
	{
		tList->node[i] = tList->node[i-1];
	}

	tList->node[i] = (int* )node; //ok
	tList->length ++;

	return 0;
}

//获取某一个位置的链表结点
SeqListNode* SeqList_Get(SeqList* list, int pos)  //O(1)
{
	TSeqList	*tList = NULL;
	SeqListNode *tmp = NULL;

	tList = (TSeqList *)list;

	if (list == NULL || pos<0 || pos >=tList->length )
	{
		return NULL;
	}
	tmp = tList->node[pos];

	return tmp;
}

//删除某一个位置的结点
SeqListNode* SeqList_Delete(SeqList* list, int pos)  ////O(n)
{
	int			i = 0;
	TSeqList	*tList = NULL;
	SeqListNode *tmp = NULL; 

	tList = (TSeqList *)list;
	if (list == NULL || pos <0 || pos >= tList->length)
	{
		return NULL;
	}
	tmp = tList->node[pos];

	// pos = 3
	for (i=pos+1; i<tList->length; i++)
	{
		tList->node[i-1] = tList->node[i];

	}
	tList->length --;
	return tmp;
}



seqqueue.h

#ifndef _MY_SEQQUEUE_H_
#define _MY_SEQQUEUE_H_

typedef void SeqQueue;

//创建队列 
SeqQueue* SeqQueue_Create(int capacity);

//销毁 队列 
void SeqQueue_Destroy(SeqQueue* queue);

//清空 队列
void SeqQueue_Clear(SeqQueue* queue);

//向队列中添加 元素 
int SeqQueue_Append(SeqQueue* queue, void* item);

//从 队列 中 提取 元素 
void* SeqQueue_Retrieve(SeqQueue* queue);


//求 队列 队头元素
void* SeqQueue_Header(SeqQueue* queue);

//队列 长度
int SeqQueue_Length(SeqQueue* queue);


//队列容量
int SeqQueue_Capacity(SeqQueue* queue);

#endif //_MY_SEQQUEUE_H_

seqqueue.c

#define  _CRT_SECURE_NO_WARNINGS 
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include "seqqueue.h"
#include "seqlist.h"

//创建一个队列 相当于 创建一个顺序表
SeqQueue* SeqQueue_Create(int capacity)
{
	return SeqList_Create(capacity);
}

//销毁 队列 相当于 销毁 一个 顺序表
void SeqQueue_Destroy(SeqQueue* queue)
{
	SeqList_Destroy(queue);
}

//清空 队列 相当于 清空 一个 顺序表
void SeqQueue_Clear(SeqQueue* queue)
{
	 SeqList_Clear(queue);
}

//向队列尾部添加一个元素 相当于 向线性表的尾部添加元素
int SeqQueue_Append(SeqQueue* queue, void* item)
{
	return SeqList_Insert(queue, item, SeqList_Length(queue));
}

//提取队头元素  相当于 删除链表0号位置元素
void* SeqQueue_Retrieve(SeqQueue* queue)
{
	return SeqList_Delete(queue, 0)  ;
}

//获取队头元素  相当于 获取 链表0号位置元素
void* SeqQueue_Header(SeqQueue* queue)
{
	return SeqList_Get(queue, 0);
}

int SeqQueue_Length(SeqQueue* queue)
{
	return SeqList_Length(queue);
}

int SeqQueue_Capacity(SeqQueue* queue)
{
	return SeqList_Capacity(queue);
}

队列顺序存储设计与实现_测试框架.c

#define  _CRT_SECURE_NO_WARNINGS 
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include "seqqueue.h"

void main()
{
	int  i = 0, a[10];

	SeqQueue *queue = NULL;

	for (i=0; i<10; i++)
	{
		a[i] = i + 1;
	}

	queue = SeqQueue_Create(10);

	//向队列的尾部 添加元素 
	for (i=0; i<10; i++)
	{
		SeqQueue_Append(queue, a + i);
	}

	//获取队列的属性
	printf("capacity:%d \n", SeqQueue_Capacity(queue));
	printf("length:%d \n", SeqQueue_Length(queue));
	printf("队头: %d \n", *( (int *)SeqQueue_Header(queue) ));

	//销毁 队列

	while (SeqQueue_Length(queue) > 0 )
	{
		int tmp; 
		tmp =  *(  (int *)SeqQueue_Retrieve(queue) );
		printf("%d ", tmp);
	}
	SeqQueue_Destroy(queue);
	
	printf("hello...\n");
	system("pause");
	return ;
}

树

dm01_二叉链表表示法.c

#define  _CRT_SECURE_NO_WARNINGS 
#include <stdlib.h>
#include <string.h>
#include <stdio.h>


//1 
typedef struct BiTNode
{
	int		data;
	struct BiTNode *lchild, *rchild;
}BiTNode;

typedef struct BiTNode * BiTree;


//2
//第二种表示方法 三叉链表
//三叉链表
typedef struct TriTNode 
{
	int data;
	//左右孩子指针
	struct TriTNode *lchild, *rchild;
	struct TriTNode *parent;
}TriTNode, *TriTree;



//双亲链表
#define MAX_TREE_SIZE 100
typedef struct BPTNode
{
	int data;
	int parentPosition; //指向双亲的指针 //数组下标
	char LRTag; //左右孩子标志域
}BPTNode;

typedef struct BPTree
{
	BPTNode nodes[100]; //因为节点之间是分散的，需要把节点存储到数组中
	int num_node;  //节点数目
	int root; //根结点的位置 //注意此域存储的是父亲节点在数组的下标
}BPTree;

//用这个数据结构能表达出一颗树。。。能，怎么表达？不能why

void main()
{
	BPTree myTree; //

	myTree.root = 0; //数组的0号位置 是根结点
	myTree.nodes[0].data = 'A';

	//B
	myTree.nodes[1].data = 'B';
	myTree.nodes[1].parentPosition = 0;
	myTree.nodes[1].LRTag = 1;

	//C
	myTree.nodes[2].data = 'C';
	myTree.nodes[2].parentPosition = 0;
	myTree.nodes[2].LRTag = 2;

	system("pause");
}


void main11()
{
	BiTNode  nodeA, nodeB, nodeC, nodeD, nodeE;

	nodeA.lchild = NULL;
	nodeA.rchild = NULL;
	nodeA.data = 0;
	memset(&nodeA, 0, sizeof(BiTNode));
	memset(&nodeB, 0, sizeof(BiTNode));
	memset(&nodeC, 0, sizeof(BiTNode));
	memset(&nodeD, 0, sizeof(BiTNode));
	memset(&nodeE, 0, sizeof(BiTNode));

	nodeA.data = 1;
	nodeA.lchild = &nodeB;
	nodeA.rchild = &nodeC;
	nodeB.lchild = &nodeD;
	nodeC.lchild = &nodeE;

	printf("hello...\n");
	system("pause");
	return ;
}

dm01_中序非递归.c++


#include <iostream>
using namespace std;

#include "stack"




//1 
typedef struct BiTNode
{
	int		data;
	struct BiTNode *lchild, *rchild;
}BiTNode;

typedef struct BiTNode * BiTree;

//递归 中序遍历
void InOrder(BiTNode *T)
{
	if (T == NULL)
	{
		return ;
	}

	if (T->lchild != NULL)
	{
		InOrder(T->lchild);
	}

	printf("%d ", T->data); //

	if (T->rchild != NULL)
	{
		InOrder(T->rchild);
	}
}


BiTNode *  GoFarLeft(BiTNode *T, stack<BiTNode *> &s)
{
	if (T ==NULL)
	{
		return NULL;
	}
	while (T->lchild != NULL) //一直往左走 ,找到中序遍历的起点
	{
		s.push(T);
		T = T->lchild; //让指针下移 
	}
	return T; //
}

void MyInOrder(BiTNode *T)
{
	stack<BiTNode *> s; //
	BiTNode *t = GoFarLeft(T, s); //一直往左走 找到中序遍历的起点

	while (t != NULL)
	{
		printf("%d ", t->data);

		//若结点 有右子树,重复步骤1
		if (t->rchild != NULL)
		{
			t = GoFarLeft(t->rchild, s);
		}
		//若结点 没有右子树 看栈是否为空
		else if ( !s.empty() )
		{
			t = s.top(); //把栈顶弹出 
			s.pop();
		}
		else
		{
			t = NULL;
		}
	}
}

void main()
{
	BiTNode  nodeA, nodeB, nodeC, nodeD, nodeE;

	nodeA.lchild = NULL;
	nodeA.rchild = NULL;
	nodeA.data = 0;
	memset(&nodeA, 0, sizeof(BiTNode));
	memset(&nodeB, 0, sizeof(BiTNode));
	memset(&nodeC, 0, sizeof(BiTNode));
	memset(&nodeD, 0, sizeof(BiTNode));
	memset(&nodeE, 0, sizeof(BiTNode));

	nodeA.data = 1;
	nodeB.data = 2;
	nodeC.data = 3;
	nodeD.data = 4;
	nodeE.data = 5;

	nodeA.lchild = &nodeB;
	nodeA.rchild = &nodeC;
	nodeB.lchild = &nodeD;
	nodeC.lchild = &nodeE;

	printf("\n中序遍历递归算法");
	InOrder(&nodeA);

	printf("\n中序遍历非递归算法");
	MyInOrder(&nodeA);

	

	
	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

dm02_树的操作.c



#define  _CRT_SECURE_NO_WARNINGS 
#include <stdlib.h>
#include <string.h>
#include <stdio.h>


//1 
typedef struct BiTNode
{
	int		data;
	struct BiTNode *lchild, *rchild;
}BiTNode;

typedef struct BiTNode * BiTree;

//先序遍历
void preOrder(BiTNode *T)
{
	if (T == NULL)
	{
		return ;
	}
	printf("%d ", T->data); //

	if (T->lchild != NULL)
	{
		preOrder(T->lchild);
	}

	if (T->rchild != NULL)
	{
		preOrder(T->rchild);
	}
}


void InOrder(BiTNode *T)
{
	if (T == NULL)
	{
		return ;
	}
	
	if (T->lchild != NULL)
	{
		InOrder(T->lchild);
	}

	printf("%d ", T->data); //

	if (T->rchild != NULL)
	{
		InOrder(T->rchild);
	}
}



void PostOrder(BiTNode *T)
{
	if (T == NULL)
	{
		return ;
	}

	if (T->lchild != NULL)
	{
		PostOrder(T->lchild);
	}

	if (T->rchild != NULL)
	{
		PostOrder(T->rchild);
	}

	printf("%d ", T->data); //
}

/*
		1
	2		3
4		5
*/


//求树的叶子结点的个数

int  sum = 0;
void coutLeafNum(BiTNode *T)
{
	if (T == NULL)
	{
		return ;
	}
	if (T->lchild == NULL && T->rchild ==NULL)
	{
		sum ++;
	}
	coutLeafNum(T->lchild); //求左子树的叶子结点个数

	coutLeafNum(T->rchild); //求右子树 叶子结点个数
}


//1 递归函数遇上全局变量 ===>函数参数
//2 //遍历的本质 强化
	//访问树的路径是相同的,是不过是计算叶子结点的时机不同....

void coutLeafNum2(BiTNode *T, int *sum)
{
	if (T == NULL)
	{
		return ;
	}
	if (T->lchild == NULL && T->rchild ==NULL)
	{
		//*sum++;
		//*sum = *sum +1;
		(*sum )++ ;  //++后置 ++   先*p 然后sum++
					//1   p++

					//1 是让实参++ 而不是让地址++
	}
	
	coutLeafNum2(T->lchild, sum); //求左子树的叶子结点个数

	coutLeafNum2(T->rchild, sum); //求右子树 叶子结点个数
}


void coutLeafNum3(BiTNode *T, int *sum)
{
	if (T == NULL)
	{
		return ;
	}

	coutLeafNum3(T->lchild, sum); //求左子树的叶子结点个数


	coutLeafNum3(T->rchild, sum); //求右子树 叶子结点个数

	if (T->lchild == NULL && T->rchild ==NULL)
	{
		(*sum )++ ;   //计算叶子结点
	}
}

//求树的高度
int Depth(BiTNode *T)
{
	int  depthval = 0;
	int  depthLeft = 0, depthRight = 0;

	if (T == NULL)
	{
		return 0;
	}

	depthLeft =  Depth(T->lchild); //求左子树的高度
	depthRight = Depth(T->rchild); //求右子树的高度

	//1 + 谁大要谁
	depthval = 1 + ( (depthLeft>depthRight) ? depthLeft :depthRight );
	return depthval;
}

//copy二叉树
BiTNode* CopyTree(BiTNode *T)
{
	BiTNode *newlptr = NULL;
	BiTNode *newRptr = NULL;
	BiTNode *newNode = NULL;

	if (T == NULL)
	{
		return NULL;
	}

	newlptr = CopyTree(T->lchild);
	newRptr = CopyTree(T->rchild);



	//new结点
	newNode = (BiTNode *)malloc(sizeof(BiTNode)) ; //
	if (newNode == NULL)
	{
		return NULL;
	}



	newNode->data = T->data; //从旧树中copy数据
	newNode->lchild = newlptr; //新的左子树
	newNode->rchild = newRptr; //新的右子树
	return newNode;
}


void main()
{
	BiTNode  nodeA, nodeB, nodeC, nodeD, nodeE;

	nodeA.lchild = NULL;
	nodeA.rchild = NULL;
	nodeA.data = 0;
	memset(&nodeA, 0, sizeof(BiTNode));
	memset(&nodeB, 0, sizeof(BiTNode));
	memset(&nodeC, 0, sizeof(BiTNode));
	memset(&nodeD, 0, sizeof(BiTNode));
	memset(&nodeE, 0, sizeof(BiTNode));

	nodeA.data = 1;
	nodeB.data = 2;
	nodeC.data = 3;
	nodeD.data = 4;
	nodeE.data = 5;

	nodeA.lchild = &nodeB;
	nodeA.rchild = &nodeC;
	nodeB.lchild = &nodeD;
	nodeC.lchild = &nodeE;

	//拷贝二叉树
	{
		BiTNode *newTree = NULL;
		newTree = CopyTree(&nodeA);
		printf("\n中序遍历新树:");
		InOrder(newTree);
	}

	{
		//求树的高度
		int depth = Depth(&nodeA);
		printf("depth:%d \n", depth);

	}

	//计算树的叶子结点
	{
		int mysum = 0;
		coutLeafNum(&nodeA);
		printf("sum:%d \n", sum);

		coutLeafNum2(&nodeA, &mysum);
		printf("mysum:%d \n", mysum);

		mysum = 0;
		coutLeafNum3(&nodeA, &mysum);
		printf("mysum:%d \n", mysum);

		
	}

	//printf("\n先序遍历树: ");
	//preOrder(&nodeA);

	printf("\n中序遍历树: ");
	InOrder(&nodeA);

	//printf("\n后序遍历树: ");
	//PostOrder(&nodeA);

	system("pause");
}


第16章数据结构day04

demo01_选择法.c

#include "stdio.h"
#include "stdlib.h"
#include "string.h"

void printArray01(int array[], int len)
{
	int i = 0;
	for(i=0; i<len; i++)
	{
		printf("%d ", array[i]);
	}
	printf("\n");
}

void swap01(int array[], int i, int j)
{
	int temp = array[i];
	array[i] = array[j];
	array[j] = temp;
}

void SelectionSort(int array[], int len) // O(n*n)
{
	int i = 0;
	int j = 0;
	int k = -1;

	/*
	for (i=0; i<10; ;i++)
	{
		for (j=i+1; j<10; j++)
		{
			if (a[i] < a[j])
			{
				tmp = a[i];
				a[i] = a[j];
				a[j] = tmp;
			}
		}
	}
	*/
	for(i=0; i<len; i++)
	{
		k = i; //寻找最小元素的下标
		for(j=i+1; j<len; j++)
		{
			if( array[j] < array[k] ) //开始寻找最小元素的下标
			{
				k = j;	
			}
		}

		//if (k != i)
		swap01(array, i, k);
	}
}

int main111()
{
	//int array[] = {12, 5, 433, 253, 216, 7};
	int array[] = {12, 5, 433, 253};
	int len = sizeof(array) / sizeof(*array); 

	printArray01(array, len);
	SelectionSort(array, len);
	printArray01(array, len);
	system("pause");
	return 0;
}


demo02_插入.c

#include "stdio.h"
#include "stdlib.h"
#include "string.h"

void printArray02(int array[], int len)
{
	int i = 0;

	for(i=0; i<len; i++)
	{
		printf("%d ", array[i]);
	}

	printf("\n");
}
void InertionSort(int array[], int len) // O(n*n)
{
	int i = 0;
	int j = 0;
	int k = -1;
	int temp = -1;

	//{12, 5, 433, 253, 216, 7};
	for(i=1; i<len; i++)
	{
		k = i; //待插入位置
		temp = array[k];

		for(j=i-1; (j>=0) && (array[j]>temp); j--)
		{ 
			array[j+1] = array[j]; //元素后移
			k = j; //k需要插入的位置
		}

		array[k] = temp;//元素插入
	}
}

int main222()
{
	int array[] = {12, 5, 433, 253, 216, 7};
	int len = sizeof(array) / sizeof(*array); 

	printArray02(array, len);
	InertionSort(array, len);
	printArray02(array, len);
	system("pause");
	return 0;
}


demo03_冒泡.c

#include "stdio.h"
#include "stdlib.h"
#include "string.h"

void printfArray03(int array[], int len)
{
	int i = 0;

	for(i=0; i<len; i++)
	{
		printf("%d ", array[i]);
	}
	printf("\n");
}

void swap03(int array[], int i, int j)
{
	int temp = array[i];
	array[i] = array[j];
	array[j] = temp;
}

void BubbleSort(int array[], int len) // O(n*n)
{
	int i = 0;
	int j = 0;
	//{8,3,6,1};
	int exchange = 1; //表明数组是否已经排好序 已经排好序为0   1表示没有排好序
	//1假设第一趟比较 已经排好序 在进行第二趟比较时候 exchange===0
	//2 因为第一趟已经排好序,所以第2趟,没有机会执行 39
	//3 当第3趟比较的时候 exchange==0  不满足外层循环条件,跳出外层循环..
	for(i=0; (i<len) && exchange; i++)
	{
		exchange = 0;//认为已经排序完毕
		for(j=len-1; j>i; j--)
		{
			if( array[j] < array[j-1] )
			{
				swap03(array, j, j-1);
				exchange = 1;// 如果35 36行被执行，说明还没有排好序
			}
		}
	}
}

int main31()
{
	int array[] ={8,3,6,1};
	int len = sizeof(array) / sizeof(*array); 
	printfArray03(array, len);
	BubbleSort(array, len);
	printfArray03(array, len);
	system("pause");
	return 0;
}

demo04_希尔排序法.c

#include "stdio.h"
#include "stdlib.h"
#include "string.h"

void println(int array[], int len)
{
	int i = 0;

	for(i=0; i<len; i++)
	{
		printf("%d ", array[i]);
	}

	printf("\n");
}
void swap(int array[], int i, int j)
{
	int temp = array[i];
	array[i] = array[j];
	array[j] = temp;
}

void InertionSort_ddddd(int array[], int len) // O(n*n)
{
	int i = 0;
	int j = 0;
	int k = -1;
	int temp = -1;
	//{12, 5, 433, 253, 216, 7};
	for(i=1; i<len; i++)
	{
		k = i; //待插入位置
		temp = array[k];

		for(j=i-1; (j>=0) && (array[j]>temp); j--)
		{ 
			array[j+1] = array[j]; //元素后移
			k = j; //k需要插入的位置
		}

		array[k] = temp;//元素插入
	}
}
void ShellSort(int array[], int len) //
{
	int i = 0;
	int j = 0;
	int k = -1;
	int temp = -1;
	int gap = len;
	do
	{
		 //业界统一实验的 平均最好情况 经过若干次后，收敛为1
		gap = gap / 3 + 1; //gap /2345 2000 都行  //O（n 1.3） gap = 1;
	
		for(i=gap; i<len; i+=gap)
		{
			k = i;
			temp = array[k];

			for(j=i-gap; (j>=0) && (array[j]>temp); j-=gap)
			{
				array[j+gap] = array[j];
				k = j;
			}
			array[k] = temp;
		}
	}while( gap > 1 );
}


int main4111()
{
	int array[] = {12, 5, 433, 253, 216, 7};
	int len = sizeof(array) / sizeof(*array); 

	println(array, len);
	ShellSort(array, len);
	println(array, len); 
	system("pause");
	return 0;
}


demo05_快速排序.c

void printArray05(int array[], int len)
{
	int i = 0;

	for(i=0; i<len; i++)
	{
		printf("%d ", array[i]);
	}

	printf("\n");
}

void swap5(int array[], int i, int j)
{
	int temp = array[i];
	array[i] = array[j];
	array[j] = temp;
}
//划分过程 第一个元素当枢轴，分成2个有效子序列
int partition(int array[], int low, int high)
{
	int pv = array[low];

	while( low < high )
	{
		while( (low < high) && (array[high] >= pv) )
		{
			high--; //比基准大，本来就在右边，所以high前移动
		}
		swap5(array, low, high);
		while( (low < high) && (array[low] <= pv) )
		{
			low++;
		}
		swap5(array, low, high);
	}
	//返回枢轴的位置。。。重要
	return low;
}


void QSort(int array[], int low, int high)
{
	if( low < high )
	{
		//选一个pv值，把数据分别放在pv值得左右两边，并把pivot位置返回出来。。
		int pivot = partition(array, low, high);

		//对子序列1排序
		QSort(array, low, pivot-1);
		//对子序列2排序
		QSort(array, pivot+1, high);
	}
}

void QuickSort(int array[], int len) // O(n*logn)
{
	QSort(array, 0, len-1);
}

int main555()
{
	//int array[] = {12, 5, 433, 253, 216, 7};
	int array[] = {21,100, 3, 50, 1};
	//int array[] = {12, 5, 433};
	//int array[] = {12, 5};
	int len = sizeof(array) / sizeof(*array); 
	printArray05(array, len);
	QuickSort(array, len);
	printArray05(array, len);
	system("pause");
	return 0;
}


demo06_归并算法.c

#include <stdio.h>
#include <malloc.h>

void printArray06(int array[], int len)
{
	int i = 0;
	for(i=0; i<len; i++)
	{
		printf("%d ", array[i]);
	}
	printf("\n");
}

void swap6(int array[], int i, int j)
{
	int temp = array[i];
	array[i] = array[j];
	array[j] = temp;
}

void Merge(int src[], int des[], int low, int mid, int high)
{
	int i = low;
	int j = mid + 1;
	int k = low;

	while( (i <= mid) && (j <= high) ) //将小的放到目的地中
	{
		if( src[i] < src[j] )
		{
			des[k++] = src[i++];
		}
		else
		{
			des[k++] = src[j++];
		}
	}

	while( i <= mid )  //若还剩几个尾部元素
	{
		des[k++] = src[i++];
	}

	while( j <= high ) //若还剩几个尾部元素
	{
		des[k++] = src[j++];
	}
}

//每次分为两路 当只剩下一个元素时，就不需要在划分
void MSort(int src[], int des[], int low, int high, int max)
{
	if( low == high ) //只有一个元素，不需要归并，结果赋给des[low]
	{
		des[low] = src[low]; 
	}
	else //如果多个元素，进行两路划分
	{
		int mid = (low + high) / 2;
		int* space = (int*)malloc(sizeof(int) * max);

		//递归进行两路，两路的划分 
		//当剩下一个元素的时，递归划分结束，然后开始merge归并操作
		if( space != NULL )
		{
			MSort(src, space, low, mid, max); 
			MSort(src, space, mid+1, high, max);
			Merge(space, des, low, mid, high); //调用归并函数进行归并
		}

		free(space);
	}
}

void MergeSort(int array[], int len) // O(n*logn)
{
	MSort(array, array, 0, len-1, len);
}

int main()
{
	
	//int array[] = {21, 25, 49, 25, 16, 8};
	int array[] = {21, 25};
	int len = sizeof(array) / sizeof(*array); 
	printArray06(array, len);
	MergeSort(array, len);
	printArray06(array, len);
	system("pause");
	return 0;
}


dm03_创建树.c


#define  _CRT_SECURE_NO_WARNINGS 
#include <stdlib.h>
#include <string.h>
#include <stdio.h>


typedef struct BiTNode
{
	int		data;
	struct BiTNode *lchild, *rchild;
}BiTNode;

typedef struct BiTNode * BiTree;


void InOrder(BiTNode *T)
{
	if (T == NULL)
	{
		return ;
	}

	if (T->lchild != NULL)
	{
		InOrder(T->lchild);
	}

	printf("%c ", T->data); //

	if (T->rchild != NULL)
	{
		InOrder(T->rchild);
	}
}

// "1##"
// 124###3##

//创建树 用先序
BiTNode *BiTree_Creat()
{
	BiTNode  *tmp = NULL;
	char  ch;
	scanf("%c", &ch);

	if (ch == '#')
	{
		return NULL;
	}
	else
	{
		
		tmp = (BiTNode *) malloc(sizeof(BiTNode)); //创建结点
		if (tmp == NULL)
		{
			return NULL;
		}
		tmp->data = ch;
		tmp->lchild = NULL;
		tmp->rchild = NULL; 
		//在创建结点的左子树
		tmp->lchild = BiTree_Creat();
		tmp->rchild = BiTree_Creat();
		return tmp;
	}
}

//释放树 选释放左子树 在释放右子树 在释放根结点
void BiTree_Free(BiTNode *T)
{
	if (T == NULL)
	{
		return ;
	}

	if (T->lchild != NULL)
	{
		BiTree_Free(T->lchild); //释放左子树 把左子树的根结点 传给释放函数
		T->lchild = NULL;
	}

	if (T->rchild != NULL)
	{
		BiTree_Free(T->rchild);
		T->rchild = NULL;
	}

	free(T);

	//

}
void main()
{
	BiTNode  *T = NULL;
	printf("#号法创建树 请输入字符串 ( 124###3## ): ");
	T  = BiTree_Creat();
	InOrder(T);

	BiTree_Free(T);


	printf("hello...\n");
	system("pause");
	return ;
}

dm04_树的线索化.c

#define  _CRT_SECURE_NO_WARNINGS 
#include "string.h"
#include "stdio.h"    
#include "stdlib.h"   

/* Link==0表示指向左右孩子指针, */
/* Thread==1表示指向前驱或后继的线索 */
#define Thread 1
#define Link	0

typedef  struct BiThrNode	/* 二叉线索存储结点结构 */
{
	char		data;	/* 结点数据 */
	struct BiThrNode *lchild, *rchild;	/* 左右孩子指针 */
	int			LTag;
	int			RTag;		/* 左右标志 */
} BiThrNode, *BiThrTree;

char Nil='#'; /* 字符型以空格符为空 */

/* 按前序输入二叉线索树中结点的值,构造二叉线索树T */
BiThrNode* CreateBiThrTree()
{ 
	BiThrNode *tmp = NULL;
	char ch;
	scanf("%c",&ch);

	if (ch == '#')
	{
		return NULL;
	}	
	else
	{
		tmp = (BiThrNode *)malloc(sizeof(BiThrNode));
		if (tmp == NULL)
		{
			return NULL;
		}
		memset(tmp, 0, sizeof(BiThrNode));
		tmp->data = ch;

		tmp->lchild = CreateBiThrTree(); /* 递归构造左子树 */
		tmp->rchild = CreateBiThrTree();
	}
	return tmp;
}

BiThrNode  *pre; /* 全局变量,始终指向刚刚访问过的结点 */
/* 中序遍历进行中序线索化 */
void InThreading(BiThrNode *p)
{ 
	if(p)
	{
		InThreading(p->lchild); // 递归左子树线索化 
		if(p->lchild == NULL)	// 没有左孩子 
		{
			p->LTag = Thread; 	 p->lchild = pre;	//前驱线索 左孩子指针指向前驱 
		}
		if(pre->rchild == NULL) // 前驱没有右孩子 
		{
			pre->RTag = Thread;  pre->rchild = p;	// 后继线索 前驱右孩子指针指向后继(当前结点p) 
		}
		pre = p;				// 保持pre指向p的前驱 
		InThreading(p->rchild); // 递归右子树线索化 
	}
}

/* 中序遍历二叉树T,并将其中序线索化,Thrt指向头结点 */
BiThrNode* InOrderThreading(BiThrTree T)
{
	BiThrNode *Thrt = NULL;

	Thrt = (BiThrNode *)malloc(sizeof(BiThrNode)); //建头结点 
	if (Thrt == NULL)
	{
		return NULL;
	}
	memset(Thrt, 0, sizeof(BiThrNode));

	Thrt->LTag = Link;  //左孩子为孩子指针
	Thrt->RTag = Thread; //右孩子为线索化的指针
	Thrt->rchild = Thrt; // 右指针回指 */  //步骤2和4
	if(T == NULL) // 若二叉树空,则左指针回指 
	{
		Thrt->lchild  = Thrt; //步骤1和3
	}
	else
	{
		Thrt->lchild = T;	//步骤1 
		pre = Thrt ;
		InThreading(T);		// 中序遍历进行中序线索化 
		pre->rchild = Thrt;	//步骤4
		pre->RTag = Thread;	// 最后一个结点线索化 
		Thrt->rchild = pre;	//步骤2
	}
	return Thrt;
}

/* 中序遍历二叉线索树T(头结点)的非递归算法 */
int InOrderTraverse_Thr(BiThrNode* T)
{ 
	BiThrNode* p;
	p = T->lchild; /* p指向根结点 */
	while (p != T)
	{ 
		/* 空树或遍历结束时,p==T */
		while (p->LTag == Link)
			p = p->lchild;
		printf("%c ", p->data);

		//如果中序遍历的最后一个结点的 右孩子 == T 说明到最后一个结点 ,遍历结束..
		while (p->RTag==Thread && p->rchild!=T)
		{
			p = p->rchild;
			printf("%c ", p->data);
		}
		p = p->rchild;
	}
	return 0;
}

/* 中序遍历二叉线索树T(头结点)的非递归算法 */
int InOrderTraverse_Thr2(BiThrNode* T)
{ 
	BiThrNode* p;
	p = T->rchild; /* p指向根结点 */
	while (p != T)
	{ 
		/* 空树或遍历结束时,p==T */
		while (p->RTag == Link)
			p = p->rchild;
		printf("%c ", p->data);

		//如果中序遍历的最后一个结点的 右孩子 == T 说明到最后一个结点 ,遍历结束..
		while (p->LTag==Thread && p->lchild!=T)
		{
			p = p->lchild;
			printf("%c ", p->data);
		}
		p = p->lchild;
	}
	return 0;
}


int main()
{
	BiThrTree T, H;
	printf("请按前序输入二叉树(如:'ABDH##I##EJ###CF##G##')\n");
	T = CreateBiThrTree(); // 按前序产生二叉树 
	H = InOrderThreading(T); // 中序遍历,并中序线索化二叉树 
	printf("中序遍历(输出)二叉线索树:\n");
	InOrderTraverse_Thr(H); // 中序遍历(输出)二叉线索树 

	printf("\n逆序访问:");
	InOrderTraverse_Thr2(H);

	printf("\n");

	system("pause");
	return 0;
}






第17章  数据结构day05

LinkList.h



#pragma  once

#include <iostream>
using namespace std;

template <typename T>
struct Node
{
	T		t;
	Node<T>  *next;
	//Node<T>  *pre;
};

template <typename T>
class LinkList
{
public:
	LinkList();
	~LinkList();

public:
	void	clear();
	int		length();
	int		insert(T &t, int pos);
	int		get(int pos, T &t);
	int		del(int pos, T &t);
protected:
	Node<T> *m_header;
	int		m_len;
};

template <typename T>
LinkList<T>::LinkList()
{
	m_header = new Node<T>;
	m_header->next = NULL; //注意
	m_len = 0;
}

template <typename T>
LinkList<T>::~LinkList()
{
	clear();
	delete m_header;
	m_len = 0;

}

template <typename T>
void LinkList<T>::clear()
{
	//销毁一个链表

	Node<T> *tmp = NULL;
	
	while (m_header != NULL)
	{
		tmp = m_header->next;
		delete m_header;
		m_header = tmp;
	}

	m_header = new Node<T>;
	m_header->next = NULL; //注意
	m_len = 0;
}

template <typename T>
int	 LinkList<T>::length()
{
	return m_len;
}

template <typename T>
int	LinkList<T>::insert(T &t, int pos)
{
	Node<T> *current = NULL;
	Node<T> *node = NULL;

	current = m_header; //赋值指针变量 初始化
	for (int i=0; i<pos; i++)
	{
		current = current->next;
	}

	node = new Node<T>;
	node->next = NULL;
	node->t = t; //1 把用户的结点,缓存到容器中   2 t应该可以被= 

	node->next = current->next;
	current->next = node;
	m_len ++;
	return 0;
}

template <typename T>
int	LinkList<T>::get(int pos, T &t)
{
	Node<T> *current = NULL;

	current = m_header; //赋值指针变量 初始化
	for (int i=0; i<pos; i++)
	{
		current = current->next;
	}
	t = current->next->t;  //把容器中缓存的结点 = 给上层应用
	return 0;
}

template <typename T>
int	LinkList<T>::del(int pos, T &t)
{
	Node<T> *current = NULL;
	Node<T> *ret = NULL;

	current = m_header; //赋值指针变量 初始化
	for (int i=0; i<pos; i++)
	{
		current = current->next;
	}

	ret = current->next;
	t = ret->t; //把容器中缓存的结点 = 给上层应用

	//删除
	current->next = ret->next;

	delete ret ;//modify by bombing 

	m_len --;

	return 0;
}





dm01_链表类_链式存储.cpp


#include <iostream>
using namespace std;

#include "LinkList.hpp"

class Teacher01
{
public:
protected:
public:
	char name[32];
	int age;
};

void main11()
{
	
	Teacher01 t1, t2, t3, tmp;
	t1.age = 31;
	t2.age = 32;
	t3.age = 33;

	LinkList<Teacher01> list;

	//插入元素 
	list.insert(t1, 0);
	list.insert(t2, 0);
	list.insert(t3, 0);

	//遍历 
	for (int i=0; i<list.length(); i++)
	{
		list.get(i, tmp);
		cout << tmp.age << " ";
	}

	/*
	//删除
	while (list.length() > 0)
	{
		list.del(0, tmp);
		cout << tmp.age << " ";
	}
	*/

	list.clear();
	return ;
}


void main12()
{
	main11();
	cout<<"hello..."<<endl;
	system("pause");
}

LinkStack.h



#pragma  once

#include "LinkList.hpp"

template <typename T>
class LinkStack  
{
public:
	LinkStack();
	~LinkStack();
public:
	int clear();
	int push(T &t);
	int pop(T &t);
	int top(T &t);
	int size();
protected:
	LinkList<T> *m_list; //
};

template <typename T>
LinkStack<T>::LinkStack()
{
	m_list = new LinkList<T>;
}

template <typename T>
LinkStack<T>::~LinkStack()
{
	clear();
	delete m_list;
	m_list = NULL;
}

template <typename T>
int LinkStack<T>::clear()
{
	T t;
	while (m_list->length() > 0)
	{
		m_list->del(0, t);
	}
	return 0;
}

template <typename T>
int LinkStack<T>::push(T &t)
{
	return m_list->insert(t, 0);
}

template <typename T>
int LinkStack<T>::pop(T &t)
{
	return m_list->del(0, t);
}

template <typename T>
int LinkStack<T>::top(T &t)
{
	return m_list->get(0, t);
}

template <typename T>
int LinkStack<T>::size()
{
	return m_list->length();
}




dm02_栈类_链式存储.cpp


#include <iostream>
using namespace std;
#include "LinkStack.hpp"

class Teacher02
{
public:
protected:
public:
	char name[32];
	int age;
};

void main21()
{
	Teacher02 t1, t2, t3, tmp;
	t1.age = 31;
	t2.age = 32;
	t3.age = 33;

	//创建栈 
	LinkStack<Teacher02> stack;

	//压栈
	stack.push(t1);
	stack.push(t2);
	stack.push(t3);

	//遍历
	stack.top(tmp);
	cout << tmp.age << "\n";


	//出栈
	while (stack.size() > 0)
	{
		stack.pop(tmp);
		cout << tmp.age << " ";
	}
	stack.clear();
}

void main22()
{
	main21();
	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

LinkQueue.h

#pragma  once

#include "LinkList.hpp"

template <typename T>
class LinkQueue
{
public:
	LinkQueue();
	~LinkQueue();
public:
	int clear();
	int append(T &t);
	int retieve(T &t);
	int header(T &t);
	int length();

protected:
	LinkList<T>* m_list;
};

template <typename T>
 LinkQueue<T>::LinkQueue()
 {
	 m_list = new LinkList<T>;
 }

 template <typename T>
 LinkQueue<T>::~LinkQueue()
 {
	 clear();
	 delete m_list;
	 m_list = NULL;
 }

 template <typename T>
 int LinkQueue<T>::clear()
 {
	 T t;
	 while (length() > 0)
	 {
		 retieve(t);
	 }
	 return 0;
 }

 template <typename T>
 int LinkQueue<T>::append(T &t)
 {
	  return m_list->insert(t, m_list->length());
 }

 template <typename T>
 int LinkQueue<T>::retieve(T &t)
 {
	  return m_list->del(0, t);
 }

 template <typename T>
 int LinkQueue<T>::header(T &t)
 {
	  return m_list->get(0, t);
 }

 template <typename T>
 int LinkQueue<T>::length()
 {
	  return m_list->length();
 }



dm03_队列类_链式存储.cpp


#include <iostream>
using namespace std;
#include "LinkQueue.hpp"

class Teacher03
{
public:
protected:
public:
	char name[32];
	int age;
};

void main31()
{
	Teacher03 t1, t2, t3, tmp;
	t1.age = 31;
	t2.age = 32;
	t3.age = 33;

	//创建队列
	LinkQueue<Teacher03> queue;

	//
	queue.append(t1);
	queue.append(t2);
	queue.append(t3);

	while (queue.length() > 0)
	{
		queue.retieve(tmp);
		cout << tmp.age << " ";
	}
	
	queue.clear();

}

void main33()
{
	main31();
	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

SeqList.h


#pragma  once

#include <iostream>
using namespace std;


template <typename T>
class SeqList
{
public:
	SeqList(int capacity=20);
	~SeqList();

public:
	int clear();
	int length();
	int capacity();
	int insert(T &t, int pos);
	int get(int pos, T &t);
	int del(int pos, T &t);
protected:
	int		m_capacity;
	int		m_len;
	T		*m_array;
};

template <typename T>
SeqList<T>::SeqList(int capacity=20)
{
	m_capacity = capacity;
	m_len = 0;
	m_array = new T[m_capacity];

	return ;
}
template <typename T>
SeqList<T>::~SeqList()
{
	delete [] m_array ;
	m_array = NULL;
	m_len = 0;
	m_capacity = 0; //fei hua
	return ;
}

template <typename T>
int SeqList<T>::clear()
{
	m_len = 0;
	return 0;
}

template <typename T>
int SeqList<T>::length()
{
	return m_len;
}

template <typename T>
int SeqList<T>::capacity()
{
	return m_capacity;
}

template <typename T>
int SeqList<T>::insert(T &t, int pos)
{
	int i = 0;
	for (i=m_len; i>pos; i--)  //n
	{
		m_array[i] = m_array[i-1];
	}

	m_array[i] = t; // 1把上层应用的t缓存在数组中  2若t是类对象,则类要保证能够被=,避免深拷贝浅拷贝问题
	m_len ++;
	return 0;
}

template <typename T>
int SeqList<T>::get(int pos, T &t)
{
	t = m_array[pos];//把容器缓存的 等号给t
	return 0;
}

template <typename T>
int SeqList<T>::del(int pos, T &t)
{
	int i = 0;
	t = m_array[pos];

	// pos = 3
	for (i=pos+1; i<m_len; i++)
	{
		m_array[i-1] = m_array[i];

	}
	m_len --;
	return 0;
}




dm04_链表类_顺序存储.cpp


#include <iostream>
using namespace std;

#include "SeqList.hpp"

class Teacher04
{
public:
protected:
public:
	char name[32];
	int age;
};

void main41()
{

	Teacher04 t1, t2, t3, tmp;
	t1.age = 31;
	t2.age = 32;
	t3.age = 33;

	//创建一个seq链表
	SeqList<Teacher04> list;

	list.insert(t1, 0);
	list.insert(t2, 0);
	list.insert(t3, 0);

	//遍历

	for (int i=0; i<list.length(); i++)
	{
		list.get(i, tmp);
		cout << tmp.age << " ";
	}

	cout << "删除" << endl;
	while ( list.length() > 0)
	{
		list.del(0, tmp);
		cout << tmp.age << " ";
	}
	list.clear();
}

void main44()
{
	main41();
	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

SeqStack.h

#pragma  once

#include "SeqList.hpp"

template <typename T>
class SeqStack
{
public:
	SeqStack(int capacity = 20);
	~SeqStack();
public:
	int clear();
	int push(T &t);
	int pop(T &t);
	int top(T &t);
	int size();
	int capacity();
protected:
	SeqList<T> *m_list;
};

template <typename T>
SeqStack<T>::SeqStack(int capacity = 20)
{
	m_list = new SeqList<T>(capacity);
}

template <typename T>
SeqStack<T>::~SeqStack()
{
	clear();
	delete m_list;
	m_list = NULL;
}

template <typename T>
int SeqStack<T>::clear()
{
	T t;
	while (size() > 0 )
	{
		pop(t);
	}
	return 0;
}

template <typename T>
int SeqStack<T>::push(T &t)
{
	return m_list->insert(t, m_list->length());
}

template <typename T>
int SeqStack<T>::pop(T &t)
{
	return m_list->del(m_list->length()-1, t); //10个元素 数组下表为9
}

template <typename T>
int SeqStack<T>::top(T &t)
{
	return m_list->get(m_list->length()-1, t);
}

template <typename T>
int SeqStack<T>::size()
{
	return m_list->length();
}

template <typename T>
int SeqStack<T>::capacity()
{
	return m_list->capacity();
}


dm05_栈类_顺序存储.cpp



#include <iostream>
using namespace std;

#include "SeqStack.hpp"

class Teacher05
{
public:
protected:
public:
	char name[32];
	int age;
};

void main51()
{
	Teacher05 t1, t2, t3, tmp;
	t1.age = 31;
	t2.age = 32;
	t3.age = 33;

	//创建栈 
	SeqStack<Teacher05> stack;

	stack.push(t1);
	stack.push(t2);
	stack.push(t3);

	//出栈
	while (stack.size() > 0)
	{
		stack.pop(tmp);
		cout << tmp.age << " ";
	}
	stack.clear();

}


void main55()
{
	main51();
	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

LinkQueue.h

#pragma  once

#include "LinkList.hpp"

template <typename T>
class LinkQueue
{
public:
	LinkQueue();
	~LinkQueue();
public:
	int clear();
	int append(T &t);
	int retieve(T &t);
	int header(T &t);
	int length();

protected:
	LinkList<T>* m_list;
};

template <typename T>
 LinkQueue<T>::LinkQueue()
 {
	 m_list = new LinkList<T>;
 }

 template <typename T>
 LinkQueue<T>::~LinkQueue()
 {
	 clear();
	 delete m_list;
	 m_list = NULL;
 }

 template <typename T>
 int LinkQueue<T>::clear()
 {
	 T t;
	 while (length() > 0)
	 {
		 retieve(t);
	 }
	 return 0;
 }

 template <typename T>
 int LinkQueue<T>::append(T &t)
 {
	  return m_list->insert(t, m_list->length());
 }

 template <typename T>
 int LinkQueue<T>::retieve(T &t)
 {
	  return m_list->del(0, t);
 }

 template <typename T>
 int LinkQueue<T>::header(T &t)
 {
	  return m_list->get(0, t);
 }

 template <typename T>
 int LinkQueue<T>::length()
 {
	  return m_list->length();
 }



dm06_队列类_顺序存储.cpp



#include <iostream>
using namespace std;

#include "SeqQueue.hpp"


class Teacher06
{
public:
protected:
public:
	char name[32];
	int age;
};

void main61()
{
	Teacher06 t1, t2, t3, tmp;
	t1.age = 31;
	t2.age = 32;
	t3.age = 33;

	
	//创建队列
	SeqQueue<Teacher06> queue(11);

	queue.append(t1);
	queue.append(t2);
	queue.append(t3);

	while (queue.length() > 0)
	{
		queue.retrieve(tmp);
		cout << tmp.age << " ";
	}

	queue.clear();

}

void main()
{
	main61();
	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

第18章 C++进阶设计模式

dm01_Singelton.cpp


#include <iostream>
using namespace std;

class Singelton
{
private:
	//
	Singelton()
	{
		cout << "Singelton 构造函数 begin\n";
		sleep(1000);
		cout << "Singelton 构造函数 end\n";
	}
	~Singelton()
	{
		cout << "Singelton 析构函数 begin\n";
		if (m_single != NULL)
		{
			delete m_single;
			m_single = NULL;
		}
		cout << "Singelton 析构构造函数 end\n";
	}
public:
	static Singelton * getSingelton()
	{
		//只有在使用   Singelton::getSingelton()时候,才创建对象 
		//这种模式 是懒汉式
		if (m_single == NULL)
		{
			m_single = new Singelton;
			return m_single;
		}
		else
		{
			return m_single;
		}
	}
	
	static void  FreeSingelton()
	{
		//只有在使用   Singelton::getSingelton()时候,才创建对象 
		//这种模式 是懒汉式
		if (m_single != NULL)
		{
			delete m_single;
			m_single = NULL;
		}

	}
protected:
private:
	static Singelton *m_single ;
};
Singelton * Singelton::m_single = NULL ;

void main11()
{
	Singelton *s1 = Singelton::getSingelton();
	Singelton *s2 = Singelton::getSingelton();
	if (s1 == s2)
	{
		cout << "s1和s2 相等" << endl;
	}
	else
	{
		cout << "s1和s2 不相等" << endl;
	}
	FreeSingelton();
}

void main()
{
	main11();
	cout<<"hello..."<<endl;
	system("pause");
}

dm01_懒汉式单例和多线程.cpp

// 单例和多线程.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include "windows.h"
#include "winbase.h"
#include <process.h>
#include "iostream"

#include <iostream>
using namespace std;


class Singelton
{
private:
	//
	Singelton()
	{
		s_count ++;
		cout << "Singelton 构造函数 begin\n";
		Sleep(1000);
		cout << "Singelton 构造函数 end\n";
	}
	~Singelton()
	{
		cout << "Singelton 析构函数 begin\n";
		if (m_single != NULL)
		{
			delete m_single;
			m_single = NULL;
		}
		cout << "Singelton 析构构造函数 end\n";
	}
	
public:
	static Singelton * getSingelton()
	{
		//只有在使用   Singelton::getSingelton()时候,才创建对象 
		//这种模式 是懒汉式
		if (m_single == NULL)
		{
			m_single = new Singelton;
			return m_single;
		}
		else
		{
			return m_single;
		}
	}

	static void freeSingelton()
	{
		if (m_single != NULL)
		{
			delete m_single;
			m_single = NULL;
		}
	}

	static void printS()
	{
		cout << "s_count:" <<s_count <<"\n" ;
	}

private:
	static Singelton *m_single ;
	static int s_count;
};
Singelton * Singelton::m_single = NULL ;
 int Singelton::s_count = 0;

 void ThreadFunc (void *p)
{
	Singelton::getSingelton()->printS();
}

void _tmain(int argc, _TCHAR* argv[])
{
	int		i = 0;
	HANDLE threadID[100];

	for (i=0; i<3; i++)
	{
		threadID[i] = (HANDLE)_beginthread(ThreadFunc, 0, NULL);
		if ( threadID[i]  == NULL)
		{
			printf("启动线程失败....\n");
			return ;
		}
	}
	
	//
	for (i=0; i<3; i++)
	{
		WaitForSingleObject(threadID[i], INFINITE);
	}

	//Singelton::freeSingelton();
	
	cout << "hello..." << endl;
	system("pause");
	return ;
}



dm02_Singelton.cpp


#include <iostream>
using namespace std;

class Singelton
{
private:
	Singelton()
	{
		cout << "Singelton 构造函数 begin\n";
		cout << "Singelton 构造函数 end\n";
	}
	~Singelton()
	{
		cout << "Singelton 析构函数 begin\n";
		if (m_single != NULL)
		{
			delete m_single;
			m_single = NULL;
		}
		cout << "Singelton 析构构造函数 end\n";
	}
public:
	static Singelton * getSingelton()
	{
		return m_single;
	}
protected:
private:
	static Singelton *m_single ;
};

//int Singelton::g_a = 10;
//定义类的时候  就把类的对象给new出来

//饿汉式
Singelton * Singelton::m_single = new Singelton ;

void main11()
{
	cout << "hello.....\n";
	Singelton *s1 = Singelton::getSingelton();
	Singelton *s2 = Singelton::getSingelton();
	if (s1 == s2)
	{
		cout << "s1和s2 相等" << endl;
	}
	else
	{
		cout << "s1和s2 不相等" << endl;
	}

}

void main()
{
	main11();
	cout<<"hello..."<<endl;
	system("pause");
}

dm02_饿汉式遇见多线程.cpp

// 单例和多线程.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include "windows.h"
#include "winbase.h"
#include <process.h>
#include "iostream"

#include <iostream>
using namespace std;


class Singelton
{
private:
	//构造函数 不能保证线程安全化
	Singelton()
	{
		s_count ++;
		cout << "Singelton 构造函数 begin\n";
		Sleep(1000);
		cout << "Singelton 构造函数 end\n";
	}
	~Singelton()
	{
		cout << "Singelton 析构函数 begin\n";
		if (m_single != NULL)
		{
			delete m_single;
			m_single = NULL;
		}
		cout << "Singelton 析构构造函数 end\n";
	}

public:
	static Singelton * getSingelton()
	{
		return m_single;	
	}

	static void freeSingelton()
	{
		if (m_single != NULL)
		{
			delete m_single;
			m_single = NULL;
		}
	}

	static void printS()
	{
		cout << "s_count:" <<s_count <<"\n" ;
	}

private:
	static Singelton *m_single ;
	static int s_count;
};
Singelton * Singelton::m_single = new Singelton ;
int Singelton::s_count = 0;

void ThreadFunc (void *p)
{
	Singelton::getSingelton()->printS();
}

void _tmain(int argc, _TCHAR* argv[])
{
	int		i = 0;
	HANDLE threadID[100];

	for (i=0; i<3; i++)
	{
		threadID[i] = (HANDLE)_beginthread(ThreadFunc, 0, NULL);
		if ( threadID[i]  == NULL)
		{
			printf("启动线程失败....\n");
			return ;
		}
	}

	//
	for (i=0; i<3; i++)
	{
		WaitForSingleObject(threadID[i], INFINITE);
	}

	//Singelton::freeSingelton();

	cout << "hello..." << endl;
	system("pause");
	return ;
}



dm03_简单工厂.cpp


#include <iostream>
using namespace std;

class Fruit
{
public:
	virtual void sayFruit() = 0;
protected:
private:
};


class Banana : public Fruit
{
public:
	virtual void sayFruit()
	{
		cout << "我是香蕉\n";
	}
protected:
private:
};

class Pear : public Fruit
{
public:
	virtual void sayFruit()
	{
		cout << "我是 Pear\n";
	}
protected:
private:
};

class Factory
{
public:
	static Fruit *Create(char *name)
	{
		if (strcmp(name, "pear") == 0)
		{
			return new Pear;
		}
		else if (strcmp(name, "banana") == 0)
		{
			return new Banana;
		}	
		return NULL;
	}

protected:
private:
};
void main()
{
	Fruit *fruit = NULL;

	//
	fruit = Factory::Create("pear");
	fruit->sayFruit();
	delete fruit;

	//
	fruit = Factory::Create("banana");
	fruit->sayFruit();  //多态是设计模式的基础  是框架的基石
	delete fruit;


	
	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

dm03_懒汉式多线程.cpp


//#include "stdafx.h"
//#include "windows.h"
//#include "winbase.h"
//#include <process.h>
#include "iostream"

using namespace std;
class Singelton
{
private:
	Singelton()
	{
		count ++;
		cout<<"Singelton构造函数begin\n"<<endl;
		Sleep(1000);
		cout<<"Singelton构造函数end\n"<<endl;

	}
private:
	//防止拷贝构造和赋值操作
	Singelton(const Singelton &obj) { ;}
	Singelton& operator=(const Singelton &obj)	{ ;}
public:
	static Singelton *getSingelton()
	{
		//1"懒汉"模式虽然有优点，但是每次调用GetInstance()静态方法时，必须判断
		//	NULL == m_instance，使程序相对开销增大。
		//2多线程中会导致多个实例的产生，从而导致运行代码不正确以及内存的泄露。
		//3提供释放资源的函数
		return single;
	}

	static Singelton *releaseSingelton()
	{
		if (single != NULL) //需要判断
		{
			cout<<"释放资源\n"<<endl;
			delete single;
			single = NULL;
		}
		return single;
	}
	void pirntS() //测试函数
	{
		printf("Singelton printS test count:%d \n", count);
	}

private:
	static Singelton *single;
	static int count;
};

//note 静态变量类外初始化
Singelton *Singelton::single = new Singelton();
int Singelton::count = 0;

int _tmainTTT(int argc, _TCHAR* argv[])
{
	Singelton *s1 = Singelton::getSingelton();
	Singelton *s2 = Singelton::getSingelton();
	if (s1 == s2)
	{
		cout<<"ok....equal"<<endl;
	}
	else
	{
		cout<<"not.equal"<<endl;
	}
	s1->pirntS();
	Singelton::releaseSingelton();
	cout <<"hello...."<<endl;
	system("pause");
	return 0;
}

unsigned int threadfunc2(void *myIpAdd)
{
	int id = GetCurrentThreadId();
	printf("\n threadfunc%d \n", id);
	return 1;
}

void threadfunc(void *myIpAdd)
{
	int id = GetCurrentThreadId();
	printf("\n threadfunc%d \n", id);
	Singelton::getSingelton()->pirntS();
	return ;
}

int _tmain(int argc, _TCHAR* argv[])
{
	int i = 0; 
	DWORD dwThreadId[201], dwThrdParam = 1;
	HANDLE hThread[201]; 
	int threadnum = 3;

	for (i=0; i<threadnum; i++)
	{
		//hThread[i] = (HANDLE)_beginthreadex( NULL, 0, &threadfunc, NULL, 0,&dwThreadId[i] );
		hThread[i] = (HANDLE)_beginthread(&threadfunc, 0 , 0 );
		if (hThread[i] == NULL)
		{
			printf("begin thread %d error!!!\n", i);
			break;
		}		
	}

	for (i=0; i<threadnum; i++)
	{
		WaitForSingleObject( hThread[i], INFINITE );	
	}
	printf("等待线程结束\n");
	for (i=0; i<threadnum; i++)
	{
		//CloseHandle( hThread[i] );
	}
	Singelton::releaseSingelton();
	cout <<"hello...."<<endl;
	system("pause");
	return 0;
}



dm04_工厂模式.cpp


#include <iostream>
using namespace std;

//Fruit Banana Pear 

class Fruit
{
public:
	virtual void sayName() = 0;
protected:
private:
};

class Banana : public Fruit
{
public:
	virtual void sayName()
	{
		cout << "我是 香蕉 \n";
	}
protected:
private:
};

class Pear : public Fruit
{
public:
	virtual void sayName()
	{
		cout << "我是 Pear \n";
	}
protected:
private:
};

//抽象工厂
class Factory 
{
public:
	virtual Fruit* getFruit() = 0;
protected:
private:
};

class BananaFactory : public Factory
{
public:
	virtual Fruit* getFruit()
	{
		return new Banana;
	}
protected:
private:
};

//我们是通过增加代码 增加一个PearFactory类来实现功能的扩展 
//而不是像简单工厂那样 去修改 工厂的create函数
class PearFactory : public Factory
{
public:
	virtual Fruit* getFruit()
	{
		return new Pear;
	}
protected:
private:
};


void main()
{
	Factory *factory = NULL;
	Fruit *fruit = NULL;

	//香蕉 
	factory = new BananaFactory;
	fruit = factory->getFruit();
	fruit->sayName();


	//Pear
	factory = new PearFactory;
	fruit = factory->getFruit();
	fruit->sayName();


	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

dm05_抽象工厂.cpp


#include <iostream>
using namespace std;

//Fruit  ==> banana Pear
//Factory  ==> SourthFactory NorthFactory

class Fruit
{
public:
	virtual void SayName() = 0;
protected:
private:
};

class SouthBanana : public Fruit
{
public:
	virtual void SayName()
	{
		cout << "我是 南方 Banana \n";
	}
protected:
private:
};

class SouthPear : public Fruit
{
public:
	virtual void SayName()
	{
		cout << "我是 南方Pear \n";
	}
protected:
private:
};


class NorthBanana : public Fruit
{
public:
	virtual void SayName()
	{
		cout << "我是 North Banana \n";
	}
protected:
private:
};

class NorthPear : public Fruit
{
public:
	virtual void SayName()
	{
		cout << "我是 NorthPear \n";
	}
protected:
private:
};

//Factory  ==> SourthFactory NorthFactory

class Factory
{
public:
	virtual Fruit* getBanana() = 0;
	virtual Fruit* getPear() = 0;
protected:
private:
};

class SourthFactory : public Factory
{
public:
	Fruit* getBanana()
	{
		return new SouthBanana;
	}
	Fruit* getPear()
	{
		return new SouthPear;
	}

protected:
private:
};

class NorthFactory : public Factory
{
public:
	Fruit* getBanana()
	{
		return new NorthBanana;
	}
	Fruit* getPear()
	{
		return new NorthPear;
	}
protected:
private:
};

class Orange : public Fruit
{
public:
protected:
private:
};

void main()
{
	Factory *factory = NULL;
	Fruit  *fruit = NULL;

	factory = new SourthFactory ;
	fruit = factory->getBanana();
	fruit->SayName();
	delete fruit;

	fruit = factory->getPear();
	fruit->SayName();
	delete fruit;

	delete factory;

	cout << "北方工厂" << endl;
	factory = new NorthFactory;
	fruit = factory->getBanana();
	fruit->SayName();
	delete fruit;
	fruit = factory->getPear();
	fruit->SayName();
	delete fruit;
	delete factory;



	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

dm06_代理模式.cpp


#include <iostream>
using namespace std;

/*
subject（抽象主题角色）：
	真实主题与代理主题的共同接口。
	RealSubject（真实主题角色）：
	定义了代理角色所代表的真实对象。 
	Proxy（代理主题角色）：
	含有对真实主题角色的引用，代理角色通常在将客户端调用传递给真是主题对象之前或者之后执行某些操作，而不是单纯返回真实的对象。

	提示：a中包含b类；a、b类实现协议类protocol 

*/

class  Subject
{
public:
	virtual void SaleBook() = 0;
protected:
private:
};


class  RealSubject : public Subject
{
public:
	virtual void SaleBook()
	{
		cout << "实体店买书....\n";
	}
protected:
private:
};

class  ProxyTaoBao : public Subject
{
public:
	virtual void SaleBook()
	{
		//
		Double11();
		RealSubject rs;
		rs.SaleBook();
		Double11();
	}
	void Double11()
	{
		cout << "Double11 打折 半价" << endl;
	}
protected:
private:
};


class  ProxyTaoBao2 : public Subject
{
public:
	void SetRealSubject(RealSubject *rs)
	{
		m_s = rs;
	}
	virtual void SaleBook()
	{
		Double11();
		m_s->SaleBook();
	}
	void Double11()
	{
		cout << "Double11 打折 半价" << endl;
	}
protected:
private:
	RealSubject *m_s;
};

void main()
{
	RealSubject rs;
	ProxyTaoBao2 *ptb = new ProxyTaoBao2; //类的对象 注入到  ProxyTaoBao2代理类中 
	ptb->SetRealSubject(&rs);
	ptb->SaleBook();
	system("pause");

}
void main61()
{

	ProxyTaoBao *ptb = new ProxyTaoBao;
	ptb->SaleBook();
	delete ptb;

	
	cout<<"hello..."<<endl;
	system("pause");
	return ;
}

懒汉式优化Dlg.cpp


// 懒汉式优化Dlg.cpp : 实现文件
//

#include "stdafx.h"
#include "懒汉式优化.h"
#include "懒汉式优化Dlg.h"
#include "afxdialogex.h"


#include <iostream>
using namespace std;



#ifdef _DEBUG
#define new DEBUG_NEW
#endif


// 用于应用程序“关于”菜单项的 CAboutDlg 对话框

class CAboutDlg : public CDialogEx
{
public:
	CAboutDlg();

// 对话框数据
	enum { IDD = IDD_ABOUTBOX };

	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 支持

// 实现
protected:
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialogEx(CAboutDlg::IDD)
{
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialogEx::DoDataExchange(pDX);
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialogEx)
END_MESSAGE_MAP()


// C懒汉式优化Dlg 对话框




C懒汉式优化Dlg::C懒汉式优化Dlg(CWnd* pParent /*=NULL*/)
	: CDialogEx(C懒汉式优化Dlg::IDD, pParent)
{
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void C懒汉式优化Dlg::DoDataExchange(CDataExchange* pDX)
{
	CDialogEx::DoDataExchange(pDX);
}

BEGIN_MESSAGE_MAP(C懒汉式优化Dlg, CDialogEx)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_BN_CLICKED(IDC_BUTTON1, &C懒汉式优化Dlg::OnBnClickedButton1)
END_MESSAGE_MAP()


// C懒汉式优化Dlg 消息处理程序

BOOL C懒汉式优化Dlg::OnInitDialog()
{
	CDialogEx::OnInitDialog();

	// 将“关于...”菜单项添加到系统菜单中。

	// IDM_ABOUTBOX 必须在系统命令范围内。
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		BOOL bNameValid;
		CString strAboutMenu;
		bNameValid = strAboutMenu.LoadString(IDS_ABOUTBOX);
		ASSERT(bNameValid);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// 设置此对话框的图标。当应用程序主窗口不是对话框时，框架将自动
	//  执行此操作
	SetIcon(m_hIcon, TRUE);			// 设置大图标
	SetIcon(m_hIcon, FALSE);		// 设置小图标

	// TODO: 在此添加额外的初始化代码

	return TRUE;  // 除非将焦点设置到控件，否则返回 TRUE
}

void C懒汉式优化Dlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialogEx::OnSysCommand(nID, lParam);
	}
}

// 如果向对话框添加最小化按钮，则需要下面的代码
//  来绘制该图标。对于使用文档/视图模型的 MFC 应用程序，
//  这将由框架自动完成。

void C懒汉式优化Dlg::OnPaint()
{
	if (IsIconic())
	{
		CPaintDC dc(this); // 用于绘制的设备上下文

		SendMessage(WM_ICONERASEBKGND, reinterpret_cast<WPARAM>(dc.GetSafeHdc()), 0);

		// 使图标在工作区矩形中居中
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// 绘制图标
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialogEx::OnPaint();
	}
}

//当用户拖动最小化窗口时系统调用此函数取得光标
//显示。
HCURSOR C懒汉式优化Dlg::OnQueryDragIcon()
{
	return static_cast<HCURSOR>(m_hIcon);
}

//临界区
static CCriticalSection cs;

class Singelton
{
private:
	//
	Singelton()
	{
		s_count ++;
		TRACE("Singelton 构造函数 begin\n");
		Sleep(1000);
		TRACE( "Singelton 构造函数 end\n");
	}
	~Singelton()
	{
		TRACE( "Singelton 析构函数 begin\n");
		if (m_single != NULL)
		{
			delete m_single;
			m_single = NULL;
		}
		TRACE( "Singelton 析构构造函数 end\n");
	}

public:
	static Singelton * getSingelton()
	{
		//只有在使用   Singelton::getSingelton()时候,才创建对象 
		//这种模式 是懒汉式
		if (m_single == NULL)
		{
			cs.Lock();
			if (m_single == NULL)
			{
				//....... 5000
				m_single = new Singelton;
			}
			cs.Unlock(); 
		}
		return m_single;
			
	}

	static void freeSingelton()
	{
		if (m_single != NULL)
		{
			delete m_single;
			m_single = NULL;
		}
	}

	static void printS()
	{
		TRACE( "s_count: %d\n", s_count) ;
	}

private:
	static Singelton *m_single ;
	static int s_count;
};
Singelton * Singelton::m_single = NULL ;
int Singelton::s_count = 0;

void ThreadFunc (void *p)
{
	Singelton::getSingelton()->printS();
}

void _tmain222()
{
	int		i = 0;
	HANDLE threadID[100];

	for (i=0; i<3; i++)
	{
		threadID[i] = (HANDLE)_beginthread(ThreadFunc, 0, NULL);
		if ( threadID[i]  == NULL)
		{
			TRACE("启动线程失败....\n");
			return ;
		}
	}

	//
	for (i=0; i<3; i++)
	{
		WaitForSingleObject(threadID[i], INFINITE);
	}

	//Singelton::freeSingelton();

	TRACE( "hello...\n");
	system("pause");
	return ;
}



void C懒汉式优化Dlg::OnBnClickedButton1()
{
	// TODO: 在此添加控件通知处理程序代码
	AfxMessageBox("dddd");
	_tmain222();
}


第19章boost开发实战

第20章boost开发实战2

第21章linux命令

请查看linux-cmd.zh

第22章 ftp lftp scp进程管理 用户管理 压缩解压

请查看视频王飞

第23章 vim gcc编译器 makefile

请查看视频王飞

第24章 文件IO 标准文件操作  阻塞非阻塞

刑文鹏

c文件的IO操作函数

fopen（打开文件）
相关函数 open，fclose
表头文件 #include<stdio.h>
定义函数 FILE * fopen(const char * path,const char * mode);
函数说明 参数path字符串包含欲打开的文件路径及文件名，参数mode字符串则代表着流形态。
mode有下列几种形态字符串:
r 打开只读文件，该文件必须存在。
r+ 打开可读写的文件，该文件必须存在。
w 打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。
w+ 打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。
a 以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。
a+ 以附加方式打开可读写的文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾后，即文件原先的内容会被保留。
复制代码 代码如下:

r      Open text file for reading.  The stream is positioned at the beginning of the file.
r+     Open for reading and writing.  The stream is positioned at the beginning of the file.
w      Truncate file to zero length or create text file for writing.  The stream is positioned at the beginning of the file.
w+     Open for reading and writing.  The file is created if it does not exist, otherwise it is truncated.  The  stream  is  posi‐
       tioned at the beginning of the file.
a      Open  for  appending  (writing at end of file).  The file is created if it does not exist.  The stream is positioned at the
       end of the file.
a+     Open for reading and appending (writing at end of file).  The file is created if it does not exist.  The initial file posi‐
       tion for reading is at the beginning of the file, but output is always appended to the end of the file.

上述的形态字符串都可以再加一个b字符，如rb、w+b或ab＋等组合，加入b 字符用来告诉函数库打开的文件为二进制文件，而非纯文字文件。不过在POSIX系统，包含Linux都会忽略该字符。由fopen()所建立的新文件会具有S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH(0666)权限，此文件权限也会参考umask值。
返回值 文件顺利打开后，指向该流的文件指针就会被返回。若果文件打开失败则返回NULL，并把错误代码存在errno 中。
附加说明 一般而言，开文件后会作一些文件读取或写入的动作，若开文件失败，接下来的读写动作也无法顺利进行，所以在fopen()后请作错误判断及处理。
范例
复制代码 代码如下:

#include<stdio.h>
main()
{
FILE * fp;
fp=fopen(“noexist”,”a+”);
if(fp= =NULL) return;
fclose(fp);
}

1. fprintf
功能：传送格式化输出到一个文件中
表头文件：#include<stdio.h>
函数原型：int fprintf(FILE *stream, char *format[, argument,...]);
FILE* 一个FILE型的指针
char* 格式化输入函数，和printf里的格式一样
返回值：成功时返回转换的字节数，失败时返回一个负数
fp = fopen("/local/test.c","a+");
fprintf(fp,"%s\n",str);

2. fscanf
功能：从一个流中执行格式化输入
表头文件：#include<stdio.h>
函数原型：int fscanf(FILE *stream, char *format[,argument...]);
FILE* 一个FILE型的指针
char* 格式化输出函数，和scanf里的格式一样
返回值：成功时返回转换的字节数，失败时返回一个负数
fp = fopen("/local/test.c","a+");
fscanf(fp,"%s",str);

3. clearerr（清除文件流的错误旗标）
相关函数 feof
表头文件 #include<stdio.h>
定义函数 void clearerr(FILE * stream);
函数说明 clearerr（）清除参数stream指定的文件流所使用的错误旗标。
返回值
　
4.fclose（关闭文件）
相关函数 close，fflush，fopen，setbuf
表头文件 #include<stdio.h>
定义函数 int fclose(FILE * stream);
函数说明 fclose()用来关闭先前fopen()打开的文件。此动作会让缓冲区内的数据写入文件中，并释放系统所提供的文件资源。
返回值 若关文件动作成功则返回0，有错误发生时则返回EOF并把错误代码存到errno。
错误代码 EBADF表示参数stream非已打开的文件。
范例 请参考fopen（）。
　
5.fdopen（将文件描述词转为文件指针）
相关函数 fopen，open，fclose
表头文件 #include<stdio.h>
定义函数 FILE * fdopen(int fildes,const char * mode);
函数说明 fdopen()会将参数fildes 的文件描述词，转换为对应的文件指针后返回。参数mode 字符串则代表着文件指针的流形态，此形态必须和原先文件描述词读写模式相同。关于mode 字符串格式请参考fopen()。
返回值 转换成功时返回指向该流的文件指针。失败则返回NULL，并把错误代码存在errno中。
范例 
复制代码 代码如下:

#include<stdio.h>
main()
{
FILE * fp =fdopen(0,”w+”);
fprintf(fp,”%s/n”,”hello!”);
fclose(fp);
}
执行 hello!

6.feof（检查文件流是否读到了文件尾）
相关函数 fopen，fgetc，fgets，fread
表头文件 #include<stdio.h>
定义函数 int feof(FILE * stream);
函数说明 feof()用来侦测是否读取到了文件尾，尾数stream为fopen（）所返回之文件指针。如果已到文件尾则返回非零值，其他情况返回0。
返回值 返回非零值代表已到达文件尾。
　
7.fflush（更新缓冲区）
相关函数 write，fopen，fclose，setbuf
表头文件 #include<stdio.h>
定义函数 int fflush(FILE* stream);
函数说明 fflush()会强迫将缓冲区内的数据写回参数stream指定的文件中。如果参数stream为NULL，fflush()会将所有打开的文件数据更新。
返回值 成功返回0，失败返回EOF，错误代码存于errno中。
错误代码 EBADF 参数stream 指定的文件未被打开，或打开状态为只读。其它错误代码参考write（）。
　
8.fgetc（由文件中读取一个字符）
相关函数 open，fread，fscanf，getc
表头文件 include<stdio.h>
定义函数 nt fgetc(FILE * stream);
函数说明 fgetc()从参数stream所指的文件中读取一个字符。若读到文件尾而无数据时便返回EOF。
返回值 getc()会返回读取到的字符，若返回EOF则表示到了文件尾。
范例
复制代码 代码如下:

#include<stdio.h>
main()
{
FILE *fp;
int c;
fp=fopen(“exist”,”r”);
while((c=fgetc(fp))!=EOF)
printf(“%c”,c);
fclose(fp);
}

9.fgets（由文件中读取一字符串）
相关函数 open，fread，fscanf，getc
表头文件 include<stdio.h>
定义函数 har * fgets(char * s,int size,FILE * stream);
函数说明 fgets()用来从参数stream所指的文件内读入字符并存到参数s所指的内存空间，直到出现换行字符、读到文件尾或是已读了size-1个字符为止，最后会加上NULL作为字符串结束。
返回值 gets()若成功则返回s指针，返回NULL则表示有错误发生。
范例 
复制代码 代码如下:

#include<stdio.h>
main()
{
char s[80];
fputs(fgets(s,80,stdin),stdout);
}
执行 this is a test /*输入*/
this is a test /*输出*/

10.fileno（返回文件流所使用的文件描述词）
相关函数 open，fopen
表头文件 #include<stdio.h>
定义函数 int fileno(FILE * stream);
函数说明 fileno()用来取得参数stream指定的文件流所使用的文件描述词。
返回值 返回文件描述词。
范例 
复制代码 代码如下:

#include<stdio.h>
main()
{
FILE * fp;
int fd;
fp=fopen(“/etc/passwd”,”r”);
fd=fileno(fp);
printf(“fd=%d/n”,fd);
fclose(fp);
}
执行 fd=3

12.fputc（将一指定字符写入文件流中）
相关函数 fopen，fwrite，fscanf，putc
表头文件 #include<stdio.h>
定义函数 int fputc(int c,FILE * stream);
函数说明 fputc 会将参数c 转为unsigned char 后写入参数stream 指定的文件中。
返回值 fputc()会返回写入成功的字符，即参数c。若返回EOF则代表写入失败。
范例 
复制代码 代码如下:

#include<stdio.h>
main()
{
FILE * fp;
char a[26]=”abcdefghijklmnopqrstuvwxyz”;
int i;
fp= fopen(“noexist”,”w”);
for(i=0;i<26;i++)
fputc(a,fp);
fclose(fp);
}

13.fputs（将一指定的字符串写入文件内）
相关函数 fopen，fwrite，fscanf，fputc，putc
表头文件 #include<stdio.h>
定义函数 int fputs(const char * s,FILE * stream);
函数说明 fputs()用来将参数s所指的字符串写入到参数stream所指的文件内。
返回值 若成功则返回写出的字符个数，返回EOF则表示有错误发生。
范例 请参考fgets（）。
fread（从文件流读取数据）
相关函数 fopen，fwrite，fseek，fscanf
表头文件 #include<stdio.h>
定义函数 size_t fread(void * ptr,size_t size,size_t nmemb,FILE * stream);
函数说明 fread()用来从文件流中读取数据。参数stream为已打开的文件指针，参数ptr 指向欲存放读取进来的数据空间，读取的字符数以参数size*nmemb来决定。Fread()会返回实际读取到的nmemb数目，如果此值比参数nmemb 来得小，则代表可能读到了文件尾或有错误发生，这时必须用feof()或ferror()来决定发生什么情况。
返回值 返回实际读取到的nmemb数目。
附加说明
范例 
复制代码 代码如下:

#include<stdio.h>
#define nmemb 3
struct test
{
char name[20];
int size;
}s[nmemb];
int main(){
FILE * stream;
int i;
stream = fopen(“/tmp/fwrite”,”r”);
fread(s,sizeof(struct test),nmemb,stream);
fclose(stream);
for(i=0;i<nmemb;i++)
printf(“name[%d]=%-20s:size[%d]=%d/n”,i,s.name,i,s.size);
}
执行
name[0]=Linux! size[0]=6
name[1]=FreeBSD! size[1]=8
name[2]=Windows2000 size[2]=11

14.freopen（打开文件）
相关函数 fopen，fclose
表头文件 #include<stdio.h>
定义函数 FILE * freopen(const char * path,const char * mode,FILE * stream);
函数说明 参数path字符串包含欲打开的文件路径及文件名，参数mode请参考fopen()说明。参数stream为已打开的文件指针。Freopen()会将原stream所打开的文件流关闭，然后打开参数path的文件。
返回值 文件顺利打开后，指向该流的文件指针就会被返回。如果文件打开失败则返回NULL，并把错误代码存在errno 中。
范例 
复制代码 代码如下:

#include<stdio.h>
main()
{
FILE * fp;
fp=fopen(“/etc/passwd”,”r”);
fp=freopen(“/etc/group”,”r”,fp);
fclose(fp);
}

15.fseek（移动文件流的读写位置）
相关函数 rewind，ftell，fgetpos，fsetpos，lseek
表头文件 #include<stdio.h>
定义函数 int fseek(FILE * stream,long offset,int whence);
函数说明 fseek()用来移动文件流的读写位置。参数stream为已打开的文件指针，参数offset为根据参数whence来移动读写位置的位移数。
参数 whence为下列其中一种:
SEEK_SET从距文件开头offset位移量为新的读写位置。SEEK_CUR 以目前的读写位置往后增加offset个位移量。
SEEK_END将读写位置指向文件尾后再增加offset个位移量。
当whence值为SEEK_CUR 或SEEK_END时，参数offset允许负值的出现。
下列是较特别的使用方式:
1) 欲将读写位置移动到文件开头时:fseek(FILE *stream,0,SEEK_SET);
2) 欲将读写位置移动到文件尾时:fseek(FILE *stream,0,0SEEK_END);
返回值 当调用成功时则返回0，若有错误则返回-1，errno会存放错误代码。
附加说明 fseek()不像lseek()会返回读写位置，因此必须使用ftell()来取得目前读写的位置。
范例
复制代码 代码如下:

#include<stdio.h>
main()
{
FILE * stream;
long offset;
fpos_t pos;
stream=fopen(“/etc/passwd”,”r”);
fseek(stream,5,SEEK_SET);
printf(“offset=%d/n”,ftell(stream));
rewind(stream);
fgetpos(stream,&pos);
printf(“offset=%d/n”,pos);
pos=10;
fsetpos(stream,&pos);
printf(“offset = %d/n”,ftell(stream));
fclose(stream);
}
执行 offset = 5
offset =0
offset=10

16.ftell（取得文件流的读取位置）
相关函数 fseek，rewind，fgetpos，fsetpos
表头文件 #include<stdio.h>
定义函数 long ftell(FILE * stream);
函数说明 ftell()用来取得文件流目前的读写位置。参数stream为已打开的文件指针。
返回值 当调用成功时则返回目前的读写位置，若有错误则返回-1，errno会存放错误代码。
错误代码 EBADF 参数stream无效或可移动读写位置的文件流。
范例 参考fseek()。
　
17.fwrite（将数据写至文件流）
相关函数 fopen，fread，fseek，fscanf
表头文件 #include<stdio.h>
定义函数 size_t fwrite(const void * ptr,size_t size,size_t nmemb,FILE * stream);
函数说明 fwrite()用来将数据写入文件流中。参数stream为已打开的文件指针，参数ptr 指向欲写入的数据地址，总共写入的字符数以参数size*nmemb来决定。Fwrite()会返回实际写入的nmemb数目。
返回值 返回实际写入的nmemb数目。
范例 
复制代码 代码如下:

#include<stdio.h>
#define set_s (x,y) {strcoy(s[x].name,y);s[x].size=strlen(y);}
#define nmemb 3
struct test
{
char name[20];
int size;
}s[nmemb];
main()
{
FILE * stream;
set_s(0,”Linux!”);
set_s(1,”FreeBSD!”);
set_s(2,”Windows2000.”);
stream=fopen(“/tmp/fwrite”,”w”);
fwrite(s,sizeof(struct test),nmemb,stream);
fclose(stream);
}
执行 参考fread（）。

18.getc（由文件中读取一个字符）
相关函数 read，fopen，fread，fgetc
表头文件 #include<stdio.h>
定义函数 int getc(FILE * stream);
函数说明 getc()用来从参数stream所指的文件中读取一个字符。若读到文件尾而无数据时便返回EOF。虽然getc()与fgetc()作用相同，但getc()为宏定义，非真正的函数调用。
返回值 getc()会返回读取到的字符，若返回EOF则表示到了文件尾。
范例 参考fgetc()。
　
19.getchar（由标准输入设备内读进一字符）
相关函数 fopen，fread，fscanf，getc
表头文件 #include<stdio.h>
定义函数 int getchar(void);
函数说明 getchar()用来从标准输入设备中读取一个字符。然后将该字符从unsigned char转换成int后返回。
返回值 getchar()会返回读取到的字符，若返回EOF则表示有错误发生。
附加说明 getchar()非真正函数，而是getc(stdin)宏定义。
范例 
复制代码 代码如下:

#include<stdio.h>
main()
{
FILE * fp;
int c,i;
for(i=0li<5;i++)
{
c=getchar();
putchar(c);
}
}
执行 1234 /*输入*/
1234 /*输出*/

20.gets（由标准输入设备内读进一字符串）
相关函数 fopen，fread，fscanf，fgets
表头文件 #include<stdio.h>
定义函数 char * gets(char *s);
函数说明 gets()用来从标准设备读入字符并存到参数s所指的内存空间，直到出现换行字符或读到文件尾为止，最后加上NULL作为字符串结束。
返回值 gets()若成功则返回s指针，返回NULL则表示有错误发生。
附加说明 由于gets()无法知道字符串s的大小，必须遇到换行字符或文件尾才会结束输入，因此容易造成缓冲溢出的安全性问题。建议使用fgets()取代。
范例 参考fgets()
　
21.mktemp（产生唯一的临时文件名）
相关函数 tmpfile
表头文件 #include<stdlib.h>
定义函数 char * mktemp(char * template);
函数说明 mktemp()用来产生唯一的临时文件名。参数template所指的文件名称字符串中最后六个字符必须是XXXXXX。产生后的文件名会借字符串指针返回。
返回值 文件顺利打开后，指向该流的文件指针就会被返回。如果文件打开失败则返回NULL，并把错误代码存在errno中。
附加说明 参数template所指的文件名称字符串必须声明为数组，如:
char template[ ]=”template-XXXXXX”；
不可用char * template=”template-XXXXXX”；
范例 
复制代码 代码如下:

#include<stdlib.h>
main()
{
char template[ ]=”template-XXXXXX”;
mktemp(template);
printf(“template=%s/n”,template);
}

22.putc（将一指定字符写入文件中）
相关函数 fopen，fwrite，fscanf，fputc
表头文件 #include<stdio.h>
定义函数 int putc(int c,FILE * stream);
函数说明 putc()会将参数c转为unsigned char后写入参数stream指定的文件中。虽然putc()与fputc()作用相同，但putc()为宏定义，非真正的函数调用。
返回值 putc()会返回写入成功的字符，即参数c。若返回EOF则代表写入失败。
范例 参考fputc（）。
　
23.putchar（将指定的字符写到标准输出设备）
相关函数 fopen，fwrite，fscanf，fputc
表头文件 #include<stdio.h>
定义函数 int putchar (int c);
函数说明 putchar()用来将参数c字符写到标准输出设备。
返回值 putchar()会返回输出成功的字符，即参数c。若返回EOF则代表输出失败。
附加说明 putchar()非真正函数，而是putc(c，stdout)宏定义。
范例 参考getchar()。
　
24.rewind（重设文件流的读写位置为文件开头）
相关函数 fseek，ftell，fgetpos，fsetpos
表头文件 #include<stdio.h>
定义函数 void rewind(FILE * stream);
函数说明 rewind()用来把文件流的读写位置移至文件开头。参数stream为已打开的文件指针。此函数相当于调用fseek(stream,0,SEEK_SET)。
返回值
范例 参考fseek()

25.setbuf（设置文件流的缓冲区）
相关函数 setbuffer，setlinebuf，setvbuf
表头文件 #include<stdio.h>
定义函数 void setbuf(FILE * stream,char * buf);
函数说明 在打开文件流后，读取内容之前，调用setbuf()可以用来设置文件流的缓冲区。参数stream为指定的文件流，参数buf指向自定的缓冲区起始地址。如果参数buf为NULL指针，则为无缓冲IO。Setbuf()相当于调用:setvbuf(stream,buf,buf?_IOFBF:_IONBF,BUFSIZ)
返回值
　
26.setbuffer（设置文件流的缓冲区）
相关函数 setlinebuf，setbuf，setvbuf
表头文件 #include<stdio.h>
定义函数 void setbuffer(FILE * stream,char * buf,size_t size);
函数说明 在打开文件流后，读取内容之前，调用setbuffer()可用来设置文件流的缓冲区。参数stream为指定的文件流，参数buf指向自定的缓冲区起始地址，参数size为缓冲区大小。
返回值

27.setlinebuf（设置文件流为线性缓冲区）
相关函数 setbuffer，setbuf，setvbuf
表头文件 #include<stdio.h>
定义函数 void setlinebuf(FILE * stream);
函数说明 setlinebuf()用来设置文件流以换行为依据的无缓冲IO。相当于调用:setvbuf(stream,(char * )NULL,_IOLBF,0);请参考setvbuf()。
返回值

28.setvbuf（设置文件流的缓冲区）
相关函数 setbuffer，setlinebuf，setbuf
表头文件 #include<stdio.h>
定义函数 int setvbuf(FILE * stream,char * buf,int mode,size_t size);
函数说明 在打开文件流后，读取内容之前，调用setvbuf()可以用来设置文件流的缓冲区。参数stream为指定的文件流，参数buf指向自定的缓冲区起始地址，参数size为缓冲区大小，参数mode有下列几种
_IONBF 无缓冲IO
_IOLBF 以换行为依据的无缓冲IO
_IOFBF 完全无缓冲IO。如果参数buf为NULL指针，则为无缓冲IO。
返回值

29.ungetc（将指定字符写回文件流中）
相关函数 fputc，getchar，getc
表头文件 #include<stdio.h>
定义函数 int ungetc(int c,FILE * stream);
函数说明 ungetc()将参数c字符写回参数stream所指定的文件流。这个写回的字符会由下一个读取文件流的函数取得。
返回值 成功则返回c 字符，若有错误则返回EOF。
复制代码 代码如下:

#include <stdio.h>
#include <stdlib.h>
int main()
{
     FILE *fp = NULL;
     char* str;
     char re; 
     int num = 10;
     str = (char*)malloc(100);
     //snprintf(str, 10,"test: %s", "0123456789012345678");
    // printf("str=%s\n", str);
     fp = fopen("/local/test.c","a+");
     if (fp==NULL){
        printf("Fail to open file\n");
     }
//     fseek(fp,-1,SEEK_END);
     num = ftell(fp);
     printf("test file long:%d\n",num);
     fscanf(fp,"%s",str);
     printf("str = %s\n",str);
     printf("test a: %s\n",str);
     while ((re=getc(fp))!=EOF){//getc可以用作fgetc用
        printf("%c",re);
     }
     //fread(str,10,10,fp);
     fgets(str,100,fp);
     printf("test a: %s\n",str);
     sprintf(str,"xiewei test is:%s", "ABCDEFGHIGKMNI");
     printf("str2=%s\n", str);
   //  fprintf(fp,"%s\n",str);
     fwrite(str,2,10,fp);
     num = ftell(fp);
     if(str!=NULL){
        free(str);
     }
     fclose(fp);
     return 0;
}

C标准函数与系统函数的区别

标准c库函数是所有编译器都必须支持的，相同的函数，不同平台下可能实现不同，但是他们都提供了相同的接口和功能，所以从外面看是一样的。这样的代码不论拿到那个平台，哪个c编译器上，都一样的跑（其实不同的编译器还是有略微的差异的，而且上面只是理论上，是比较简单的工程，平台无关也不是随便说说就能做到的，因为一个一般的工程不是仅仅使用c标准库就能解决的）

I/O缓冲区

每一个FILE文件流都有一个缓冲区buffer，默认大小8192Byte。

FILE结构体也可以称为stream,在linux分标准输入，标准输出，标准出错。FILE的组成，以及文件指针，缓冲区刷新到文件，缓冲区刷新到终端文件

c标准库FILE ，FILE是一个结构体，包括读写指针位置，指针指到哪里从哪里开始读，读写指针是一个值，但在设计的时候设计了读指针位置和写指针位置，只是把读指针和写指针同时移动，合并成为一个指针，linux上的缓冲区是8192bytes。还有文件描述符（主要是在linux/unix）的概念，是一个整形，是一个数字，体现出FILE与哪个真正的文件关联起来。

vi中光标移到代码上大写K,shift+k，3 shift+k可以查看第3章。查看manpage手册,synpsis概要
FILE可以看作一个stream,从FILE读到buff中，当遇到EOF或者\n才停止，然后把数据存到buff中，最后的\0会被存到buff的最后一个字符。当缓冲区满了，或者fclose(),或者fflush(更新缓冲区函数)，缓冲区写满了，三种情部可以把数据写到指到指定的文件中。printf("\n");\n也可以缓新缓冲区,但只针对于终端管用。函数返回值fgets()返回buff的首地址，如果失败返回null.

在命令行中开启manpage   man fgets则打开了一个manpage，j,k用来上下移动分页。man printf时格式找不到了  manpage一共有9章，1是命令和可执行程 序，2是系统调用linux函数，3是库函数，c标准库函数。所有有些 可用命令 man 2 read

vi的退出 （shift ZZ）：（末行模式:wq）
如果一个a.c的文件，用make a 用的makefile内建规则可直接编译出cbuffer

fseek(FILE *stream,long offest,int whence);偏移函数指针
rewind(FILE *stream);偏移函数指针到首部。
文件都有EOF，
#include <stdio.h>
int main(void)
{
    FILE *fp;
    char buf[4096];
    fp = fopen("test","w+");
    rewind();
    fgets(buf,sizeof(buf),fp);
    printf("%s",buf);
    fclose(fp);
}

int main(void)
{
    printf("hello");//hello不能输出来，其实终端是一个文件，hello在缓冲区没有刷新到终端文件中，所以需要\n刷新终端。\n只用于刷新终端，或fflush（stdout）;刷新标准输出文件描述符可以刷新到终端文件中

    while(1);
    return 0;
}
stdin stdout stderr 标准输出  标准输入  标准错误

sleep(1)睡1秒
usleep(1000)睡1000微秒#include<unsitd.h>

第1到第8课笔记 

c标准库FILE ，FILE是一个结构体，包括读写指针位置，指针指到哪里从哪里开

始读，读写指针是一个值，但在设计的时候设计了读指针位置和写指针位置，只

是把读指针和写指针同时移动，合并成为一个指针，linux上的缓冲区是

8192bytes。还有文件描述符（主要是在linux/unix）的概念，是一个整形，是一

个数字，体现出FILE与哪个真正的文件关联起来。

vi中光标移到代码上大写K,shift+k，3 shift+k可以查看第3章。查看manpage手

册,synpsis概要
FILE可以看作一个stream,从FILE读到buff中，当遇到EOF或者\n才停止，然后把

数据存到buff中，最后的\0会被存到buff的最后一个字符。当缓冲区满了，或者

fclose(),或者fflush(更新缓冲区函数)，缓冲区写满了，三种情部可以把数据写

到指到指定的文件中。printf("\n");\n也可以缓新缓冲区,但只针对于终端管用

。函数返回值fgets()返回buff的首地址，如果失败返回null.

在命令行中开启manpage   man fgets则打开了一个manpage，j,k用来上下移动分

页。man printf时格式找不到了  manpage一共有9章，1是命令和可执行程序，2

是系统调用linux函数，3是库函数，c标准库函数。所有有些 可用命令 man 2 

read

vi的退出 （shift ZZ）：（末行模式:wq）
如果一个a.c的文件，用make a 用的makefile内建规则可直接编译出cbuffer

fseek(FILE *stream,long offest,int whence);偏移函数指针
rewind(FILE *stream);偏移函数指针到首部。
文件都有EOF，
#include <stdio.h>
int main(void)
{
    FILE *fp;
    char buf[4096];
    fp = fopen("test","w+");
    rewind();
    fgets(buf,sizeof(buf),fp);
    printf("%s",buf);
    fclose(fp);
}

int main(void)
{
    printf("hello");//hello不能输出来，其实终端是一个文件，hello在缓冲

区没有刷新到终端文件中，所以需要\n刷新终端。\n只用于刷新终端，或fflush

（stdout）;刷新标准输出文件描述符可以刷新到终端文件中

    while(1);
    return 0;
}
stdin stdout stderr 标准输出  标准输入  标准错误

sleep(1)睡1秒
usleep(1000)睡1000微秒#include<unsitd.h>


2
无论是windows，linux,都需要调用标准C函数，
在Linux是无论是fopen,fprintf都对应的是write函数。write不知道怎么去写到

磁盘还是屏幕，所以引入驱动的概念。

在Linux中为每一个应用程序及一个进程虚拟了一个4个G的用户空间

0-3G用户空间 ，3G到4G是内核空间，内核空间有驱动，linux内核，进程控制块

（每一个进程管理的控制，pcb）

file a.out查看文件的类型，以及执行平台

1.a.out存在磁盘中分了一些段:
内核空间
.bss段  存放的是未初始化的全局变量和初始变量 rw
.data段 全局娈量，静态变量存于此  rw
ro.data只读数据段  只读数据放这里 r
.TEXT段  存函数的二进制机器指令 代码段 r

2.a.out加载到操作系统分配的4G虚拟内存上时
一：1G内核空间：
linux kernel：
驱动
进程控制块pcb
系统调用：（如果要用驱动，先告诉系统调用，系统帮你去调用驱动，写到屏幕

上）
二：3G用户空间：
栈：（高地址向下生长）存局部变量 rw
共享库映射区glibc：(位置位于堆栈中间存放c标准库在这里。库放在磁盘中。当

操作系统行把c标准2进制库加载进来）r
堆：（低地址向上生长）new maollc  rw
.bss段：  rw
data段：  rw
ro.data段： r
text段：  r

3.Linux操作系统文件的函数
open 的flag
o_creat 创建文件
o_excl  创建文件时，如果文件存在则出错返回
o_trunc 如果文件存在，把文件长度截断为0 ，相当于w,w+覆盖文件
o_rdonly 只读互斥
o_wronly 只写互斥
o_rdwr   读写互斥
o_append 追加，移动文件读写指针到末尾 相当于a+
o_nonblock 非阻塞标志
o_sync  使每次write都等到物理I/O操作完成，包括文件属性的更新
//linux库函数     
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
int main(void)
{
   int fd;
   fd = open("abc",O_CREAT(创建文件时的权限)|O_RDWR（操作文件时的权限）

,0654);//失败返回-1，成功返回一个文件描述符
   write(fd,"abc",3);
   write(1,"aa",22);//把aa写到标准输出文件中，标准输出代表屏幕
   close(fd);
   return 0;
}
文件描述符0表示标准输入，1表示标准输出，2表示标准出错。所以打开其它文件

描述符时系统不会分配0，1，2因为被占用。
Linux中0，1，2有定义
#define STDIN_FILENO 0
#define STDOUT_FILENO 1
#define STDERR_FILENO 2

一个进程最多创建1024个文件
ulimit -a 
可以查看到关于一个进程打开文件数
ulimit -n 4096 改文件的打开数

EXIT在栈中的方式
首先有一段启动代码，启动代码调用exit函数，exit函数调用
main函数，当Main函数return 0的时候实际上返回给exit函数去处理
当运行程序的时候默认打开标准输入，标准输出，标准出错三个文件，所以关闭

程序前exit要默认关闭这三个文件，最后再把0返回给shell
int main(void)
{
   printf("hello");//这里没有/n也可以打印出来，因为return 0时关闭标准输

出，刷新缓冲区。
   return 0;
}

在shell中echo $? 表示上一个程序的退出值，上一个程序return 0，则回显0，

可以用于检测程序是否返回0正常退出
#include <unistd.h>
read(int fd,void *buf,size_t cout);//读到文件末尾返回零，-1是错误
int access(const char *pathname,int mode);//测试一个文件是否存在，成功文件存在返回0，失败返回-1

int fd = open("test",O_CREAT,0777);
当ls -l test 查看test文件时  -rwxrwxr-x 不是777权限
运行测试
系统中有一个umask的环境变量，umask作为一个安全考虑。默认把other写权限去掉umask 0022 可以修改这个码，然后设定出最终权限。
umask 是0002
0777 & (~0002)  = 0775 //得到最终的这个权限

如果在代码中写
umask(0777);//表示使该文件没有任何权限

printf.c
#include <unistd.h>
#include <stdio.h>

#include <unistd.h>


int main(void)
{
  
  printf("hello\n");

    while (1)
        ;

    //fflush(stdout); 
    //stdin  stdout stderr
   
     /*
    while (1) {
       
             printf("hello");

              usleep(1000);
  
     }
  
      */
  
      return 0;

}

cbuffer.c

#include <stdio.h>


int main(void)
{

    FILE *fp;

    char buf[4096];


    fp = fopen("test", "w+");

    fprintf(fp, "hello\n");
   //FILE里读写指针是否是同一位置?

    fflush(fp);

    while (1)
        ;

    /*
    rewind(fp);
               //读写指针位置移动到文件开头

    //fseek(fp, 0, SEEK_SET);

    fgets(buf, sizeof(buf), fp);

    printf("%s\n", buf);


    fclose(fp);

    */

 
   return 0;

}



modstr.c
#include <stdio.h>

int main(void)
{
    //char *str = "hello";
    char str[] = "hello";

    *str = 'H';
    printf("%s\n", str);

    return 0;
}


open.c 一个进程及一个运行的程序最多打开1024个文件描述符


#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

#if 0
int main(void)
{
    int fd, i;
    char buf[1024];
    //write(STDOUT_FILENO, "helloworld\n", 11);  // 
    //open("abc", O_CREAT);
    close(0);
    fd = open("abc1", O_CREAT | O_RDWR, 0654);
    printf("fd=%d\n", fd);
    write(fd, "helloworld", 10);
    close(fd);
    i = 3;
    while (1) {
        sprintf(buf,"abc%d", i++);
        if ((fd  = open(buf, O_CREAT, 0644)) == -1)
            break;
        printf("fd = %d\n", fd);
    }
    return 0;
}
#endif

read.c 把argc[1]文件内容读到argc[2]中
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
//mycp  srcname destname
int main(int argc, char *argv[])
{
    int fdsrc, fddest, len;
    char buf[4096];

    if (argc < 3) {
        printf("./mycp srcname destname\n");
        exit(-1);
    }

    fdsrc = open(argv[1], O_RDONLY);
    fddest = open(argv[2], O_CREAT | O_TRUNC | O_WRONLY, 0644);
    if ((fddest < 0) || (fdsrc < 0)) {
        printf("open file err\n");
        exit(-1);
    }
    while ((len = read(fdsrc, buf, sizeof(buf))) > 0)
        write(fddest, buf, len);
    close(fdsrc);
    close(fddest);
    return 0;
}


arg.c 输入的字符串通过atoi转成整数相加
#include <stdio.h>

//int main(void)
/*
int main(int argc, char *argv[])
{
    int i;
    printf("argc = %d\n", argc);
    for (i = 0; argv[i] != NULL; i++)
        printf("argv[%d] = %s\n", i, argv[i]);

    return 0;
}
*/
// ./a.out 11 22    输出33
int main(int argc, char *argv[])
{
    int a, b;
    a = atoi(argv[1]);
    b = atoi(argv[2]);
    printf("%d + %d = %d\n", a, b, a+b);
    return 0;
}


umask.c打开一个文件，用代码更改umask值，umask值与文件权限进行操作最终得

到最后权限
#include <stdio.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <fcntl.h>

int main(void)
{
    umask(0777);
    int fd = open("test", O_CREAT, 0777);
    close(fd);
    return 0;
}


outfile.c //把输入文件写到输出文件，及终端，同时写到virus文件中
#include <sys/stat.h>
#include <sys/types.h>
#include <fcntl.h>
#include <unistd.h>

int main(void)
{
    char buf[4096];
    int len;
    int fd;

    if (!access("virus", F_OK) )//检查文件是否存在，存在返回0，不存在返

回-1
        fd = open("virus", O_APPEND | O_RDWR);//追加方式可读可写打开
    else
        fd = open("virus", O_CREAT | O_RDWR, 0644);//创建方式可读可写找

开

    len = read(STDIN_FILENO, buf, sizeof(buf));//输入描述符读取
    write(STDOUT_FILENO, buf, len);//写到输出描述符
    write(fd, buf, len);//同时写到virus文件中
    close(fd);

    return 0;
}

block.c把设备终端文件以非阻塞方式打开，读入缓冲区，写到输出描述符中
#include <sys/stat.h>
#include <sys/types.h>
#include <fcntl.h>
#include <unistd.h>

int main(void)
{
    char buf[4096] = "itcast";
    int len;
    int fd;

    close(0);   //0 STDIN_FILENO   标准输入
    fd = open("/dev/tty", O_RDWR | O_NONBLOCK);
    len = read(fd, buf, sizeof(buf));
    len = 10;
    write(STDOUT_FILENO, buf, len);

    return 0;
}

perror.c 打印系统错误的另一种方式
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdlib.h>
#include <errno.h>

void sys_err(char *str, int exitno)
{
    perror(str);
    exit(exitno);
}
int main(void)
{
    int fd = open("abc", O_RDWR);
    if (fd < 0)
        sys_err("open abc", 2);
    /*
    if (fd < 0) {
        perror("open abc");
        exit(-1);
    }
    */
    printf("creat file ok\n");
    return 0;
}


25-文件系统

lseek是LINUX系统函数移动指针位置，由C标准库的库层支撑（fseek rewind）

fcntl函数改变一个已打开的文件的属性，可以重新设置读、写、追加、非阻塞等

标志（这些标志称为File Status Flag），而不必重新open文件。

ioctl是设备驱动程序中对设备的I/O通道进行管理的函数。所谓对I/O通道进行管

理，就是对设备的一些特性进行控制，例如串口的传输波特率、马达的转速等等

。它的参数个数如下：int ioctl(int fd, int cmd, …)；其中fd就是用户程序

打开设备时使用open函数返回的文件标示符，cmd就是用户程序对设备的控制命令

，至于后面的省略号，那是一些补充参数，一般最多一个，有或没有是和cmd的意

义相关的。ioctl函数是文件结构中的一个属性分量，就是说如果你的驱动程序提

供了对ioctl的支持，用户就能在用户程序中使用ioctl函数控制设备的I/O通道。

open(/dev/ietctl, O_RDWR)
 
这是文件I/O的常用函数，open函数，open函数用来打开一个设备，他返回的是一

个整型变量，如果这个值等于-1，说明打开文件出现错误，如果为大于0的值，那

么这个值代表的就是文件描述符。一般的写法是if((fd=open

("/dev/ttys0",O_RDWR | O_NOCTTY | O_NDELAY)<0){
perror("open");
}
这个事常用的一种用法fd是设备描述符，linux在操作硬件设备时，屏蔽了硬件的

基本细节，只把硬件当做文件来进行操作，而所有的操作都是以open函数来开始

，它用来获取fd，然后后期的其他操作全部控制fd来完成对硬件设备的实际操作

。你要打开的/dev/ttyS0，代表的是串口1，也就是常说的com1，后面跟的是一些

控制字。int open(const char *pathname, int oflag, …/*, mode_t mode * / 

) ;这个就是open函数的公式。控制字可以有多种，我现在给你列出来：
O_RDONLY 只读打开。
O_WRONLY 只写打开。
O_RDWR 读、写打开。
O_APPEND 每次写时都加到文件的尾端。
O_CREAT 若此文件不存在则创建它。使用此选择项时，需同时说明第三个参数

mode，用其说明该新文件的存取许可权位。
O_EXCL 如果同时指定了O_CREAT，而文件已经存在，则出错。这可测试一个文件

是否存在，如果不存在则创建此文件成为一个原子操作。
O_TRUNC 如果此文件存在，而且为只读或只写成功打开，则将其长度截短为0。
O_NOCTTY 如果p a t h n a m e指的是终端设备，则不将此设备分配作为此进程

的控制终端。
O_NONBLOCK 如果p a t h n a m e指的是一个F I F O、一个块特殊文件或一个字

符特殊文件，则此选择项为此文件的本次打开操作和后续的I / O操作设置非阻塞

方式。
O_SYNC 使每次w r i t e都等到物理I / O操作完成。
这些控制字都是通过“或”符号分开（|）
当调用系统调用open时，操作系统会将文件系统对应设备文件的inode中的

file_operations安装进用户进程的task_struct中的file_struct，然后再调用具

体文件的file_operations中的open函数，其他的read、write等等也是如此，所

以实际上open操作实际上是一个连接过程，我个人认为称其为open容易误导。至

于file_operations中的针对底层硬件的操作，简单地说实际上就是对具体硬件接

口的控制/状态寄存器和数据寄存器的读写，如硬盘这种硬件有其自己的控制器，

所以他自己内部会定期处理寄存器的命令和数据，完成相应的操作请求，请求完

成后cpu发中断

可以通过fcntl先获取原有flags(文件的打开属性，如读写，阻塞等)，再用fcntl

改变flags属性
4g空间

内核空间（1G）包括pcb(进程控制块)
pcb包函关于此程序的所有文件描述符表，文件描述符表中FILE,FILE结构体存了0

，1，2，3的文件描述符
FILE中包括以下部份：
1：文件访问控制属性O_RDWR,0_NONBLOCK（可以不用重新找开文件的情况下更改

文件的访问权限）
2:文件读写指针位置
3：inode指向真正的磁盘文件如指向：abc.text
4:ioctl杂项参数，物理自有属性，用于控制硬件属性，如显示屏分辨率

ioctl.jpg
linux系统应用层：如a.out可以用open,read,write,ioctl操作文件描述符
识别文件描述符对应的驱动层
驱动层：
1:串口命令（UART_open,UART_read,UART_iocl）
2.磁盘命令（file_open,file_read,file_ioctl）
3.显示屏命令（LCD_OPEN,LCD_write,LCD_ioctl）


truncate.jpg

truncate的意义：
用于改变一个文件的原有大小。
表头文件：#include <unistd.h>
定义函数：int truncate(const char *path, off_t length);
函数说明：truncate()会将参数path指定的文件大小改为参数length指定的大小

。 如果原来的文件大小比参数length大，则超过的部分会被删除
返回值：执行成功则返回0， 失败返回-1， 错误原因存于errno
错误代码：EACCESS 参数path所指定的文件无法存取
EROFS 欲写入的文件存在于只读文件系统内
EFAULT 参数path指针超出可存取空间
EINVAL 参数path包含不合法字符
ENAMETOOLONG 参数path太长
ENOTDIR 参数path路径并非一目录
EISDIR 参数path指向一目录
ETXTBUSY 参数path所指的文件为共享程序，而且正被执行中
ELOOP 参数path有过多符号连接问题
EIO I/O存取错误

tree 递归显示目录下的文件结构
ls -r 进入到子目录中显示内容

ext2.jpg
ext2文件系统是继ext文件系统后的文件系统，现在有ext3,ext4文件系统，升级

版，只是多了一些字段。

问题：
当open时，/home/itcast/hello.txt文件是如何存储的？
如何找到/home/itcast/hello.txt文件
如何恢复文件?
文件系统是怎么布局存储的？
文件系统的函数？
512GB的磁盘，如果存文件，需要一个文件管理系统，需要知道哪里存的歌，哪里

存的电影。
1.首先磁盘分了若干个组，每个组分了很多块。
2.整个磁盘的第一个块（boot block）block占固定大小1024字节，无论是ntfs，

都有这个块，是启动块，放分区信息，如哪个盘装了操作系统，有几个盘
3.扇区是windows磁盘的概念。1扇区（物理块）=512bytes，在linux中实验场景

1block = 1024B(bytes)=512bytes,真实系统：1block = 4096= 8扇

区,1block=8192bit。
4.实验场景：因为多个block,所以分成若干个组，一个组有若干的block，组的大

小取决于块的大小。每个block是1024B，如何管理block?
结构：

                       Group0
boot   super  GDTF块      block   indeo                          
block  block  组描述符表  bitmap  bitmap  inode表 data数据块
(1024B)                  (块位图)（1byte）

boot block:整个磁盘的第一个块（boot block）block占固定大小1024字节，无

论是ntfs，都有这个块，是启动块，放分区信息，如哪个盘装了操作系统，有几

个盘

super boot:描述了文件块有多大，上次创建时间，每组有多少块。group0与

group1的super boot数据相同，互为备份，系统在使用时仅调用group0的块就可

以了。

GDT块组描述符表：描述从第几个块开始是block bitmap,第几个块儿开始是inode 

table等


block bitmap块位图：有8192bit，可以描述8192个块有没有使用，1代表用，0代

表没有使用。所以block bitmap能描述多少个块就代表组有多大。所以一个组有
8192个块，一个块有1024B，一个组大小= 8192*1024B

inode bitmap位图：用于记录有多少个inode被使用了，一共有1024大小。

inode table:是一张表，存放了许多inode.一个inode主要由两部份组成，一个块

可以放8个inode

inode的大小 size = 128B，每个Inode代表一个文件，所以删除文件只是把inode 

bitmap 至1.

属性：stat ioctl.c  （查看文件的属性） 
可以查看文件权限，文件大小，文件所有者uid，访问时间
硬链接数link inode编号 IO块大小 块：8(指扇区个数) IO块：4096指块大小

数据块指针：一共有15个指针 block[0],block[1],每个指针占4个字节，每一个

指针指向存放数据块的编号。inode有一级不指向真正的文件，指向二级指针，二

级不指向真正文件指向三级指针，三级索引，三级指针可指向文件地址，所以一

个inode中有15个指针，每个都指向下一组指针，这样一个inode实现了可以创建

一个很大的文件。一级寻址，二级间接寻址，三级间接寻址。多一级指向的越大

。

data数据块：存放数据，如音乐，电影的数据，文件内容，一个文件太小，造成

数据块浪费

创建一个文件，向文件系统申请一个inode。可以得到需要创建文件的大小，权限

等。

如果存一个高清电影，所有的data block块都被高清电影用完，这样，inode浪费
如果存很多小文件，inode用完，但是data block块没有用完，data block浪费


group0为里面的每一个块统一编号，1，2，3....group1接着继续往下编号
inode也是编一编号


数据块的文件真正删除掉是无法恢复的，用inode bitmap可以把inode bitmap置1

，能恢复数据

linux /目录的inode号是2，这是固定值 stat / 
vi / 中目录存放子目录和文件名。如果在ext2中存根目录，根目录对应一个

datablock,这个块有一个记录项，
主要记录node号，文件名长度，文件名，文件类型。

dup.jpg
 dup/dup2

int dup(int oldfd);
int dup2(int oldfd, int newfd);
2.13节 VFS虚拟文件系统 25
dup和dup2都可用来复制一个现存的文件描述符，使两个文件描述符指向同一个

file结
构体。如果两个文件描述符指向同一个file结构体，File Status Flag和读写位

置只保存一
份在file结构体中，并且file结构体的引用计数是2。如果两次open同一文件得到

两个文件
描述符，则每个描述符对应一个不同的file结构体，可以有不同的File Status 

Flag和读写
位置。请注意区分这两种情况。

typedef.c typedef的用法，lseek是偏移文件指针位置
typedef off_t int;
typedef off_t long long;

off_t a;

off_t lseek(int fd, off_t offset, int whence);

lseek.c lseek的用法
#include <unistd.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <fcntl.h>
#include <string.h>

int main(void)
{
    char buf[1024] = "hello itcast\n";
    char str[1024];
    int len, fd;

    fd = open("abc", O_CREAT | O_RDWR, 0777);
    write(fd, buf, strlen(buf));
    lseek(fd, 0, SEEK_SET);//偏移到0，起始位置
    len = read(fd, str, sizeof(str));
    write(STDOUT_FILENO, str, len);
    close(fd);

    return 0;
}


lseek_creatfile.c//通过偏移到文件末尾，在末尾写入\0创建一个大文件

#include <unistd.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <fcntl.h>
#include <string.h>

int main(void)
{
    int len, fd;

    fd = open("abc", O_CREAT | O_RDWR, 0777);
    lseek(fd, 1024*1024*10 - 1, SEEK_SET);
    write(fd, "\0", 1);      //write(fd, 'a', 1);

    close(fd);

    return 0;
}


fcntl.c fcntl改变文件的属性如阻塞，只读等

#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
int main(void)
{
    int flags;

    flags = fcntl(STDIN_FILENO, F_GETFL); //STDIN_FILENO 是当前终端的标

准输入，也可以换成别的文件的fd
    flags |= O_NONBLOCK;
    fcntl(STDIN_FILENO, F_SETFL, flags);

    printf("after set nonblock\n");

    if (flags & O_RDONLY)
        printf("file : O_RDONLY\n");
    else if (flags & O_WRONLY)
        printf("file : O_WRONLY\n");
    else if (flags & O_RDWR)
        printf("file : O_RDWR\n");

    if (flags & O_NONBLOCK)
        printf("file : O_NONBLOCK\n");

    return 0;
}


ioctl.c  
ioctl用于向设备发控制和配置命令，有些命令也需要读写一些数据，但这些数据

是不能用read/write读写的，称为Out-of-band数据。也就是说，read/write读写

的数据是in-band数据，是I/O操作的主体，而ioctl命令传送的是控制信息，其中

的数据是辅助的数据。例如，在串口线上收发数据通过read/write操作，而串口

的波特率、校验位、停止位通过ioctl设置，A/D转换的结果通过read读取，而A/D

转换的精度和工作频率通过ioctl设置。
if(ioctl(STDOUT_FILENO, TIOCGWINSZ, &size)
d是某个设备的文件描述符。request是ioctl的命令，可变参数取决于request，

通常是一个指向变量或结构体的指针。若出错则返回-1，若成功则返回其他值，

返回值也是取决于request。

以下程序使用TIOCGWINSZ命令获得终端设备的窗口大小。


#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/ioctl.h>
int main(void)
{
    struct winsize size;
    if (isatty(STDOUT_FILENO) == 0)
        exit(1);
    if(ioctl(STDOUT_FILENO, TIOCGWINSZ, &size)<0) {
        perror("ioctl TIOCGWINSZ error");
        exit(1);
    }
    printf("%d rows, %d columns\n", size.ws_row, size.ws_col);
    return 0;
}

access.c 判断文件存不存在，存在返回0，不存在返回-1

#include <stdio.h>
#include <unistd.h>

int main(int argc, char *argv[])
{
    if (!access(argv[1], W_OK))
        printf("can be write\n");
    else
        printf("can't be write\n");

    return 0;
}


chmod.c  chmod改变文件的读写许可设置，如果改变成功返回0，否则返回-1
mode_t 实际上也就是一种无符号整数。
另外如下结构 struct stat 定义中的 st_mode 成员变量也是使用的 mode_t 类

型的变量。

#include <stdio.h>
#include <unistd.h>

int main(int argc, char *argv[])
{
    char str[1024];
    mode_t mode;
    //  0644
    fgets(str, sizeof(str), stdin);
    mode = atoi(str); 
    chmod(argv[1], mode);
    return 0;
}


stat.c 如何判断文件的类型，先用stat可以得到文件的indeo，indeo描述了文件

的属性以及映射的物理块数据，通过struct stat的st_mode可以拿到文件的类型,

同时可以拿到文件的其它属性
WGRP 是用户组用户写的权限
IWOTH 是非所有者或用户组用户写的权限
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>


/*
   struct stat *buf; //sizeof(buf) = 4
   stat(argv[1], buf);
   */
int main(int argc, char *argv[])
{
    struct stat buf; //sizeof(buf)
    //stat(argv[1], &buf);
    lstat(argv[1], &buf);
    printf("%s size = %d\n", argv[1], (int)buf.st_size);
    int flag = buf.st_mode & S_IRWXO;
    if (flag & S_IWOTH)
        printf("others can be write\n");

    return 0;
}

truncate.c truncae在文件已经打开的情况下可以改变文件的大小

#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <fcntl.h>

int main(int argc, char *argv[])
{
    int len, fd;
    if (argc < 3) {
        printf("./a.out filename size\n");
        exit(-1);
    }
    len = atoi(argv[2]);
    fd = open(argv[1], O_CREAT | O_RDWR, 0644);
    ftruncate(fd, len);
    close(fd);
    return 0;
}

link.c
link命令的使用
这个命令最常用的参数是-s，具体用法是：
sudo ln -s 源文件 目标文件

     当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的

目录下都放一个必须相同的文件，
我们只要在某个固定的目录放上该文件，然后在其它的目录下用ln命令链接

（link）它就可以，不必重复的占用磁
盘空间。
例如：sudo ln -s /usr/local/mysql/bin/mysqladmin /sbin/mysqladmin
-s 是代号（symbolic）的意思。
     若是可执行文件，一般我们将其链接到/sbin的目录下，这样可以直接输入

文件名称执行命令了，而不需要带上
目录地址。
如在上例执行下面两个语句是等价的
yajiu@yajiu-desktop:~$ mysqladmin -uroot -p password ubuntu
yajiu@yajiu-desktop:~$ /usr/local/mysql/bin/mysqladmin -uroot -p 

password ubuntu

这里有两点要注意：
第一，ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处

，其它的文件都会发生相同的变化；
第二，ln的链接又分软链接和硬链接两种，软链接就是ln -s ** **，它只会在你

选定的位置上生成一个文件的镜像，
不会占用磁盘空间，硬链接ln ** **，没有参数-s， 它会在你选定的位置上生成

一个和源文件大小相同的文件，
无论是软链接还是硬链接，文件都保持同步变化。
     如果你用ls察看一个目录时，发现有的文件右上角有一个箭头，那就是一个

用ln命令生成的文件，用ls -l命令
去察看，就可以看到显示的link的路径了

语　法：ln [-bdfinsv][-S <字尾备份字符串>][-V <备份方式>][--help][--

version][源文件或目录][目标文件或
目录] 或 ln [-bdfinsv][-S <字尾备份字符串>][-V <备份方式>][--help][--

version][源文件或目录...][目的目录]

补充说明：ln指令用在连接文件或目录，如同时指定两个以上的文件或目录，且

最后的目的地是一个已经存在的
目录，则会把前面指定的所有文件或目录复制到该目录中。若同时指定多个文件

或目录，且最后的目的地并非是
一个已存在的目录，则会出现错误信息。

参　　数：
-b或--backup      #删除，覆盖目标文件之前的备份
-d或-F或--directory      #建立目录的硬连接
-f或--force      #强行建立文件或目录的连接，不论文件或目录是否存在
-i或--interactive      #覆盖既有文件之前先询问用户
-n或--no-dereference      #将符号连接的目的目录视为一般文件
-s或--symbolic      #对源文件建立符号连接，而非硬连接
-S<字尾备份字符串>或--suffix=<字尾备份字符串>      #用"-b"参数备份目标

文件

#include <stdio.h>
#include <unistd.h>

int main(int argc, char *argv[])
{
    link(argv[1], argv[2]);
    return 0;
}


readlink.c
相关函数： stat, lstat, symlink
表头文件： #include <unistd.h>
定义函数：int  readlink(const  char *path,  char *buf, size_t  bufsiz);
函数说明：readlink()会将参数path的符号连接内容到参数buf所指的内存空间，

返回的内容不是以NULL作字符串结尾，但会将字符串的字符数返回。若参数

bufsiz小于符号连接的内容长度，过长的内容会被截断

返回值   ：执行成功则传符号连接所指的文件路径字符串，失败返回-1， 错误

代码存于errno
错误代码：
               EACCESS                  取文件时被拒绝，权限不够
               EINVAL                    参数bufsiz为负数
               EIO                         O存取错误
               ELOOP                     欲打开的文件有过多符号连接问题
               ENAMETOOLONG       参数path的路径名称太长
               ENOENT                   参数path所指定的文件不存在
               ENOMEM                   核心内存不足
               ENOTDIR                   参数path路径中的目录存在但却非

真正的目录


#include <unistd.h>
#include <stdio.h>

int main(void)
{
    char buf[1024];
    int len;
    len = readlink("bbb", buf, sizeof(buf));
    buf[len] = '\0';
    printf("%s\n", buf);
    return 0;
}

unlink.c 删除文件的链接数
看了unlink()函数是对文件的删除，于是写了一个函数进行测试之，结果发现在调用了unlink以后仍然可以对文件进行读写操作，又看了一下书才明白是我没有明白unlink函数的真正含义：删除目录相并减少一个连接数，如果链接数为0并且没有任何进程打开该文件，该文件内容才能被真正删除，但是若又进程打开了该文件，则文件暂时不删除直到所有打开该文件的进程都结束时文件才能被删除。

#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

int main(int argc, char *argv[])
{
    int fd, i = 0, len;
    char buf[1024];
    fd = open("tmpfile", O_CREAT | O_RDWR, 0777);
    unlink("tmpfile");
    write(fd, "helloworld", 10);
    while (i < 5) {
        i++;
        sleep(1);
    }
    lseek(fd, 0, SEEK_SET);
    len = read(fd, buf, sizeof(buf));
    write(STDOUT_FILENO, buf, len);
    close(fd);
    return 0;
}

getcwd.c
头文件：#include

定义函数：char * getcwd(char * buf, size_t size);

函数说明：getcwd()会将当前的工作目录绝对路径复制到参数buf 所指的内存空间，参数size 为buf 的空间大小。

注：
1、在调用此函数时，buf 所指的内存空间要足够大。若工作目录绝对路径的字符串长度超过参数size 大小，则返回NULL，errno 的值则为ERANGE。
2、倘若参数buf 为NULL，getcwd()会依参数size 的大小自动配置内存(使用malloc())，如果参数size 也为0，则getcwd()会依工作目录绝对路径的字符串程度来决定所配置的内存大小，进程可以在使用完次字符串后利用free()来释放此空间。

返回值：执行成功则将结果复制到参数buf 所指的内存空间, 或是返回自动配置的字符串指针. 失败返回NULL,错误代码存于errno.

范例
#include
main()
{
    char buf[80];
    getcwd(buf, sizeof(buf));
    printf("current working directory : %s\n", buf);
}

执行：
current working directory :/tmp 


ls_R.c
递归打印出文件目录名及文件名

#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <dirent.h>
#include <stdio.h>
#include <string.h>
#define MAX_PATH 1024
/* dirwalk: apply fcn to all files in dir */
void dirwalk(char *dir, void (*fcn)(char *))
{
    char name[MAX_PATH];
    struct dirent *dp;
    DIR *dfd;
    if ((dfd = opendir(dir)) == NULL) {
        fprintf(stderr, "dirwalk: can't open %s\n", dir);
        return;
    }
    while ((dp = readdir(dfd)) != NULL) {
        if (strcmp(dp->d_name, ".") == 0
                || strcmp(dp->d_name, "..") == 0)
            continue;

        /* skip self and parent */
        //  /home/itcast   hello.c
        //  "/home/itcast/hello.c"
        if (strlen(dir)+strlen(dp->d_name)+2 > sizeof(name))
            fprintf(stderr, "dirwalk: name %s %s too long\n",
                    dir, dp->d_name);
        else {
            sprintf(name, "%s/%s", dir, dp->d_name);
            (*fcn)(name);
            //fcn(name);
        }
    }
    closedir(dfd);
}
/* fsize: print the size and name of file "name" */
void fsize(char *name)
{
    struct stat stbuf;
    if (stat(name, &stbuf) == -1) {
        fprintf(stderr, "fsize: can't access %s\n", name);
        return;
    }
    if ((stbuf.st_mode & S_IFMT) == S_IFDIR)
        dirwalk(name, fsize);   //回调函数，fsize作为参数传递
    printf("%8ld %s\n", stbuf.st_size, name);
}
int main(int argc, char **argv)
//int main(int argc, char *argv[])
{
    if (argc == 1) /* default: current directory */
        fsize(".");         //./a.out
    else
        while (--argc > 0)   //./a.out dir
            fsize(*++argv);
    return 0;
}

dup.c  dup2 dup

dup和dup2也是两个非常有用的调用，它们的作用都是用来复制一个文件的描述符。它们经常用来重定向进程的stdin、stdout和stderr。这两个函数的原形如下：
 
C代码  收藏代码
#include <unistd.h>  
int dup( int oldfd );  
int dup2( int oldfd, int targetfd );  
 
 
dup()函数
 
利用函数dup，我们可以复制一个描述符。传给该函数一个既有的描述符，它就会返回一个新的描述符，这个新的描述符是传给它的描述符的拷贝。这意味着，这两个描述符共享同一个数据结构。例如，如果我们对一个文件描述符执行lseek操作，得到的第一个文件的位置和第二个是一样的。下面是用来说明dup函数使用方法的代码片段：
 
C代码  收藏代码
int fd1, fd2;  
...  
fd2 = dup( fd1 );  
 
    需要注意的是，我们可以在调用fork之前建立一个描述符，这与调用dup建立描述符的效果是一样的，子进程也同样会收到一个复制出来的描述符。 
 
 
dup2()函数
 
    dup2函数跟dup函数相似，但dup2函数允许调用者规定一个有效描述符和目标描述符的id。dup2函数成功返回时，目标描述符（dup2函数的第二个参数）将变成源描述符（dup2函数的第一个参数）的复制品，换句话说，两个文件描述符现在都指向同一个文件，并且是函数第一个参数指向的文件。下面我们用一段代码加以说明：
 
C代码  收藏代码
int oldfd;  
oldfd = open("app_log", (O_RDWR | O_CREATE), 0644 );  
dup2( oldfd, 1 );  
close( oldfd );  
 
    在本例中，我们打开了一个新文件，称为“app_log”，并收到一个文件描述符，该描述符叫做fd1。我们调用dup2函数，参数为oldfd和1，这会导致用我们新打开的文件描述符替换掉由1代表的文件描述符（即stdout，因为标准输出文件的id为1）。任何写到stdout的东西，现在都将改为写入名为“app_log”的文件中。需要注意的是，dup2函数在复制了oldfd之后，会立即将其关闭，但不会关掉新近打开的文件描述符，因为文件描述符1现在也指向它。 
 
 
例子
 
下面我们介绍一个更加深入的示例代码。回忆一下命令行管道，我们可以将ls –l命令的标准输出作为标准输入连接到wc –l命令。接下来，我们就用一个C程序来加以说明这个过程的实现。代码如下所示。 
 
C代码  收藏代码
#include <stdio.h>  
#include <stdlib.h>  
#include <unistd.h>  
  
int main()  
{  
    int pfds[2];  
  
    if ( pipe(pfds) == 0 ) {  
  
    if ( fork() == 0 ) {  
  
        close(1);  
        dup2( pfds[1], 1 );  
        close( pfds[0] );  
        execlp( "ls", "ls", "-l", NULL );  
  
    } else {  
  
        close(0);  
        dup2( pfds[0], 0 );  
        close( pfds[1] );  
        execlp( "wc", "wc", "-l", NULL );  
  
    }  
  
    return 0;  
}  
 
    在示例代码中，首先在第9行代码中建立一个管道，然后将应用程序分成两个进程：一个子进程（第13–16行）和一个父进程（第20–23行）。接下来，在子进程中首先关闭stdout描述符（第13行），然后提供了ls –l命令功能，不过它不是写到stdout（第13行），而是写到我们建立的管道的输出端，这是通过dup2函数来完成重定向的。在第14行，使用dup2 函数把stdout重定向到管道（pfds[1]）。之后，马上关掉管道的输入端。然后，使用execlp函数把子进程的映像替换为命令ls –l的进程映像，一旦该命令执行，它的任何输出都将发给管道的输入端。 
 
    现在来研究一下管道的接收端。从代码中可以看出，管道的接收端是由父进程来担当的。首先关闭stdin描述符（第20行），因为我们不会从机器的键盘等标准设备文件来接收数据的输入，而是从其它程序的输出中接收数据。然后，再一次用到dup2函数（第21行），让管道的输入端作为输入，这是通过让文件描述符0（即常规的stdin）重定向到pfds[0]实现的。关闭管道的stdout端（pfds[1]），因为在这里用不到它。最后，使用 execlp函数把父进程的映像替换为命令wc -l的进程映像，命令wc -l把管道的内容作为它的输入（第23行）。

26进程




进程

进程状态.jpg：

状态分：运行态，挂起，就绪，结束终止进程。如果用sleep(10)进程挂起，
运行态，挂起，就绪态可以相互切换，但是结束终止状态不能到运行态，就绪态

，挂起态。反过来可以。

如果一个单核cpu,是不能并发的，多个cpu才可以，单个采用分时复用技术
1时间片=10ms,1s = 100时间片。
如果有4个进程，则第一个进程给20时间片，第二个进程给40时间片，第三个进程

给40时间片，当第一个进程执行20时间片后，切到第二个进程执行40时间片，再

切到第三个进程40时间片。


cpu知识：
一般寄存器:AX、BX、CX、DX
AX:累积暂存器，BX:基底暂存器，CX:计数暂存器，DX:资料暂存器

索引暂存器:SI、DI
SI:来源索引暂存器，DI:目的索引暂存器

堆叠、基底暂存器:SP、BP
SP:堆叠指标暂存器，BP:基底指标暂存器

EAX、ECX、EDX、EBX：為ax,bx,cx,dx的延伸，各為32位元
ESI、EDI、ESP、EBP：為si,di,sp,bp的延伸，32位元

eax, ebx, ecx, edx, esi, edi, ebp, esp等都是X86 汇编语言中CPU上的通用寄

存器的名称，是32位的寄存器。如果用C语言来解释，可以把这些寄存器当作变量

看待。

比方说：add eax,-2 ; //可以认为是给变量eax加上-2这样的一个值。

这些32位寄存器有多种用途，但每一个都有“专长”，有各自的特别之处。

EAX 是"累加器"(accumulator), 它是很多加法乘法指令的缺省寄存器。

EBX 是"基地址"(base)寄存器, 在内存寻址时存放基地址。

ECX 是计数器(counter), 是重复(REP)前缀指令和LOOP指令的内定计数器。

EDX 则总是被用来放整数除法产生的余数。

ESI/EDI分别叫做"源/目标索引寄存器"(source/destination index),因为在很多

字符串操作指令中, DS:ESI指向源串,而ES:EDI指向目标串.

EBP是"基址指针"(BASE POINTER), 它最经常被用作高级语言函数调用的"框架指

针"(frame pointer). 在破解的时候,经常可以看见一个标准的函数起始代码:
　　
　　push ebp ;保存当前ebp
　　mov ebp,esp ;EBP设为当前堆栈指针
　　sub esp, xxx ;预留xxx字节给函数临时变量.
　　...
　　
　　这样一来,EBP 构成了该函数的一个框架, 在EBP上方分别是原来的EBP, 返回

地址和参数. EBP下方则是临时变量. 函数返回时作 mov esp,ebp/pop ebp/ret 

即可.

ESP 专门用作堆栈指针，被形象地称为栈顶指针，堆栈的顶部是地址小的区域，

压入堆栈的数据越多，ESP也就越来越小。在32位平台上，ESP每次减少4字节。



386部分寄存器：



状态和控制寄存器组除了EFLAGS、EIP ，还有四个32位的控制寄存器，它们是CR0

，CR1，CR2和CR3。

这几个寄存器中保存全局性和任务无关的机器状态。

CR0中包含了6个预定义标志，0位是保护允许位PE(Protedted Enable)，用于启动

保护模式，如果PE位置1，则保护模式启动，如果PE=0，则在实模式下运行。1位

是监控协处理位MP(Moniter coprocessor)，它与第3位一起决定：当TS=1时操作

码WAIT是否产生一个“协处理器不能使用”的出错信号。第3位是任务转换位

(Task Switch)，当一个任务转换完成之后，自动将它置1。随着TS=1，就不能使

用协处理器。CR0的第2位是模拟协处理器位 EM (Emulate coprocessor)，如果

EM=1，则不能使用协处理器，如果EM=0，则允许使用协处理器。第4位是微处理器

的扩展类型位ET(Processor Extension Type)，其内保存着处理器扩展类型的信

息，如果ET=0，则标识系统使用的是287协处理器，如果 ET=1，则表示系统使用

的是387浮点协处理器。CR0的第31位是分页允许位(Paging Enable)，它表示芯片

上的分页部件是否允许工作。

CR1是未定义的控制寄存器，供将来的处理器使用。

CR2是页故障线性地址寄存器，保存最后一次出现页故障的全32位线性地址。

CR3是页目录基址寄存器，保存页目录表的物理地址，页目录表总是放在以4K字节

为单位的存储器边界上，因此，它的地址的低12位总为0，不起作用，即使写上内

容，也不会被理会。

这几个寄存器是与分页机制密切相关的，因此，在进程管理及虚拟内存管理中会

涉及到这几个寄存器，读者要记住CR0、CR2及CR3这三个寄存器的内容。


esp：寄存器存放当前线程的栈顶指针
ebp：寄存器存放当前线程的栈底指针

eip：寄存器存放下一个CPU指令存放的内存地址，当CPU执行完当前的指令后，从

EIP寄存器中读取下一条指令的内存地址，然后继续执行。



处理器现场.jpg

4g空间中，会把代码段中text指令交给CPU作处理，如果代码段中有线程，则cpu

中用esp寄存器存放当前线程的栈顶指针，用ebp存放当前线程的栈底指针。
EAX 是"累加器"(accumulator), 它是很多加法乘法指令的缺省寄存器。
EBX 是"基地址"(base)寄存器, 在内存寻址时存放基地址。
保存处理器现场和恢复处理器现场用到了EAX EBX ESP


物理内存和虚拟内存映射。

因为物理内存有限，当物理内存不够用的时候，所以有交换分区的概念，把内存

中暂时不用的数据，存到磁盘的交换分区，给其它程序用。在linux中当内存不足

的时候，把一部分硬盘空间虚拟成内存使用,从而解决内存容量不足的情况。交换

分区一般是物理内存的两部，物理内存2G，交换分区是4G。

首先./b.out文件在磁盘上。从下到上有，.text代码段（b.out），共享库

gblic.so...内核空间pcb .

把/b.out交给物理内存，物理内存由下到上有b.out,glibc.so.a.out.kernel 

pcb.物理内存有2g

把物理内存通过mmu内存管理单元，把物理内存映射成虚拟内存。

也就是4G空间
4G空间包括：

内核区：
1.linux kernel
2.pcb (文件描述符表,文件描述符表中有关于文件的flags属性，偏移位置f_pos

，以及区动)
3.另一个pcb (struct task_struct)
4.系统调用，调用一些动态库时系统调用去访问mmu,通过mmu再射到物理内存去访

问
3G空间：
1.环境变量
2.命令行参数
3.栈
4.共享库映射区glibc.so
5.空洞
堆 
.bss 全局变量未初始化，常量


.data 静态变量初始化
.ro.data 只读静态变量
.text代码段，只存二进制指令




环境变量唯一
A,B,C进程都有独立的进程地址空间，有各自的PCB，它们共用一块儿4G空间，在

4G空间的内核区划分了各自的PCB，在用户3G空间划分了多个各自的用户空间


fork.jpg

fork用于创建子进程
pid_t = fork(void) fork一次调用两次返回，父进程中返回子进程的pid,子进程

中返回0.

当fork的时候，在共用的内核空间会多一份子进程的pcb
在3G空间会clone克隆一份，当3G空间的TEXT代码需要读取的时候，可以共享读取

代码，但当需要写操作的时候，复制了整个3g空间，子进程可以用exec去执行

b.out程序

exec.jpg
exec关于环境变量
在3G空间中会根据路径去找对应于磁盘上的a.out并启动


wait.jpg
当开启一个子进程，内核中就会有子进程的pcb，PCB会记录进程的死亡原因。
父进程用wait方法可以去查看和回收子进程的PCB，并且kill -9 杀掉子进程，并

return 终止子进程，如果没有用wait方法，则kill子进程，但是子进程的pcb还

在，这种子进程是僵尸进程，如果父进程死了，子进程还在，子进程没有父亲，

这种进程是孤儿进程。


main.c libc中定义的全局变量environ指向环境变量表，environ没有包含在任何

头文件中，所以在使用时要用extern声明,由于父进程在调用fork创建子进程时会

把自己的环境变量表也复制给子进程，所以
a.out打印的环境变量和Shell进程的环境变量是相同的。
按照惯例，环境变量字符串都是name=value这样的形式，大多数name由大写字母

加下划
线组成，一般把name的部分叫做环境变量，value的部分则是环境变量的值。环境

变量定义
了进程的运行环境，一些比较重要的环境变量的含义如下：
PATH
* 可执行文件的搜索路径。ls命令也是一个程序，执行它不需要提供完整的路径

名/bin/
ls，然而通常我们执行当前目录下的程序a.out却需要提供完整的路径名./a.out

，这
是因为PATH环境变量的值里面包含了ls命令所在的目录/bin，却不包含a.out所在

的目
录。PATH环境变量的值可以包含多个目录，用:号隔开。在Shell中用echo命令可

以查
看这个环境变量的值：
$ echo $PATH
SHELL
3.1节 进程环境 29
* 当前Shell，它的值通常是/bin/bash。
TERM
* 当前终端类型，在图形界面终端下它的值通常是xterm，终端类型决定了一些程

序的输
出显示方式，比如图形界面终端可以显示汉字，而字符终端一般不行。
LANG
* 语言和locale，决定了字符编码以及时间、货币等信息的显示格式。
HOME
* 当前用户主目录的路径，很多程序需要在主目录下保存配置文件，使得每个用

户在运
行该程序时都有自己的一套配置。
用environ指针可以查看所有环境变量字符串，但是不够方便，如果给出name要在

环境变量
表中查找它对应的value，可以用getenv函数。
#include <stdlib.h>
char *getenv(const char *name);
getenv的返回值是指向value的指针，若未找到则为NULL。
修改环境变量可以用以下函数
#include <stdio.h>
int main(void)
{
    extern char **environ;
    int i;
    for(i=0; environ[i]!=NULL; i++)
        printf("%s\n", environ[i]);
    return 0;
}


env.c

修改环境变量可以用以下函数
#include <stdlib.h>
int setenv(const char *name, const char *value, int rewrite);
void unsetenv(const char *name);
putenv和setenv函数若成功则返回为0，若出错则返回非0。
setenv将环境变量name的值设置为value。如果已存在环境变量name，那么
若rewrite非0，则覆盖原来的定义；
若rewrite为0，则不覆盖原来的定义，也不返回错误。
unsetenv删除name的定义。即使name没有定义也不返回错误。
例 修改环境变量


#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[])
{
    printf("PATH=%s\n", getenv(argv[1]));
    setenv(argv[1], "hello", 1);
    printf("PATH=%s\n", getenv(argv[1]));

    return 0;
}



fork.c 创建子进程
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <sys/types.h>
int main(void)
{
    int num = 0;
    pid_t pid;
    pid = fork();  //创建子进程
    if (pid < 0) {
        perror("fork");
        exit(-1);
    }
    else if (pid > 0) {     //这是父进程，pid是子进程的id号
        while (1) {
            printf("%d I am parent %d\n", num++, getpid());
            sleep(1);
        }
    }   
    else {      //pid==0   这是子进程，这段代码只有子进程才会执行
        while (1) {
            printf("%d I am child %d, my parent is %d\n", num, getpid

(), getppid());
            num += 2;
            sleep(3);
        }
    }
    return 0;
}


execl.c  
exec族
用fork创建子进程后执行的是和父进程相同的程序（但有可能执行不同的代码分

支），
子进程往往要调用一种exec函数以执行另一个程序。当进程调用一种exec函数时

，该进程的
用户空间代码和数据完全被新程序替换，从新程序的启动例程开始执行。调用

exec并不创建
新进程，所以调用exec前后该进程的id并未改变。
其实有六种以exec开头的函数，统称exec函数：
#include <unistd.h>
int execl(const char *path, const char *arg, ...);
int execlp(const char *file, const char *arg, ...);
int execle(const char *path, const char *arg, ..., char *const envp[]);
int execv(const char *path, char *const argv[]);
int execvp(const char *file, char *const argv[]);
int execve(const char *path, char *const argv[], char *const envp[]);
这些函数如果调用成功则加载新的程序从启动代码开始执行，不再返回，如果调

用出错
则返回-1，所以exec函数只有出错的返回值而没有成功的返回值。


//   gcc execl.c -o a.out
#include <stdio.h>
#include <unistd.h>

int main(void)
{
    printf("hello\n");
    execl("./b.out", "./b.out", "111", "aaa", NULL);
    printf("world\n");
    return 0;
}

b.c
//  gcc b.c -o b.out
#include <stdio.h>

int main(int argc, char *argv[])
{
    int i;

    for (i = 0; i < argc; i++)
    //for (i = 0; argv[i] != NULL; i++)
        printf("argv[%d] = %s\n", i, argv[i]);
    printf("itcast\n");
    return 0;
}


example.c 进程的使用
#include <stdio.h>
#include <unistd.h>
// ./a.out times str
int main(int argc, char *argv[])
{
    pid_t pid1, pid2;//进程id
    int i = 0;
    if (argc < 3) {//最少传入3个参数
        printf("./a.out ntimes str\n");
        return -1;
    }
    pid1 = fork();  //  不能在这里fork();  //A
    if (pid1 > 0) {如果大于0执行的是父进程的代码
        pid2 = fork();   //B 在父进程中创建一个子进程
        if (pid2 > 0) {  //如果是父进程，打印出每个传入的参数，每打一次

睡一秒
            while (i < atoi(argv[1])) {
                printf("argv[2] = %s\n", argv[2]);
                i++;
                sleep(1);
            }
        }
        else if (pid2 == 0) {//创建的是子进程
            execlp("stardict", "stardict", NULL); //去PATH环境变量里找

路径
        }
        else {
            perror("fork");
        }
    }
    else if (pid1 == 0) {
        execl("/usr/bin/firefox", "firefox", "www.sina.com.cn", 

NULL);//子进程将执行firefox程序
    }
    else {
        perror("fork");
        return -1;
    }

    return 0;
}

execv.c  可通把一些shell命令放入数据中用execv来执行
这里相当 于用execv重写了一个ls -l命令

#include <stdio.h>
#include <unistd.h>

char *argvv[10];
int main(void)
{
    argvv[0] = "ls";
    argvv[1] = "-l";
    argvv[2] = NULL;

    execvp("ls", argvv);

    printf("*****************\n");
    return 0;
}

wait.c  父进程回收子进程


表头文件
编辑

#include<sys/types.h>
#include<sys/wait.h>
定义函数 pid_t waitpid(pid_t pid,int * status,int options);
2函数说明
编辑

如果在调用 waitpid()时子进程已经结束,则 waitpid()会立即
返回子进程结束状态值。 子进程的结束状态值会由参数 status 返回,
而子进程的进程识别码也会一起返回。如果不在意结束状态值,则
参数 status 可以设成 NULL。参数 pid 为欲等待的子进程识别码,
其他数值意义如下:
pid<-1 等待进程组识别码为 pid 绝对值的任何子进程。
pid=-1 等待任何子进程,相当于 wait()。
pid=0 等待进程组识别码与目前进程相同的任何子进程。
pid>0 等待任何子进程识别码为 pid 的子进程。
参数options提供了一些额外的选项来控制waitpid，参数 option 可以为 0 或可

以用"|"运算符把它们连接起来使用，比如：
ret=waitpid(-1,NULL,WNOHANG | WUNTRACED);
如果我们不想使用它们，也可以把options设为0，如：
ret=waitpid(-1,NULL,0);
WNOHANG 若pid指定的子进程没有结束，则waitpid()函数返回0，不予以等待。若

结束，则返回该子进程的ID。
WUNTRACED 若子进程进入暂停状态，则马上返回，但子进程的结束状态不予以理

会。WIFSTOPPED(status)宏确定返回值是否对应与一个暂停子进程。
子进程的结束状态返回后存于 status,底下有几个宏可判别结束情况:
WIFEXITED(status)如果若为正常结束子进程返回的状态，则为真；对于这种情况

可执行WEXITSTATUS(status)，取子进程传给exit或_eixt的低8位。
WEXITSTATUS(status)取得子进程 exit()返回的结束代码,一般会先用 WIFEXITED 

来判断是否正常结束才能使用此宏。
WIFSIGNALED(status)若为异常结束子进程返回的状态，则为真；对于这种情况可

执行WTERMSIG(status)，取使子进程结束的信号编号。
WTERMSIG(status) 取得子进程因信号而中止的信号代码,一般会先用 

WIFSIGNALED 来判断后才使用此宏。
WIFSTOPPED(status) 若为当前暂停子进程返回的状态，则为真；对于这种情况可

执行WSTOPSIG(status)，取使子进程暂停的信号编号。
WSTOPSIG(status) 取得引发子进程暂停的信号代码,一般会先用 WIFSTOPPED 来

判断后才使用此宏。
如果执行成功则返回子进程识别码(PID) ,如果有错误发生则返回
返回值-1。失败原因存于 errno 中。




#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>


int main(void)
{
    pid_t pid;
    int i = 0;
    pid = fork();
    if (pid == 0) {//子进程打印，得到子进程id
        printf("I am child %d, my parent is %d\n", getpid(), getppid

());
        while (1)
            ;
        return 3;
    }
    else if (pid > 0) {//父进程
        int status;
        pid_t child_pid;
        printf("I am parent\n");
        //child_pid = wait(&status);
        child_pid = waitpid(0, &status, WNOHANG);//若pid指定的子进程没

有结束，则waitpid()函数返回0，不予以等待。若结束，则返回该子进程的ID。
        //child_pid = wait(NULL);
        printf("child %d is over\n", child_pid);
        if (WIFEXITED(status))//如果正常结束了子进程
            printf("child return num is %d\n", WEXITSTATUS(status));//

取得子进程 exit()返回的结束代码,一般会先用 WIFEXITED 来判断是否正常结束

才能使用此宏。
        while (1);
    }
    else {
        perror("fork");
        return -1;
    }
    return 0;
}

multfork.c

#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
int main(void)
{
    int i;
    pid_t pid;
    for (i = 0; i < 3; i++) {
        pid = fork();/循环创建子进程
        if (pid == 0)//如果创建成功跳出
            break;
        else if (pid < 0) {//创建失败打印错误
            perror("fork");
        }
    }
    switch (i) {
        case 0://子进程1执行firefox程序
            printf("00000\n");
            execlp("firefox", "firefox", "www.itcast.cn", NULL);  //PATH
            break;
        case 1://子进程2执行编缉工具的程序
            {
            printf("11111\n");
            char *argvv[] = {"gedit", "a.html", NULL};
            execvp("gedit", argvv);
            break;
            }
        case 2:子进程3执行某路径下的程序
            printf("22222\n");
            execl("/usr/bin/stardict", "stardict", NULL);
            break;
        case 3:   //parent 父进程
            printf("parent\n");
            while (1) {
                printf("wait my child\n");
                waitpid(0, NULL, WNOHANG);//回收子进程，非阻塞方式回收
                sleep(1);
            }
    }
    return 0;
}

27进程间通信

pipe例子1.jpg

父与子进程通过管道通信：

父 只读-通过共用file结构体的读写操作，这个file结构体是个管道-子 只写
（关闭写端）                                               （关闭读端）


fpathconf.c 
 函数pathconf()和fpathconf()作用相同，它们都用于查询与文件系统限制和选

项有关的值，不同的只是pathconf()作用于文件名pathname，而fpathconf()作用

于已打开的文件描述字 filedes。
PC_PIPE_BUF是查看管道的缓冲区大小

#include <stdio.h>
#include <unistd.h>

int main(void)
{
    int fd[2];
    pipe(fd);//这是无名管道，这个管道是没有名字的
    printf("pipe size = %ld\n", fpathconf(fd[0], _PC_PIPE_BUF));
    printf("pipe size = %ld\n", fpathconf(fd[1], _PC_PIPE_BUF));
    return 0;
}


pipe.c  无名管道实现父子这间的通信
无名管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起

两个管道；只能用于父子进程或者兄弟进程之间（具有亲缘关系的进程）。管道

对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种

文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。数据

的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内

容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。向

管道中写入数据时,linux将不保证写入的原子性，管道缓冲区一有空闲区域，写

进程就会试图向管道写入数据。如果读进程不读走管道缓冲区中的数据，那么写

操作将一直阻塞。只有在管道的读端存在时，向管道中写入数据才有意义。否则

，向管道中写入数据的进程将收到内核传来的SIFPIPE信号，应用程序可以处理该

信号，也可以忽略（默认动作则是应用程序终止）。
#include <unistd.h>
int pipe(int fd[2])
该函数创建的管道的两端处于一个进程中间，在实际应用中没有太大意义
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>

void sys_err(char *str)
{
    perror(str);
    exit(-1);
}
int main(void)
{
    int fd[2];//创建一个数组，这个数组用于存放管道的读端和写端
    pid_t pid;

    if (pipe(fd) < 0)//创建管道失败返回-1
        sys_err("pipe");
    printf("fd[0] = %d\n", fd[0]);//创建成功打印管道的读写端文件描述符

，fd[0]是输入端，也就是读。
    printf("fd[1] = %d\n", fd[1]);

    if ((pid = fork()) < 0)//如果创建子进程失败，打印出错信息
        sys_err("fork");
    else if (pid == 0) {//如果是子进程
        close(fd[0]);//关闭输入端
        char buf[1024];
        int i = 0;
        while (1) {
            sprintf(buf, "hello itcast %d\n", i++);
            write(fd[1], buf, strlen(buf));  //子进程写数据到管道
            sleep(1);
        }
    }
    else {
        close(fd[1]);//父进程，只需要读，所以关闭掉写端
        char buf[1024];
        int len;
        while (1) {
            len = read(fd[0], buf, sizeof(buf));   //父进程读管道
            write(STDOUT_FILENO, buf, len);//最后把读到的信息打印到屏幕

上
        }
    }

    return 0;
}

transferball.c   用pipe（）无名管道实现的案例，见管道习题.jpg


#include <stdio.h>
#include <unistd.h>

void close_pipe(int pfd[3][2], int pip_num, int child_n)//关闭不同子进

程写端
{
    for (j = 0; j < pip_num; j++) {
        if (j != i || j != i+1) {
            close(pfd[j][0]);
            close(pfd[j][1]);
        }
    }
    close(fd[child_n][1]);
    if (child_n+1 < pip_num)
       close(fd[child_n+1][0]);
    return;
}
int main(void)
{
    int i, pfd[3][2];
    for (i = 0; i < 3; i++)
        pipe(pfd[i]);//创建3个管道
    for (i = 0; i < 3; i++) {
        if ((pid = fork()) == 0)//如果pid==0，表示是父进程，子进程创建

完毕
            break;
        else if (pid < 0)//小于0，创建子进程错识破
            sys_err("fork");
    }

    switch(i) {
        case 0://子进程1
            close_pip(pfd, 3, i);//读端输入端关闭
            execlp("./worker", "./worker", "1", NULL); break;
        case 1:execlp("./worker", "./worker", "2", NULL); break;
        case 2:execlp("./worker", "./worker", "0", NULL); break;
    }

    
}


pipe2.jpg
有名管道的第二种情况，两个子进程通信
父进程fork()出两个子进程，父进程关闭读端和写端
子进程1关闭读端，打开写端，向管道（管道其实是在一个程序中创建的文件描述

符的结构体）向管道中写数据。子进程2关闭写端，打开读端，从管道读出写入的

数据，实现了两个子进程之间的通讯。


fifo.jpg 有名管道，这个管道有名字
这个模型是实现两个独立的进程这间的通讯，通过 mkfifo(argv[1], 0664);函数

创建有名管道。有名管道更好，它不在一个进程空间，全双工状态，两方都可以

读可以写操作
有名管道：不同于管道之处在于它提供一个路径名与之关联，以FIFO的文件形式

存在于文件系统中。这样，即使与FIFO的创建进程不存在亲缘关系的进程，只要

可以访问该路径，就能够彼此通过FIFO相互通信（能够访问该路径的进程以及

FIFO的创建进程之间），因此，通过FIFO不相关的进程也能交换数据。值得注意

的是，FIFO严格遵循先进先出（first in first out），对管道及FIFO的读总是

从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如lseek()等

文件定位操作。



首先在磁盘上mkfifo(argv[1], 0664)创建一个testfifo的文件描述符及有名管道

在A进程中open("testfifo",o_WFONLY);以只写方式打开

在B进程中open("testfifo",o_RDONLY);以只读方式打开

A进程写数据到testfifo文件中，B进程从testfifo文件中读数据

实现两个不相关的进程通讯。


read_a.c


int access(const char *pathname, int mode);   
参数： 
pathname: 需要测试的文件路径名。   
mode: 需要测试的操作模式，可能值是一个或多个R_OK(可读?), W_OK(可写?), 

X_OK(可执行?) 或 F_OK(文件存在?)组合体。 



#include <stdio.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <fcntl.h>
#include <string.h>
int main(int argc, char *argv[])
{
    int fd,  len;
    char buf[1024];
    if (argc < 2) {//参数最少2个
        printf("./a.out fifoname\n");
        return -1;
    }
    if (access(argv[1], F_OK))//判断传入的文件是否存在
        mkfifo(argv[1], 0664);//如果传入文件存在通过mkfifo创建一个以该

文件名的有名管道
    /* argv[1] 是外部传递进来的有名管道名  */
    fd = open(argv[1], O_RDONLY); //只读打开
    while (1) {
        len = read(fd, buf, sizeof(buf));
        write(STDOUT_FILENO, buf, len);//把读到的数据写到屏幕中
        sleep(3);
    }
    return 0;
}

write_b.c b.c执行写入有名管道实现通迅的操作
#include <stdio.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <fcntl.h>
#include <string.h>
int main(int argc, char *argv[])
{
    int fd, i = 0;
    char buf[1024];
    if (argc < 2) {
        printf("./a.out fifoname\n");
        return -1;
    }
    if (access(argv[1], F_OK))
        mkfifo(argv[1], 0664);
    /* argv[1] 是外部传递进来的有名管道名  */
    fd = open(argv[1], O_WRONLY); 
    while (1) {
        sprintf(buf, "itcast %d\n", i++);
        write(fd, buf, strlen(buf));
        sleep(1);
    }
    return 0;
}

管道的4种特殊情况.jpg
1.写端未写数据，读端阻塞
2.写端写数据，读端未读，写满管道，写端阻塞
3，写端写管道，读端已关闭，写端进程收到一个信号（SIGPIPE），然后终止写

进程
4.写端写关闭，读端读管道，读完管道里的数据后，读端再次读，返回0


mmap.jpg
mmap操作提供了一种机制，让用户程序直接访问设备内存，这种机制，相比较在

用户空间和内核空间互相拷贝数据，效率更高。在要求高性能的应用中比较常用

。mmap映射内存必须是页面大小的整数倍，面向流的设备不能进行mmap，mmap的

实现和硬件有关。

磁盘映射mmap
1:提高操作磁盘文件的效北，简化文件读写操作
2.多个进程映射同一磁盘文件，实现进程间通信。

void *mmap(void *addr,size_t length,int prot,int flags,int fd,off_t 

offset);
addr //映射区的开始地址，设置为0时表示由系统决定映射区的起始地址。
length //申请内存大小，不要超过3G
flags包括很多参数，常用的MAP_SHARD/MAP_PRIVATE
MAP_SHARED //与其它所有映射这个对象的进程共享映射空间。对共享区的写入，

相当于输出到文件。直到msync()或者munmap()被调用，文件实际上不会被更新。
MAP_PRIVATE //建立一个写入时拷贝的私有映射。内存区域的写入不会影响到原

文件。这个标志和以上标志是互斥的，只能使用其中一个。
fd,要映射的文件描述符
offset 文件偏移位置，必须是4096的整数倍

函数返回说明

成功执行时，mmap()返回被映射区的指针，munmap()返回0。失败时，mmap()返回

MAP_FAILED[其值为(void *)-1]，munmap返回-1。errno被设为以下的某个值
EACCES：访问出错
EAGAIN：文件已被锁定，或者太多的内存已被锁定
EBADF：fd不是有效的文件描述词
EINVAL：一个或者多个参数无效
ENFILE：已达到系统对打开文件的限制
ENODEV：指定文件所在的文件系统不支持内存映射
ENOMEM：内存不足，或者进程已超出最大内存映射数量
EPERM：权能不足，操作不允许
ETXTBSY：已写的方式打开文件，同时指定MAP_DENYWRITE标志
SIGSEGV：试着向只读区写入
SIGBUS：试着访问不属于进程的内存区



mmap_shared_r.c  共享映射空间的读文件

#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>
#include <string.h>

struct STU {//一个学生信息结构体
    int id;
    char name[100];
    char sex;
};
int main(void)
{
    int fd, i = 1;
    struct STU *mm;//定义一个学生信息结构体类型指针
    fd = open("abc", O_RDWR);//以可读写打开一个abc文件

    mm = mmap(NULL, sizeof(struct STU), PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);//成功则返回一个指针指向学生信息结构体
    //printf("%d\t%s\t%c\n", mm->id, mm->name, mm->sex);
    while (1) {//不断的读取
        printf("%d\t%s\t%c\n", mm->id, mm->name, mm->sex);//打印出学生信息
        sleep(1);
    }

    munmap(mm, sizeof(struct STU));//函数说明 munmap()用来取消参数start所指的映射内存起始地址，参数length则是欲取消的内存大小
    close(fd);
    return 0;
}



mmap_shared_w.c

#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>
#include <string.h>

struct STU {
    int id;
    char name[100];
    char sex;
};
int main(void)
{
    int fd, i = 1;
    struct STU *mm;
    fd = open("abc", O_CREAT | O_TRUNC | O_RDWR, 0666);//以创建的方式打开一个文件abc
    ftruncate(fd, sizeof(struct STU));//创建文件的大小为学生信息结构体大小

    mm = mmap(NULL, sizeof(struct STU), PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);//创建这个共享映射区，返回的指针指向了学生信息结构体类型
    while (1) {//不断的写入
        mm->id = i;
        sprintf(mm->name, "itcast %d", mm->id);//写入名字
        mm->sex = 'm';
        i++;
        sleep(1);
    }

    munmap(mm, sizeof(struct STU));
    close(fd);
    unlink("abc");
    return 0;
}


mmap.c  


#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>
#include <string.h>

int main(void)
{
    int fd;
    struct stat fbuf;
    char *mm;
    fd = open("abc", O_RDWR);
    fstat(fd, &fbuf);//取得该文件abc的状态，如ino，块数目，设备号，文件大小
    mm = mmap(NULL, fbuf.st_size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);//创建一个共享映射区
    close(fd);

    strcpy(mm, "itcastasd");

    munmap(mm, fbuf.st_size);
    return 0;
}



mmap_child.c  父子进程也可以通过mmap进行通讯

#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>
#include <string.h>
struct STU {
    int id;
    char name[100];
    char sex;
};//学生信息结构体
int main(void)
{
    int fd, i = 1;
    struct STU *mm;
    pid_t pid;
    fd = open("abc", O_CREAT | O_TRUNC | O_RDWR, 0666);
    ftruncate(fd, sizeof(struct STU));//创建一个abc文件，大小和结构体一样大
    mm = mmap(NULL, sizeof(struct STU), PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);//以共享映射的方式创建出这个共享映射区
    if (mm == MAP_FAILED) {//使用指定的映射起始地址，如果由start和len参数指定的内存区重叠于现存的映射空间，重叠部分将会被丢弃。如果指定的起始地址不可用，操作将会失败。并且起始地址必须落在页的边界上。
        perror("mmap");
        return -1;
    }
    if ((pid = fork()) < 0) {
        perror("fork");
        return -1;
    }
    else if (pid > 0) { //in parent
        while (1) {
            mm->id = i;
            sprintf(mm->name, "itcast %d", mm->id);
            mm->sex = 'm';
            i++;
            sleep(1);
        }
    }
    else {              //in child
        while (1) {
            printf("%d\t%s\t%c\n", mm->id, mm->name, mm->sex);
            sleep(1);
        }
    }

    munmap(mm, sizeof(struct STU));
    close(fd);
    unlink("abc");
    return 0;
}




manage_task.c  这只是一个案例，没看太懂

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/wait.h>
#include <string.h>

#define N 3

void sys_err(const char *str)
{
    perror(str);
    exit(-1);
}
// ./a.out item  task_fork
int main(int argc, char *argv[])
{
    int ntask, item;
    if (argc == 2)
        ntask = N;//ntask=3
    else if (argc < 2)  {
        printf("./a.out item task_fork");
        exit(-1);
    }
    else            
        ntask = atoi(argv[2]);

    item = atoi(argv[1]);

    int i, j, pfd[ntask][2];
    pid_t pid[ntask];
    memset(pid, 0, ntask*sizeof(pid_t));

    for (i = 0; i < ntask; i++) {
        if (pipe(pfd[i]) < 0)//循环创建几个管道
            sys_err("pipe");
    }
    for (i = 0; i < ntask; i++) {
        if ((pid[i] = fork()) < 0)
            sys_err("fork");
        else if (pid[i] == 0) {
            /*in child*/
            char pipe_r[16];
            char pipe_w[16];
            sprintf(pipe_r, "%d", pfd[i][0]);
            close(pfd[i][1]);//子进程关闭写端

            if (i < ntask-1) {
                sprintf(pipe_w, "%d", pfd[i+1][1]);
                close(pfd[i+1][0]);
            }

            for (j = 0; j < ntask; j++) {
                if (j == i) {
                    j++;
                    continue;
                }
                close(pfd[j][0]);
                close(pfd[j][1]);
            }


            if (i == ntask -1) 
                sprintf(pipe_w, "%d", -1);
                
             
            execl("do_task", "./do_task", pipe_r, pipe_w, NULL);

            break;
        }
    }

    if (i == ntask) {
        /* 父进程是管理进程,使用0号管道的写端 */
        close(pfd[0][0]);
        for (j = 1; j< ntask; j++) {
            close(pfd[j][0]);
            close(pfd[j][1]);
        }
        write(pfd[0][1], &item, sizeof(item));
        while (wait(NULL) > 0)
            ;
        close(pfd[0][1]);
    }

    return 0;
}

do_task.c

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int main(int argc, char *argv[])
{
    int item, rfd, wfd;
    if (argc < 3) {
        printf("./do_task  pipe_r pipe_w\n");
        exit(-1);
    }
    rfd = atoi(argv[1]);
    wfd = atoi(argv[2]);

    read(rfd, &item, sizeof(item));
    sleep(item);
    item++;
    printf("itme = %d\t%d\n", item, getpid());
    if (wfd == -1) {
        //write(STDOUT_FILENO, &item, sizeof(item));
        printf("%d\n", item);
        close(rfd);
        return 0;
    }
    else
        write(wfd, &item, sizeof(item));

    close(rfd);
    close(wfd);

    return 0;
}


28 myshell以及共享库静态库

29信号

1.信号

信号（LINUX信号机制）
信号是Unix、类Unix以及其他POSIX兼容的操作系统中进程间通讯的一种有限制的

方式。它是一种异步的通知机制，用来提醒进程一个事件已经发生。当一个信号

发送给一个进程，操作系统中断了进程正常的控制流程，此时，任何非原子操作

都将被中断。如果进程定义了信号的处理函数，那么它将被执行，否则就执行默

认的处理函数。


2.信号编号

通过kill -l查看信号编号

xingwenpeng@ubuntu:~$ kill -l
1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP
6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL 10) SIGUSR1
11) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM
16) SIGSTKFLT 17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP
21) SIGTTIN 22) SIGTTOU 23) SIGURG 24) SIGXCPU 25) SIGXFSZ
26) SIGVTALRM 27) SIGPROF 28) SIGWINCH 29) SIGIO 30) SIGPWR
31) SIGSYS 34) SIGRTMIN 35) SIGRTMIN+1 36) SIGRTMIN+2 37) SIGRTMIN+3
38) SIGRTMIN+4 39) SIGRTMIN+5 40) SIGRTMIN+6 41) SIGRTMIN+7 42) 

SIGRTMIN+8
43) SIGRTMIN+9 44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) 

SIGRTMIN
+13
48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) 

SIGRTMAX-12
53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9 56) SIGRTMAX-8 57) 

SIGRTMAX-7
58) SIGRTMAX-6 59) SIGRTMAX-5 60) SIGRTMAX-4 61) SIGRTMAX-3 62) 

SIGRTMAX-2
63) SIGRTMAX-1 64) SIGRTMAX

前32个信号是我们需要讨论的：
0-31需讨论，叫经典信号，任何进程都可以用。
34-64的信号是时时信号，作为linux开发底层人员使用，如车辆有esp系统，传感

器硬件感知车身不稳定，会发给系统，系统再发给某一个硬件较正车身。这些信

号可以写底层的人员自己定义。暂时不讨论

经典信号举例：
9号信号是要杀死一个进程
13号信号sigpipe管道错误会终止进程
操作系统为了方便管理进程而制定了信号，这些信号是要发给进程的
cat 捕捉终端输入字符并打印出来。

ps -aux 查看进程列表
找到进程号
kill -11 5344(进程号)对没有地址的访问会产生段错误
出现（段错误）的提示
kill -8 5344
浮点数例外（核心已转储，存储了core错误信息）如果除0会报这个错误
信号可以杀死，暂停进程
如何用信号关闭进程，进程管理器统计进程信息，也是用信号杀死其它进程的。
每个信号会给进程产生什么行为呢？
man 7 signal
Term Default action is to terminate the process.
Ign Default action is to ignore the signal.
Core Default action is to terminate the process and dump core (see 

core(5)).
Stop Default action is to stop the process.
Cont Default action is to continue the process if it is currently 

stopped.
50 第5章 信号
First the signals described in the original POSIX.1-1990 standard.
Signal Value Action Comment
SIGHUP 1 Term Hangup detected on controlling terminal
or death of controlling process
SIGINT 2 Term Interrupt from keyboard
SIGQUIT 3 Core Quit from keyboard
SIGILL 4 Core Illegal Instruction
SIGABRT 6 Core Abort signal from abort(3)
SIGFPE 8 Core Floating point exception
SIGKILL 9 Term Kill signal
SIGSEGV 11 Core Invalid memory reference
SIGPIPE 13 Term Broken pipe: write to pipe with no
readers
SIGALRM 14 Term Timer signal from alarm(2)
SIGTERM 15 Term Termination signal
SIGUSR1 30,10,16 Term User-defined signal 1
SIGUSR2 31,12,17 Term User-defined signal 2
SIGCHLD 20,17,18 Ign Child stopped or terminated
SIGCONT 19,18,25 Cont Continue if stopped
SIGSTOP 17,19,23 Stop Stop process
SIGTSTP 18,20,24 Stop Stop typed at tty
SIGTTIN 21,21,26 Stop tty input for background process
SIGTTOU 22,22,27 Stop tty output for background process
The signals SIGKILL and SIGSTOP cannot be caught, blocked, or ignored.
表中第一列是各信号的宏定义名称，第二列是各信号的编号，第三列是默认处理

动作:
Term表示终止当前进程.
Core表示终止当前进程并且Core Dump（Core Dump 用于gdb调试,在unbto系统默

认没开启，需要ulimit -c 1024去开启，再用gdb a.ou core去调试）.
Ign表示忽略该信号.
Stop表示停止当前进程.
Cont表示继续执行先前停止的进程.




信号触发行为.jpg：
一个操作系统信号有三种行为五种动作，操作系统发送信号都是发送给进程的

pcb,pcb记录了信号。
当一个进程接收到一个信号的三种行为
第一个叫默认行为：
第二个叫忽略行为：
知三个捕捉行为：当信号产生，捕捉到信号，用函数去处理这个信号。
执行五种动作，动作就是信号的表现形式：
term 终止当前进程。
core 终止当前进程，并且产生core文件，方便查看这个进程终止的原因
stop 挂起/暂停当前进程
continun 唤醒挂起/暂停进程，进入就绪态
ign 忽略此信号，比如发个8号信号，可以用函数忽略掉这个8号信号

在man 7 signal中描述了每一种信号产生5种动作的原因的原因。
sigchld 信号的动作是ign ,当子进程意外死记会通过该信号通知父进程。
之前让子进程回收，用wait()阻塞或轮循，检测子进程是否死掉。

怎样改变一个SIGPIPE信号的默认动作？
可以为SIGPIPE注册一个捕捉函数，实现自定义动作，改变了默认动作
当收到这个SIGPIPE函数时会调用这个自定义的do_sigpipe.
void do_sigpipe(int sig)
{
    printf("hello");
    return;//返回到内核空间里，余下的代码段将会继续执行。
}
sigkill  sigstop 这两个信号比较特殊，不能被捕捉，阻塞，忽略。



信号集的处理：
操作系统为了方便管理信号，设置了几个信号集
每个PCB都包含了以下未决信号集，阻塞信号集，信号处理动作

未决信号集：未决信号集里是整型数组，记录收到的2号信号，并置1，表示收到

。当记录以后操作系统要处理这个信号的动作，在处理动作前需要经过阻塞信号

集。未决信号集由kerne内核自动控制，我们无法设置，但是可以读取

阻塞信号集：程序号可以获取和设置该信号集，让某此信号是否响应。0表示此信

号允许通过，1表示阻塞不可以通过。通过的可以处理动作

信号处理动作：也是一个数组，比如2号默认动作，总是默认动作终止文件，

sig_dfl(默认)=》term(终此进程)，可以由程序员更改对应编号的动作行为，如
4号位置对应的是sig_dfl=》 可以把这4号动作改为sig_ign忽略，更改了信号默

认动作

首先由内核发送信号给pcb，pcb接收到这个信号，用一个未决信号集去记录

两个述语描述它：
未决：信号产生了，但没有被响应,回为阻塞信号集阻塞了，则信号处于未决态
递达:信号产生并被响应/处理了，则称此信号递达。当处理了这个信号，应对未

决位自动置0.如果操作系统不置0未决位，那会再次发此信号。


系统开放了一组信号集操作函数

sigset_t block_set;//定义一个信号集变量

构造信号集
sigemptyset(&block_set);//把信号集清0的函数
sigfillset(sigset_t *set);//把信号集所有位置1，不允计任合通过
sigaddset(&block_set,SIGINT);//把信号集的第几号置1
sigdelset(sigset_t *set ,int signo)//把信号集的第几号置0
sigismember(xonst sigset_t *set,in)//判断信号集的某一号位置是否置1了


把构造好的信号集改变成为当前进程pcb里阻塞进信号集。
sigprocmask

前32个信号不累加它发送的信号次数
后32个系统级的时实信号会累加它的次数


manpage 2 sifprocmask 获取阻塞信号集并设置信号集的方法

int sigprocmask(int how,const sigset_t *set(现在的信号集，const表示无发

传出，因为不能传出)，sigset_t *oldset（原来的进程的信号集））;
how有三种操作！
sig_block  ： set包含了我们希望添加到当前信号屏蔽字（信号屏蔽字又叫阻塞

信号集）的信号，用原来的信号集和现在的信号集作|操作。mask = mask（原有

的信号集）|set(新的信号集)  ，这个相当于设一个新信号


SIG_UNBLOCK set包含了我们希望从当前信号屏蔽字中解除阻塞的信号，取反再与

操作，这个相当于设置阻塞信号集为0，可以让信号通过。

SIG_SETMASK 设置当前信号屏蔽字为set所指向的值，相当于mask=set.直接把现

在的信号集替换掉原来的信号集

sigpending（sigset_t *set）;读取当前进程的未决信号集，通过set参数传出，

调用成功返回0，失败-1.描述了一个信号产生了，但是没有递达。

9号信号是不允许被阻塞进

sigprockmask.c

#include <stdio.h>
#include <unistd.h>
#include <signal.h>



void printsigset(sigset_t *set)
{
	int i;
	static int j = 0;
	for (i = 1; i < 32; i++)//遍历32种信号
	if (sigismember(set, i) == 1) {//传入未决信号集，如果当前为1，

表示发送了这种信号，测试未决信号集中第i个信号有没有置1 
		putchar('1');//打印字符串1
		if (sigismember(set, SIGINT) == 1) {//如果传入的是ctrl

+c这种信号
			if (j < 10)//计个数，如果是循环了10次以内让

ctrl+c阻塞
				j++;//此信号加1
			else
				sigprocmask(SIG_UNBLOCK, set, NULL);//

设置所有阻塞信号非阻塞
		}
	}
	else
		putchar('0');//没有的信号位打印0
	puts("");
}

int main(void)
{
	sigset_t set, pend;//阻塞信号的设置，未决信号只读，阻塞信号可写

可读

	sigemptyset(&set);//阻塞信号集先设置为0，全非阻塞
	sigaddset(&set, SIGINT);//ctrl+c信号添加一个1阻塞位
	sigprocmask(SIG_SETMASK, &set, NULL);//传阻塞信号集，设置更改当

前CTRL+C信号位阻塞

	while (1) {
		sigpending(&pend);//读取当前进程的未决信号集，成功返回

零，失败返回1
		printsigset(&pend);//判断哪些信号未决了
		sleep(1);
	}
	return 0;
}


信号捕捉设定
1。主程序在用户空间执行正常指令，有一个信号导致程序暂停，系统调用就会进

入内核，2.如果内核有信号到达，就会调三种行为，默认，忽略，捕捉，如果是

默认动作，进程就中止掉，如果是忽略，则把未决信号集那一位置0就忽略掉了。

如果是捕捉，进入第3阶段，由内核去切换用户空间的捕捉函数，用户空间实现了

捕捉函数，也就是程序的那段内存空间实现捕捉函数，当用户空间执行完后，再

切换到内核空间5.内核空间return 再返回到刚在第1阶段主程序中断的那个点继

续执行主程序代码。


如何为信号设置捕捉函数：
$include <signal.h>
int sigaction(int signum,const struct sigaction *act,struct sigaction 

*oldact);
signum,为第多少号信号设置参数。
act是传入参数 现在想要设置的信号是什么
oldact传出参数 原来的信号是什么

信号一般都是由系统发出的。
struct sigaction 定义：
struct sigaction{
	void (*sa_handler)(int);//函数指针，指向一个捕捉函数
	void (*sa_sigaction)(int ,siginfo_t *,void *);//与第1个函数互斥

，另一种函数指针实现捕捉，与sa_flags配合使用
   	sigset_t sa_mask;//执行捕捉函数的时候还想阻塞哪些信号
	int sa_flags;//选择用哪个函数指针，与sa_mask互斥
	void (*sa_restorer)(void);//弃用
};
捕捉函数.png
当信号产生的时候调一个too的捕捉函数。

信号处理动作
SIG_DFL默认处理term结束进程，但这个时候要改变处理动作，不去执行term,去

调too函数。

接收到信号，切到内核PCB，经过未决，阻塞，处理动作时去调too函数，too函数

执行完再切回用户空间。

如果处理捕捉函数时又有同样的这个信号过来。会阻塞，直到这个函数处理完返

回到用户空间。
sa_mask 意思是当你执行捕捉函数的时候你还想阻塞哪些信号。当捕捉函数执行

完毕，恢复原有的mask.
mask=mask|现有的(mask)

代码例子：当ctrl +c 不终止程序实现一个捕捉函数

sigaction.c
#include <stdio.h>//信号的捕捉
#include <signal.h>

void do_sig(int n)//捕捉函数这个n是操作系统传递的，这个n正好是捕捉的这

个信号编号
{
    printf("hello world %d\n", n);
    return ;
}
int main(void)
{
    struct sigaction act;  //声名一个信号动作的结构体

    act.sa_handler = do_sig;    //函数指针 , 也可以设置为SIG_DFL（处理

默认动作）  , SIG_IGN（忽略动作）
    act.sa_flags = 0;           //0表示默认，选用sa_handler这个函数指针

，因为sa_handle这个函数指针可注册捕捉函数，另外个函数指针也可以设置捕捉

函数
    sigemptyset(&act.sa_mask);  //对信号集清0，因为没想好在捕捉函数执行

的时候还想阻塞哪些信号，执行捕捉函数时，设置mask = mask | sa_mask,信号

发过来的时候，能捕捉到，执行do_sig动作，在执行过程中如果有其它信号发过

来，可设置为阻塞状态。捕捉动作执行完成后又把后来设置的阻塞进行还原。这

里是把所有阻塞进状态设为0，非阻塞

    sigaction(SIGINT, &act, NULL);  //为SIGINT设置捕捉函数, 注册捕捉函

数，捕捉2号信号Interrupt from keyboard 从键盘输入的信号

    while (1) {
        printf("*************\n");; 
        sleep(1);
    }
    return 0;
}
/*
struct sigaction {
	void(*sa_handler)(int);
	void(*sa_sigaction)(int, siginfo_t *, void *);
	sigset_t   sa_mask;
	int        sa_flags;
	void(*sa_restorer)(void);
};
*/
//信号种类
/*
ctl+c SIGINT
ctl+z SIGTSTP
ctl+\ SIGQUIT
*/

信号能干什么事情？
我们知道进程间通信可以解决数据在进程间传输的问题。信号可以控制父子间进

程的同步问题。什么是同步，你执行一次，我执行一次。轮流执行。如打拳，你

打一拳，我打一拳，但是你打十拳我打十拳也许我就倒下了。所以用信号可控制

同步。实现父子报数，父数1，子数2.如果是并发操作，无法控制，有可能父亲数

了10，儿子只数了4.并发一般是多个CPU内核分别去执行，所以谁执行多，谁执行

少有区别的。


利用SIGUSR1和SIGUSR2信号实现父子进程同步输出，这两个信号操作系统没有给

它函义，我们可以自定义这个信号捕捉函数。，这两个信号的默认动作是退出程

序。
a.out 发SIGUSR1，捕捉SIGUSR2，把数+1
b.out 发SIGUSR2, 捕捉SIGUSR1,把数+1


信号控制进程间同步。也就是进程1执行一次，进程2执行一次，交替执行。
sigsync.c 实现父子进程同步，父进程数1，子进程数2，交替进行

#include <stdio.h>
#include <unistd.h>
#include <signal.h>
//父子进程间1，2，3交换增加值
pid_t pid;//全局的进程ID
void do_child(int n)
{
    static int num = 2;
    printf("child\t%d\n", num);
    num += 2;
    kill(getppid(), SIGUSR1);//发送信号
}
void do_parent(int n)
{
    static int num = 3;
    printf("parent\t%d\n", num);
    num += 2;
    kill(pid, SIGUSR1);//发送信号
}

int main(void)
{
    struct sigaction act;//信号执行动作的结构体
    sigset_t set;//阻塞进信号的结构体
    sigemptyset(&set);//设置阻塞值为0
    sigaddset(&set, SIGUSR1);//添加一个自定义的信号
    sigprocmask(SIG_SETMASK, &set, NULL);//设置这个SIGUSR1信号为阻塞,因

为有可能fork一个子进程，还未来得及注册，此时已经收到父进程发的信号，而

信号默认是让子进程中断。
    pid = fork();//开进程
    if (pid > 0) {
        //父进程先报数
        act.sa_handler = do_parent;//定义捕捉到信号要执行的函数
        act.sa_flags = 0;//按第一种函数类型去执行
        sigemptyset(&act.sa_mask);//设置在捕捉的过程中其它信号来访时不

阻塞
        sigaction(SIGUSR1, &act, NULL);//注册后将会对这个阻塞信号进行捕

捉
        sigprocmask(SIG_UNBLOCK, &set, NULL);//取消阻塞，由于分时复用有

可能未注册就接收信号，所以需要防止

        printf("parent\t%d\n", 1);
        kill(pid, SIGUSR1);//发送一个信号
        while (1)
            ;
    }
    else if (pid == 0) {
        //子进程等侯父进程通知，再进行报数
        act.sa_handler = do_child;
        act.sa_flags = 0;
        sigemptyset(&act.sa_mask);

        sigaction(SIGUSR1, &act, NULL);//接收一个信号会执行do_child函数
        sigprocmask(SIG_UNBLOCK, &set, NULL);//取消阻塞

        while(1)
            ;
    }
    else {
        perror("fork");    return -1;
    }
    return 0;
}



信号实现一些服务器程序的重启。及管理
sudo /etc/init.d/nfs-kernel-server restar 实现了重启NFS kernel  daemon
那是怎样实现了让这个NFS kernel daemon怎么重新启动了呢？

服务器应用程序都用到了信号！



/tmp/nfs_pid 启动时，创建一个临时文件记录进程ID号。
当修改/etc/profile配置文件，改变了共享目录，需要
nfs restart重启nfs 

nfs 的restart命令，会重新启动程序，但在启动前检测临时文件，发现这个临时

文件有这个程序的进程号。此时nfs会给这个进程发一个信号，SIGUSR1，这个进

程会捕捉到这个信号，执行一些释放操作再退出程序。再实现重新启动。

很多服务器程序都是用信号来作的。

如  ps aux | grep vsftpd 查看它的进程号
sudo /etc/init.d/vsftpd restart  这个都是通过信号实现重启实现的


信号解决僵尸进程

C标准库也有信号处理函数如下：

typedef void (*sighandler_t)(int)//函数指针类型
sighandler_t signal(int signum,sighandler_t handler)//这个函数意味可以

跨平台实现信号捕捉，signum,信号编号是哪个，handler捕捉到执行哪个函数,返

回一个sighandler,表示原来的捕捉函数是谁
int system(const char *command)//集合FORK,EXEC,wait 一体，可以实再捕捉

到函数创建子进程，EXEC其它程序，父进程回收子进程。


C标准库处理信号捕捉函数例：

signal.c

#include <signal.h>
#include <stdio.h>

void do_sig(int n)
{
    printf("hello %d\n", n);
}
int main(void)
{
    signal(SIGINT, do_sig);//捕捉输入信号，如ctrl+c 结束进程指令改为do_sig指令 C语言的捕捉信号方式
    while (1) {
        printf("***********\n");
        sleep(1);
    }
    return 0;
}


SIGCHLD信号处理，当子进程终止的时候，或子进程被暂停的时候，父进程会收到

SIGCHLD信号。

父进程正常干自己的事情，当子进程死后发信号的时候，父进程捕捉处理这个信

号。

wait_sigchld.c  这个程序ps -aux发现一堆子进程僵尸。
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>


void do_sig(int num)//回收每个死去的子进程
{
    wait(NULL);//一个一个回收
}
int main(int argc, char *argv[])
{
    pid_t pid;
    int i;
    struct sigaction act;//捕捉动作结构体
    if (argc < 2) {
        printf("./a.out num\n");
        return -1;
    }

    act.sa_handler = do_sig;//捕捉函数名为do_sig
    act.sa_flags = 0;//默认用第一种函数指针类型
    sigemptyset(&act.sa_mask);//设置捕捉函数处理时信号集所有置0，不阻塞任何发送来的信号，除非发的信号和上一个相同，将不处理，直到捕捉函数执行完才会处理与上一次相同的信号
    sigaction(SIGCHLD, &act, NULL);//捕捉SIGCHLD信号，这个信号是关于子进程死的信号

    for (i = 0; i < atoi(argv[1]); i++) {
        if ((pid = fork())  == 0)//创建子进程
            break;
    }

    if (pid == 0) {
        while (i--) {//子进程一个一个死掉
            printf("Child %d\n", getpid());
            sleep(1);
        }
    }

    if (pid > 0) {
        while(1) {
            printf("Parent\n");
            sleep(1);
        }
    }

    return 0;
}


wait_sigchld2.c 是优化版本
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
void do_sig(int num)//此方法只调一次，因为无论多少个子进程发死的信号，未决信号集不会累加，除非捕捉函数执行完全把未决再置0
{
    //while (wait(NULL) >  0)
    while (waitpid(0, NULL, WNOHANG) >  0)
        ;//回收到一个子进程总会返回这个子进程的进程ID号，而进程ID号总是>0的，所以循环的回收僵尸进程，非阻塞，这样回收完不致于阻塞主进程
}
int main(int argc, char *argv[])
{
    pid_t pid;
    int i;
    struct sigaction act;
    if (argc < 2) {
        printf("./a.out num\n");
        return -1;
    }

    act.sa_handler = do_sig;
    act.sa_flags = 0;
    sigemptyset(&act.sa_mask);
    sigaction(SIGCHLD, &act, NULL);

    for (i = 0; i < atoi(argv[1]); i++) {
        if ((pid = fork())  == 0)
            break;
    }

    if ((pid == 0) && (i < 49)) {//只对49个子进程作如下操作，，
        int j = 0;
        while (j < 3) {//每个子进程都循环三次去打印操作，打印操作完成这个子进程才死。死了会给父进程发一个儿子死的信号。父进程切到内核，未决信号集置1，父进程还未来得及调用处理函数的时候，其它的子进程也死了。我们知道未决信号集中的儿子死的信号置1，表示这个信号如果通过阻塞信号集，将可以执行动作，及执行我们现在的捕捉函数，当完成执行捕捉函数，再把先决信号集置0.此时未执行完这个捕捉函数，其它子信号都死了，先决信号集不会累加，仍然是1，所有后面死的那些子进程都没有在捕捉函数中得到回收，因为该函数只执行了一次。有让子进程同时死掉的时候wait没来得及至0，wait收到一个子进程死会进行回收，回收完后会把未决表至0，但是没来得及至0，，所以这会儿是有僵尸进程的
            printf("Child %d\n", getpid());
            sleep(1);//子进程存在活长一些好看效果。
            j++;
        }
    }
    else if ((pid == 0) && (i==49))
        while(1)
            ;

    if (pid > 0) {
        while(1) {
            printf("Parent\n");
            sleep(1);
        }
    }

    return 0;
}


status 处理方式，告诉我们如何使用回收函数waitpid，以及判断子进程是正常

终止，还是被信号终止，还是被停止的状态。
pid_t waitpid(pid_t pid, int *status, int options)
options
WNOHANG
没有子进程结束，立即返回
WUNTRACED
如果子进程由于被停止产生的SIGCHLD， waitpid则立即返回
WCONTINUED
如果子进程由于被SIGCONT唤醒而产生的SIGCHLD， waitpid则立即返回
获取status
WIFEXITED(status)
子进程正常exit终止，返回真
WEXITSTATUS(status)返回子进程正常退出值
WIFSIGNALED(status)
子进程被信号终止，返回真
WTERMSIG(status)返回终止子进程的信号值
WIFSTOPPED(status)
子进程被停止，返回真
WSTOPSIG(status)返回停止子进程的信号值
WIFCONTINUED(status)
总结这节课：

信号集：
sigset_t信号集类型为sigset_t
sigemptyset 信号集置空
sigaddset   信号集某一位置1
sigfillset 信号集所有置1
sigdelset   信号集某一位置0
sigismember 测试一个信号是否加入到信号集中，加入了置1

未决信号集 sigpending 函数返回这个进程中为1的未决信号集，意味着有多少个

信号暂时未被处理

阻塞信号集 sigprocmask  函数可以把这个进程的阻塞信号集置1，设置它阻塞，

凡阻塞的都不能处理信号的动作。
其中参数HOW有三个标志：
1.SIG_BLOCK
2.SIG_UNBLOCK
3.SIG_SETMASK

设置捕捉函数:捕捉动作结构体 sigaction act包括(sa_handle(捕捉哪个信号) 

,sa_mask（函数执行过程中需要阻塞哪些信号）,sa_flag（使用的是哪种类型的

捕捉函数）)
sigaction(SIGCHLD，&act,NULL);//注册捕捉函数
注意，在设置捕捉函数的时候常用SIGPROCMASK先阻塞信号，以防此一开始还未注

册捕捉函数就有信息发送给进程。这会导致执行默认动作，如关闭这个程序。当

注册捕捉函数完成后再解除信号阻塞，允许接收信号。

信号可以进程同步：用SIGUSR1,SIGUSR2信号，因为这两个信号系统没有定义产生

的原因，捕捉这两个信号可以产生同步，即轮流执行的效果。

30信号和进程关系

信号与进程关系，信号章节结束

串行：程序一路执行下来，没有分支

并行：两个或多个代码段在同一时刻执行，1个CPU不能作到这点，只有两个或多个CPU能产生并行，因为需要在同一时刻执行，如在2：30分同时执行了两个或多个程序。

并发：两个或多个程序在同一时间段内执行，1个CPU可以实现并发，如在2：30-2：32之间，两个或多个程序分别得到不同的执行时间。如:2:30:20-2:30:30执行A代码片段，2:30:30-2:30:50执行B代码片段。由于时间比较短，所以感觉像是多个代码段在同时执行程序。

同步：多个代码片段交替轮流执行，能同时执行多个，能保证执行次序。因此多个代码片段的运行状态是互相关联的，一个A代码片段需阻塞等待另一个代码片段B运行结束才可以执行A代码片段。互相关联。

异步：也就是不同步，在执行过程中如果来了一个信号，有可能被打断执行其它
不能保证执行顺序，多个代码片之间的运行状态互不相关。

1.不可重入函数，异步情况不可重入函数总是安全的
主要用于多任务环境中，一个可重入的函数简单来说就是可以被中断的函数，也

就是说，可以在这个函数执行的任何时刻中断它，转入OS调度下去执行另外一段

代码，而返回控制时不会出现什么错误；而不可重入的函数由于使用了一些系统

资源，比如全局变量区，中断向量表等，所以它如果被中断的话，可能会出现问

题，这类函数是不能运行在多任务环境下的。
也可以这样理解，重入即表示重复进入，首先它意味着这个函数可以被中断，其

次意味着它除了使用自己栈上的变量以外不依赖于任何环境（包括static），这

样的函数就是purecode（纯代码）可重入，可以允许有该函数的多个副本在运行

，由于它们使用的是分离的栈，所以不会互相干扰。如果确实需要访问全局变量

（包括static），一定要注意实施互斥手段。可重入函数在并行运行环境中非常

重要，但是一般要为访问全局变量付出一些性能代价。
编写可重入函数时，若使用全局变量，则应通过关中断、信号量（即P、V操作）

等手段对其加以保护。
 说明：若对所使用的全局变量不加以保护，则此函数就不具有可重入性，即当多

个进程调用此函数时，很有可能使有关全局变量变为不可知状态。

s1 = hello world itcast abc;
s2 = aa cc bb dd ee

p1 = strtok(s1," ");
p1 = strtok(NULL," ");//不可重入函数，因为内部有statct关键字

//可重入函数
char *save;
strtok_r(s1," ",&save);
save 此时保存了"word itcast abc"
strtok_r(save," ",&save);


我们在信号捕捉函数里不去调用不可重入函数。strtok是一个不可重入函数，strtok_r是一个可重入函数。应尽量调用strtok_r



strtok_r.c  这是个不可重入函数，strtok_r拆分字符串，因为用到了static变

量，多个进程操作会产生不对的数据

#include <stdio.h>
#include <string.h>

int main(void)
{
    char buf[] = "hello world itcast";
    char *p, *save;

    p = strtok_r(buf, " ", &save);
    printf("%s\n", p);
    while ((p = strtok_r(save, " ", &save)) != NULL)
        printf("%s\n", p);

    return 0;
}

互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性

。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。

同步：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的

有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况

必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。

linux系统编程中，经常会出现“竞态(race condition)”，即多进程的资源获取

冲突或者访问时序问题。Linux提供的绝大多数系统调用函数保证函数调用过程是

原子的(并非所有的系统调用均是原子的，见附录)，即单函数调用在返回或终止

之前，该函数的操作是原子的，不受其他系统调用影响。但很多系统调用往往需

要配合使用，由多个系统调用组成的调用组合，操作系统是无法保证原子性的！

这意味着：2个以上系统调用组合在多进程环境下将出现“竞态”。如何避免竞态

是linux系统编程的一个大问题。


时序竞态，信号会引起时序竞态，竞态是一种异步的概念，即多个代码片段运行状态无关联，会去在同一时刻竞争到机会执行，所以不可控，所以需要以下函数实现一种有序竞争的状态，即同步的概念，交替执行。当代码片段A执行完后再执行代码片段B。
int pause(void)
使调用进程挂起，直到有信号递达，如果递达信号是忽略，则继续挂起
早期用来实现sleep()功能的

sigsuspend(&set)更灵活，同样的使进程挂起，直到有信号递达，如果执行了信

号相关的捕捉函数，将唤醒进程，不同的是，sigsuspend可以在挂起之前重新设

置是否要阻塞或解除阻赛的信号

pause.c kill -SIGUSR1 3871发一个信号进行测试

#include <stdio.h>
#include <unistd.h>
#include <signal.h>

void do_sig(int n)
{
    printf("hello\n");
}

int main(void)
{
    signal(SIGUSR1, do_sig);

    printf("abc\n");

    pause();//此进程挂起，不执行下面的代码，直到有信号递达，如果递达信

号是忽略，则继续挂起

    printf("itcast\n");

    return 0;
}

mysleep.c 实现一个类似于sleep的函数

#include <unistd.h>
#include <signal.h>
#include <stdio.h>
void sig_alrm(int signo)
{
    /* nothing to do */
}
unsigned int mysleep(unsigned int nsecs)
{
    struct sigaction newact, oldact;//设置捕捉动作的结构体
    unsigned int unslept;
    
    newact.sa_handler = sig_alrm;//捕捉函数名
    sigemptyset(&newact.sa_mask);//捕捉函数执行过程中如果有其它信号不阻

塞进，接收
    newact.sa_flags = 0;//捕捉函数的类型默认为第一种类型
    sigset_t set, oldset;//设置两个信号集
    sigemptyset(&set);//清空所有信号集为0
    sigaddset(&set, SIGALRM);//把信号集中的其中一个置1
    sigprocmask(SIG_BLOCK, &set, &oldset);     //当前阻塞SIGALRM，并将

信号保存到oldset中

    sigaction(SIGALRM, &newact, &oldact);//注册捕捉函数sig_arlm,捕捉

SIGALRM信号
    alarm(nsecs);//经过nsecs2秒后操作系统会向进程发一个SIGALRM信号，定

时开始程序继续往下执行
    //系统负载严重，当前进程得不到cpu
    
    //pause();//如果alarm(1)定时一秒，很快执行完，pause()还没有执行，所

以捕捉函数比pause()先执行,pause后执行并不知道捕捉函数执行完了，所以一直

挂起。程序挂起，下面代码不执行，直到收到SIGALRM信号并处理捕捉函数后才往

下执行
    sigdelset(&set, SIGALRM);   //构造新的信号集，为了替代pause的功能
    sigsuspend(&set);           //设置临时解除对SIGALRM的阻塞，然后挂起

。为了替代pause的功能
    
    unslept = alarm(0);         //   alarm(0)定时10秒已经过了3秒了，我

想修改为20秒，这时返回的unslep值为7，即定时器余下的时间，这里alarm(0)，

用来看是否有外部发alarm信号给程序，如果发了，返回值不为0
    sigaction(SIGALRM, &oldact, NULL);

    sigprocmask(SIG_SETMASK, &oldset, NULL);     //当实现了睡眠功能，需

还原之前的阻塞信号集。sleep()只想程序睡眼，不应该改变阻塞进情况。

    return unslept;
}
int main(void)
{
    mysleep(1);
    printf("Two seconds passed\n");
    return 0;
}


3.避免异步io类型。
原子类型.jpg
定义一个long long n;的变量
这个变量高4地址0x11223344
这个变量低4地址0x55667788
do_sig()
{
    n=0xaabbccdd000000;//在捕捉函数给n赋值
}
main()
{
    n = 0x1122334455667788;//在主函数给n赋值 ，由于32位系统下，汇编赋值需要分两次进行，给高4个字节地址赋值，再给低4个地址赋值。

所以会产生一种情况，刚给高4个字节赋值完成时，信号产生了，来到捕捉函数，捕捉函数把整个n赋了值，捕捉函数完成以后，再执行n为低地址赋值的代码。最终重到的n值是一个四不像的值。
}

如果变量是long long，在捕捉函数操作时需要注意了。所以在这里把变量引入了一个原子类型，指变量是不可分割的。 必须修改完这个变量再执行其它的函数 

sig_atomic_t 如果电脑是32位，用这个去定义，它会根据不同位数的操作系统，自动把变量翻译成int ,long,long long，我们知道int,long无论在32还是64位下都是不用分割成两部份去执行的。避免异步I/O的类型 

volatile.jpg
volatilr 防止编译器开启优化选项时，优化性能

volatile int a = 10;//a是局部变量，存在栈上，a=10，cpu有一个寄存器eax，每次从内存中取变量a,然后用a与10作比较，编译器比较智能，不用10次都从内存都取a,如果知道a没有被改变过，只从内存取一次a作比较。这叫编译器优化。
cup每次把内存中的变量取到寄存器，这叫I/O操作，即读写内存。

所以加volatile ，表示每次都去内存中加载变量到cpu中，每次都去加载这个值。不对编译器作优化。
while(a ==10)
{
   printf("hello");
}


扩展，向信号捕捉函数传参，这个用得不多，两个进程，一个进程发一个地址给另一个进程的地址，另一个进程并不能访问到我发进程的那个地址，所以用得不多。

int sigqueue(pid_t pid,int sig,const union sigval value)//可以给一个进程发送一个sig信号，同时带一个参数value;
union sigval{//联合体类型
	int sival_int;//它可以是一个整形变量
        void *sival_ptr;//也可以是一个指针变量
};

怎么捕捉这个信号呢？

struct sigaction
{
	void (*sa_handler)(int);//捕捉上面sigqueue发的整形参数
        void (*sa_sigaction)(int ,siginfo_t *,void *);//捕捉sigqueue发的指针变量
        sigset_t sa_mask;
        int sa_flags;
        void (*sa_restorer)(void);
};

void (*sa_sigaction)(int, siginfo_t *, void *)
siginfo_t {
int si_int; /* POSIX.1b signal */
void *si_ptr; /* POSIX.1b signal *///捕捉函数接收指针用这个变量
sigval_t si_value; /* Signal value */
...
}
sa_flags = SA_SIGINFO//接收指针类型时需设置这个

传指针用得不多，因为指针只是当前进程的地址，传给另一个进程是拿不到这个地址的。所以不常用捕捉函数传参。
 进程自己收发信号，在同一地址空间
* 不同进程间收发信号，不在同一地址空间,不适合传地址

终端：打开一个命令行窗口，是一个终端，
终端里面又运行了好几个shell。
cat /etc/shells //查看shells的环境变量
/bin/sh
/bin/dash
/bin/bash  目前我们用的是bash终端
/bin/rbash

系统登录过程
当我切换到一个终端，输入用户名密码。会进入密码验证模块，登录上来启动了

一个bash类型的shell.
远程登录相当于获取到了一个远程的bash.

服务器终端启动过程

系统init一个进程 ->fork(子进程)--->exec（执行）->getty()->得到一个终端
->用户输入账号->login->密码验证->exec->shell(启动shell)

dev/tty 是一个泛型指针
切换终端会得到不同tty1,...tty7，tty1--tty6是字符终端，没有鼠标
alt+F7可以切换到图形终端tty7
ctrl + alt  + F1...F6 可以切到字符终端

图形界面也是一个终端，只是不叫tty，可以根据文件描述符获取终端名

ttyname.c


./a.out执行文件描述符0，1，2的终端
/dev/pts/1
/dev/pts/1
/dev/pts/1

/dev/tty表示访问当前窗口下的终端，因为不同终端的名可能不一样，

用/dev/tty泛型来表示



用户进程空间
opne/read/write/ioctl... 可以回写给系统调用
--------------
内核空间
read/write等 系统调用再把字符交给用户空间

line discipline  筛选输入的字符传给系统调用

终端设备驱动(处理文字)
_______________________



如果是一个ctrl+c，传给筛子，筛选出这条命令，发现不是普通字符
交给内核，由内核发一个信号给用户空间。



ssh ,telnetd 远程登陆终端的过程

telent客户端1 
用户进程
——————--
内核
   TCP/IP协议栈(封装数据和TCP/IP协议)

   交给网终设备驱动（数据链路层）

   通过网络设备驱动传输给客户端2（光纤）（物理层）

telent客户端2
解包，最后把数据传给伪终端主设备

再传给伪终端从设置

再交给line discipline 过滤到没用的东西

交给系统调用

最后交给bash(shell的名字)进程

bash开启子进程执行一个结果再原路返回


进程组：
进程有父子，兄弟，爷孙关系。
同时有组关系

ps ajx

ppid 当前进程的父亲进程ID
pid  当前进程ID
PGID 表示进程所属的组ID 

父进程和子进程都在一个组ID中。每个进程都有一个PID，也有一个groupID.
通常父进程的组ID就是父进程的PID，其它子ID的组ID也是这个父进程的PID
例 ：父PID =1000 组ID=1000
它的子组ID=1000

如果a.out就一个进程，它的组ID和自己的PID相同

如果想杀死一个进程，但这个进程有许多子进程，一个个杀不好用，可以直接杀

掉主ID。

kill -SIGKILL -1000杀掉这个组号为1000下面的所有进程
kill -SIGKILL 1000只杀掉了父进程

pid_t getpgid(pid_t pid);//可以得到组ID号
pid_t getpgrp(void)//得到组ID号，不用传参，谁调用传谁。posix.1函数
pid_t getpgrp(piid_t pid)//得到组ID号，只是这个函数是属于BSD标准的

进程组
linux遵守的是posix.1函数

组ID号一般是父进程ID号，父进程是组长进程。
组长进程可以创建一个进程组，组长退出了，进程组还在，子进程的组ID还是父

进程的组ID

父PID =1000  fork 子进程，所有子进程 组ID=1000,当你进程死了，进程组还在
其组生长周期是当组中没有进程的时候进程组结束

一个进程可以为自己或自己的子进程设置组ID。
int setpgid(pid_t pid,pid_t pgid) 把一个进程设到其它进程组
如改变子进程为新的组，应在fork后，exec前使用
非root 进程只能改变自己创建的子进程，或有权限操作的进程，也就表示a进程

如果有足够大的权限，它能够改变其它进程非子进程的组ID。

waitpid()  父进程waitpid(0,NULL,WNOHANG)如果传0，只回收和父进程一组的子

进程，-1，是回收只要是自己的孩子，不管是哪一组，都回收子进程。<-1回收任

意子进程，这些进程只属于一个1001组IDwaitpid(-1001,NULL,WNOHANG)
>0


setpgid.c

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main(void)
{
    pid_t pid;

    if ((pid = fork()) < 0) {
        perror("fork");
        exit(1);
    } 
    else if (pid == 0) {//子ID
        printf("child process PID is %d\n",getpid());
        printf("Group ID of child is %d\n",getpgid(0)); // 返回组id
        sleep(5);//睡5秒
        printf("Group ID of child is changed to %d\n",getpgid(0));//再

打印组ID
        exit(0);
    }
    sleep(1);
    setpgid(pid,pid); // 父进程改变子进程的组id为子进程本身
    sleep(5);//父睡5秒
    printf("parent process PID is %d\n",getpid());
    printf("parent of parent process PID is %d\n",getppid());
    printf("Group ID of parent is %d\n",getpgid(0));
    setpgid(getpid(),getppid()); // 改变父进程的组id为父进程的父进程
    printf("Group ID of parent is changed to %d\n",getpgid(0));
    return 0;
}






会话
pid_t setsid(void)
ps -ajx

SID 会话ID

启动两个cat 发现父进程ID相同，进程号不同，进程组不同，但是会话ID相同
会话ID其实是bash pid,也就是终端shell的pid
cat &
cat &

当关掉这个终端，两个cat进程没有了。

bash也就是shell，它有一个ID，它的进程ID和当前会话的ID相同。
当关掉终端，产生SIGHUP信号，由shell启动的所有进程将收到这个信号，默认执

行关闭动作。

怎样让SIGHUP信号不使shell启动的进程关闭呢。
方法1：捕捉这个信号进行处理。
方法2：setsid()让进程的会话id改变。这时产生SIGHUP信号，系统会认为这个进

程脱离会话，所以不会收到SIGHUP信号。父进程退掉时它的其它ID不变，只改变

了会话ID

pid_t setsid(void)//只是为进程设置到了新的会话组，但用kill -9 仍然可以

杀死这个进程，只是关掉终端这个进程还在
1，调用进程不能是父进程，只能是父进程，该进程变成新会话首进程，
2. 该进程成为一个新的进程组的组长
3.需有root权限才能执行这个函数
4.新会话丢弃原有的终端，该会话没有终端，也就是没有窗口
5.如果是组长进程调用这个函数会出错
5，建立新会话时步骤，先调用fork,父进程终止，子进程调用setsid

setsid.c   进程每两秒往磁盘打印一个时间，而且是可以关掉终端下运行的

#include <stdio.h>
#include <time.h>

int main(void)
{
    time_t date;
    FILE *fp = fopen(".tmpfile", "a+");
    pid_t pid;

    if ((pid = fork()) > 0)
        return 0;
    setsid();
    while (1) {
        time(&date);
        char *p = ctime(&date);
        fprintf(fp, "%s", p);
        fflush(fp);
        sleep(2);
    }

    return 0;
}



守护进程：
一般都是服务器程序，一直运行，如ftp服务

ps jax | grep ftp  
可以查看到ftp一直开着，nfsd,sshd.
一般进程名字都有一个后缀d，表示是守护进程，Daemon是精灵进程，是后台服务

进程，生存期比较长，通常独立于控制终端并且周期性地执行某种任务或等待处

理某些发生的事情。

1. 创建子进程，父进程退出
所有工作在子进程中进行
　　形式上脱离了控制终端
2. 在子进程中创建新会话
　　setsid()函数
　　使子进程完全独立出来，脱离控制
3. 改变当前目录为根目录
　　chdir()函数
　　防止占用可卸载的文件系统
　　也可以换成其它路径
u盘 中有个文件，其它程序索引占有这文件，这个文件不能删除
如果两主机，一组机通过NFS 挂载了，这时一主机有a.out，另一台主机
执行a.out.chdir("/")让程序不再索引占有的这个文件，这时a.out
可以删除掉

文件不能删除，是因为有程序在索引这个文件，把文件索引改变后
文件能删除

4.
重设文件权限掩码
　　umask()函数
　　防止继承的文件创建屏蔽字拒绝某些权限
　　增加守护进程灵活性
FTP，接收文件先创建文件，指定文件权限位，UMASK()重置，这时这个守护进程

的权限位不受原来文字的干扰。增加守护进程灵活性。

5.
 关闭文件描述符
　　继承的打开文件不会用到，浪费系统资源，无法卸载
关闭文件描述符
一个守护进程，每个进程默认打开三个文件描述符0，1，2.，当调用setsid()后

，0，1，2，三个文件描述符没意义了，不指向之前的终端，所以解决方法，关掉

0,1,2,当prinf("hello");  fflush(stdout);这时会出错，此时这种方法不好，

可以用另一种方法：0，1，2指向到/dev/null文件下。这是一个黑洞文件,相当于

垃圾洞，接收到的东西都丢掉。


6.开始执行守护进程核心工作一般是一个while(1)

7.守护进程退出处理。一般通过信号让守护进程停止，所以编写捕捉函数，让捕

捉函数作一些退出前的其它处理。



cat file.tar.gz>/dev/null
ls /dev/null

chdir.c   主要是显示上面第4步骤的含义


#include <stdio.h>
#include <unistd.h>

int main(void)
{
    char buf[1024];
    printf("%s\n", getcwd(buf, sizeof(buf)));//打印当前路径
    while (1)
        ;
    chdir("/");//改变到根目录下
    printf("%s\n", getcwd(buf, sizeof(buf)));//再打印当前路径，因为这个

程序可以放U盘执行，如果把根路径切到根目录，可以空易缷载U盘程序，其实是

把pwd路径改了。只是告诉加载器运行这个程序在哪个程序去找，为防止守护进程

在U盘里运行不能卸载。
    return 0;
}

习题
1.每隔10s在/tmp/dameon.log中写入当前时间
2.编写监控/home/usr/目录下文件创建与更改的守护进程，日志文件放在/home/usr/
filechangelog

怎么记录一个文件是创建，或是更改
stat feesk.c
统计出每个文件的更改时间，每5秒再统计下时间，与前一次比较，修改的写到本地文件日志里，但有小BUG，当1秒内创建再删除文件后无记录。









扩展：2.怎样让进程挂起到后台有以下几种方法：不一定看
ps -f
我们经常会碰到这样的问题，用 telnet/ssh 登录了远程的 Linux 服务器，运行

了一些耗时较长的任务， 结果却由于网络的不稳定导致任务中途失败。如何让命

令提交后不受本地关闭终端窗口/网络断开连接的干扰呢？下面举了一些例子， 

您可以针对不同的场景选择不同的方式来处理这个问题。
nohup/setsid/&
场景：
如果只是临时有一个命令需要长时间运行，什么方法能最简便的保证它在后台稳

定运行呢？
hangup 名称的来由
在 Unix 的早期版本中，每个终端都会通过 modem 和系统通讯。当用户 logout 

时，modem 就会挂断（hang up）电话。 同理，当 modem 断开连接时，就会给终

端发送 hangup 信号来通知其关闭所有子进程。
解决方法：
我们知道，当用户注销（logout）或者网络断开时，终端会收到 HUP（hangup）

信号从而关闭其所有子进程。因此，我们的解决办法就有两种途径：要么让进程

忽略 HUP 信号，要么让进程运行在新的会话里从而成为不属于此终端的子进程。
1. nohup
nohup 无疑是我们首先想到的办法。顾名思义，nohup 的用途就是让提交的命令

忽略 hangup 信号。让我们先来看一下 nohup 的帮助信息：
NOHUP(1)                        User Commands                        

NOHUP(1)

NAME
       nohup - run a command immune to hangups, with output to a non-

tty

SYNOPSIS
       nohup COMMAND [ARG]...
       nohup OPTION

DESCRIPTION
       Run COMMAND, ignoring hangup signals.

       --help display this help and exit

       --version
              output version information and exit
可见，nohup 的使用是十分方便的，只需在要处理的命令前加上 nohup 即可，标

准输出和标准错误缺省会被重定向到 nohup.out 文件中。一般我们可在结尾加上

"&"来将命令同时放入后台运行，也可用">filename 2>&1"来更改缺省的重定向文

件名。
nohup 示例
[root@pvcent107 ~]# nohup ping www.ibm.com &
[1] 3059
nohup: appending output to `nohup.out'
[root@pvcent107 ~]# ps -ef |grep 3059
root      3059   984  0 21:06 pts/3    00:00:00 ping www.ibm.com
root      3067   984  0 21:06 pts/3    00:00:00 grep 3059
[root@pvcent107 ~]#
2。setsid
nohup 无疑能通过忽略 HUP 信号来使我们的进程避免中途被中断，但如果我们换

个角度思考，如果我们的进程不属于接受 HUP 信号的终端的子进程，那么自然也

就不会受到 HUP 信号的影响了。setsid 就能帮助我们做到这一点。让我们先来

看一下 setsid 的帮助信息：
SETSID(8)                 Linux Programmer’s Manual                 

SETSID(8)

NAME
       setsid - run a program in a new session

SYNOPSIS
       setsid program [ arg ... ]

DESCRIPTION
       setsid runs a program in a new session.
可见 setsid 的使用也是非常方便的，也只需在要处理的命令前加上 setsid 即

可。
setsid 示例
[root@pvcent107 ~]# setsid ping www.ibm.com
[root@pvcent107 ~]# ps -ef |grep www.ibm.com
root     31094     1  0 07:28 ?        00:00:00 ping www.ibm.com
root     31102 29217  0 07:29 pts/4    00:00:00 grep www.ibm.com
[root@pvcent107 ~]#
值得注意的是，上例中我们的进程 ID(PID)为31094，而它的父 ID（PPID）为1（

即为 init 进程 ID），并不是当前终端的进程 ID。请将此例与nohup 例中的父 

ID 做比较。
3。&
这里还有一个关于 subshell 的小技巧。我们知道，将一个或多个命名包含

在“()”中就能让这些命令在子 shell 中运行中，从而扩展出很多有趣的功能，

我们现在要讨论的就是其中之一。
当我们将"&"也放入“()”内之后，我们就会发现所提交的作业并不在作业列表中

，也就是说，是无法通过jobs来查看的。让我们来看看为什么这样就能躲过 HUP 

信号的影响吧。
subshell 示例
[root@pvcent107 ~]# (ping www.ibm.com &)
[root@pvcent107 ~]# ps -ef |grep www.ibm.com
root     16270     1  0 14:13 pts/4    00:00:00 ping www.ibm.com
root     16278 15362  0 14:13 pts/4    00:00:00 grep www.ibm.com
[root@pvcent107 ~]#
从上例中可以看出，新提交的进程的父 ID（PPID）为1（init 进程的 PID），并

不是当前终端的进程 ID。因此并不属于当前终端的子进程，从而也就不会受到当

前终端的 HUP 信号的影响了。
回页首
disown
场景：
我们已经知道，如果事先在命令前加上 nohup 或者 setsid 就可以避免 HUP 信

号的影响。但是如果我们未加任何处理就已经提交了命令，该如何补救才能让它

避免 HUP 信号的影响呢？
解决方法：
这时想加 nohup 或者 setsid 已经为时已晚，只能通过作业调度和 disown 来解

决这个问题了。让我们来看一下 disown 的帮助信息：
disown [-ar] [-h] [jobspec ...]
	Without options, each jobspec is  removed  from  the  table  of
	active  jobs.   If  the -h option is given, each jobspec is not
	removed from the table, but is marked so  that  SIGHUP  is  not
	sent  to the job if the shell receives a SIGHUP.  If no jobspec
	is present, and neither the -a nor the -r option  is  supplied,
	the  current  job  is  used.  If no jobspec is supplied, the -a
	option means to remove or mark all jobs; the -r option  without
	a  jobspec  argument  restricts operation to running jobs.  The
	return value is 0 unless a jobspec does  not  specify  a  valid
	job.
可以看出，我们可以用如下方式来达成我们的目的。
灵活运用 CTRL-z
在我们的日常工作中，我们可以用 CTRL-z 来将当前进程挂起到后台暂停运行，

执行一些别的操作，然后再用 fg 来将挂起的进程重新放回前台（也可用 bg 来

将挂起的进程放在后台）继续运行。这样我们就可以在一个终端内灵活切换运行

多个任务，这一点在调试代码时尤为有用。因为将代码编辑器挂起到后台再重新

放回时，光标定位仍然停留在上次挂起时的位置，避免了重新定位的麻烦。
用disown -h jobspec来使某个作业忽略HUP信号。
用disown -ah 来使所有的作业都忽略HUP信号。
用disown -rh 来使正在运行的作业忽略HUP信号。
需要注意的是，当使用过 disown 之后，会将把目标作业从作业列表中移除，我

们将不能再使用jobs来查看它，但是依然能够用ps -ef查找到它。
但是还有一个问题，这种方法的操作对象是作业，如果我们在运行命令时在结尾

加了"&"来使它成为一个作业并在后台运行，那么就万事大吉了，我们可以通过

jobs命令来得到所有作业的列表。但是如果并没有把当前命令作为作业来运行，

如何才能得到它的作业号呢？答案就是用 CTRL-z（按住Ctrl键的同时按住z键）

了！
CTRL-z 的用途就是将当前进程挂起（Suspend），然后我们就可以用jobs命令来

查询它的作业号，再用bg jobspec来将它放入后台并继续运行。需要注意的是，

如果挂起会影响当前进程的运行结果，请慎用此方法。
disown 示例1（如果提交命令时已经用“&”将命令放入后台运行，则可以直接使

用“disown”）
[root@pvcent107 build]# cp -r testLargeFile largeFile &
[1] 4825
[root@pvcent107 build]# jobs
[1]+  Running                 cp -i -r testLargeFile largeFile &
[root@pvcent107 build]# disown -h %1
[root@pvcent107 build]# ps -ef |grep largeFile
root      4825   968  1 09:46 pts/4    00:00:00 cp -i -r testLargeFile 

largeFile
root      4853   968  0 09:46 pts/4    00:00:00 grep largeFile
[root@pvcent107 build]# logout
disown 示例2（如果提交命令时未使用“&”将命令放入后台运行，可使用 

CTRL-z 和“bg”将其放入后台，再使用“disown”）
[root@pvcent107 build]# cp -r testLargeFile largeFile2

[1]+  Stopped                 cp -i -r testLargeFile largeFile2
[root@pvcent107 build]# bg %1
[1]+ cp -i -r testLargeFile largeFile2 &
[root@pvcent107 build]# jobs
[1]+  Running                 cp -i -r testLargeFile largeFile2 &
[root@pvcent107 build]# disown -h %1
[root@pvcent107 build]# ps -ef |grep largeFile2
root      5790  5577  1 10:04 pts/3    00:00:00 cp -i -r testLargeFile 

largeFile2
root      5824  5577  0 10:05 pts/3    00:00:00 grep largeFile2
[root@pvcent107 build]#
回页首
screen
场景：
我们已经知道了如何让进程免受 HUP 信号的影响，但是如果有大量这种命令需要

在稳定的后台里运行，如何避免对每条命令都做这样的操作呢？
解决方法：
此时最方便的方法就是 screen 了。简单的说，screen 提供了 ANSI/VT100 的终

端模拟器，使它能够在一个真实终端下运行多个全屏的伪终端。screen 的参数很

多，具有很强大的功能，我们在此仅介绍其常用功能以及简要分析一下为什么使

用 screen 能够避免 HUP 信号的影响。我们先看一下 screen 的帮助信息：
SCREEN(1)                                                           

SCREEN(1)

NAME
       screen - screen manager with VT100/ANSI terminal emulation

SYNOPSIS
       screen [ -options ] [ cmd [ args ] ]
       screen -r [[pid.]tty[.host]]
       screen -r sessionowner/[[pid.]tty[.host]]

DESCRIPTION
       Screen  is  a  full-screen  window manager that multiplexes a 

physical
       terminal between several  processes  (typically  interactive  

shells).
       Each  virtual  terminal provides the functions of a DEC VT100 

terminal
       and, in addition, several control functions from the  ISO  6429  

(ECMA
       48,  ANSI  X3.64)  and ISO 2022 standards (e.g. insert/delete 

line and
       support for multiple character sets).  There is a  scrollback  

history
       buffer  for  each virtual terminal and a copy-and-paste 

mechanism that
       allows moving text regions between windows.
使用 screen 很方便，有以下几个常用选项：
用screen -dmS session name来建立一个处于断开模式下的会话（并指定其会话

名）。
用screen -list 来列出所有会话。
用screen -r session name来重新连接指定会话。
用快捷键CTRL-a d 来暂时断开当前会话。
screen 示例
[root@pvcent107 ~]# screen -dmS Urumchi
[root@pvcent107 ~]# screen -list
There is a screen on:
        12842.Urumchi   (Detached)
1 Socket in /tmp/screens/S-root.

[root@pvcent107 ~]# screen -r Urumchi
当我们用“-r”连接到 screen 会话后，我们就可以在这个伪终端里面为所欲为

，再也不用担心 HUP 信号会对我们的进程造成影响，也不用给每个命令前都加上

“nohup”或者“setsid”了。这是为什么呢？让我来看一下下面两个例子吧。
1. 未使用 screen 时新进程的进程树
[root@pvcent107 ~]# ping www.google.com &
[1] 9499
[root@pvcent107 ~]# pstree -H 9499
init─┬─Xvnc
     ├─acpid
     ├─atd
     ├─2*[sendmail]	
     ├─sshd─┬─sshd───bash───pstree
     │       └─sshd───bash───ping
我们可以看出，未使用 screen 时我们所处的 bash 是 sshd 的子进程，当 ssh 

断开连接时，HUP 信号自然会影响到它下面的所有子进程（包括我们新建立的 

ping 进程）。
2. 使用了 screen 后新进程的进程树
[root@pvcent107 ~]# screen -r Urumchi
[root@pvcent107 ~]# ping www.ibm.com &
[1] 9488
[root@pvcent107 ~]# pstree -H 9488
init─┬─Xvnc
     ├─acpid
     ├─atd
     ├─screen───bash───ping
     ├─2*[sendmail]
而使用了 screen 后就不同了，此时 bash 是 screen 的子进程，而 screen 是 

init（PID为1）的子进程。那么当 ssh 断开连接时，HUP 信号自然不会影响到 

screen 下面的子进程了。
回页首
总结
现在几种方法已经介绍完毕，我们可以根据不同的场景来选择不同的方案。

nohup/setsid 无疑是临时需要时最方便的方法，disown 能帮助我们来事后补救

当前已经在运行了的作业，而 screen 则是在大批量操作时不二的选择了。
